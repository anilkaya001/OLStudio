<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<meta name="theme-color" content="#050505"/>

<meta http-equiv="Content-Security-Policy" content="
    default-src 'self'; 
    script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; 
    style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://fonts.googleapis.com; 
    font-src https://fonts.gstatic.com; 
    img-src 'self' data:; 
    connect-src 'self'; 
    object-src 'none';
">

<title>Anıl Kaya | Research and Articles</title>
<meta name="description" content="Academic articles and research by Anıl Kaya">
<link rel="canonical" href="https://anilkaya.com/">

<!-- Fonts and Math -->
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sugina-dev/latin-modern-web@1.0.1/style/latinmodern-roman.css" crossorigin="anonymous"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sugina-dev/latin-modern-web@1.0.1/style/latinmodern-sans.css" crossorigin="anonymous"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">

<script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js" crossorigin="anonymous"></script>

<style>
:root{
    /* Strict Dark Theme Configuration */
    color-scheme: dark;
    --font-main: "Latin Modern Roman", serif;
    --font-ui: "Latin Modern Sans", sans-serif;
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-bottom: env(safe-area-inset-bottom, 0px);
    --nav-h: 72px;
    
    --bg: #050505;
    --border: rgba(255, 255, 255, 0.08);
    --silver: #e8e8ea;
    --silver-dim: rgba(232, 232, 234, 0.65);
    --gold: #D4AF37;
    --gold-soft: #F7E7CE;
    
    --paper-bg: rgba(12, 12, 14, 0.95);
    --paper-border: rgba(255, 255, 255, 0.08);
    --paper-shadow: 0 40px 100px rgba(0,0,0,0.95), 0 0 0 1px rgba(255,255,255,0.05) inset;
}

html, body { height: 100%; }
body {
    margin: 0;
    background: var(--bg);
    color: var(--silver);
    font-family: var(--font-main);
    overflow: hidden; /* Prevent body scrolling */
    -webkit-font-smoothing: antialiased; 
    -moz-osx-font-smoothing: grayscale;
    transition: background-color 0.5s ease;
}

/* Blur the 3D canvas when modal is open */
body.modal-open #gl {
    filter: blur(14px) brightness(0.4);
    transform: scale(1.02);
}
body.modal-open #depthName, body.modal-open #orbitHint {
    opacity: 0 !important;
}

* { box-sizing: border-box; }
a { color: var(--gold-soft); text-decoration: none; }
a:hover { opacity: 0.9; }
:focus-visible { outline: 2px solid color-mix(in oklab, var(--gold) 65%, #fff); outline-offset: 3px; border-radius: 14px; }

/* Symmetrical, Ultra-Modern Navigation */
#nav {
    position: fixed; top: 0; left: 0; right: 0;
    height: calc(var(--nav-h) + var(--safe-top));
    padding-top: var(--safe-top);
    padding-left: clamp(24px, 6vw, 64px);
    padding-right: clamp(24px, 6vw, 64px);
    display: flex; align-items: center; justify-content: space-between;
    z-index: 1000;
    border-bottom: 1px solid var(--border);
    background: radial-gradient(1200px 600px at 50% 0%, rgba(212,175,55,0.04), rgba(0,0,0,0.0) 80%),
                linear-gradient(180deg, color-mix(in oklab, var(--bg) 95%, transparent), color-mix(in oklab, var(--bg) 50%, transparent));
    backdrop-filter: blur(24px);
    -webkit-backdrop-filter: blur(24px);
    transition: transform 0.4s ease;
}

body.modal-open #nav { transform: translateY(-100%); }

#brand {
    appearance: none; border: none; background: transparent; 
    font-family: var(--font-ui); font-size: 0.95rem; font-weight: 900; 
    letter-spacing: 2.5px; text-transform: uppercase; 
    color: var(--silver);
    user-select: none; white-space: nowrap; cursor: pointer; padding: 0; 
    transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), text-shadow 0.3s ease;
}
#brand:hover { 
    transform: translateY(-1px); 
    text-shadow: 0 4px 15px rgba(212,175,55,0.3); 
    color: var(--gold);
}

#actions { display: flex; align-items: center; gap: 16px; }

.btn {
    font-family: var(--font-ui); font-size: 0.75rem; font-weight: 700; 
    letter-spacing: 1.2px; text-transform: uppercase; 
    padding: 10px 24px; border-radius: 30px; border: 1px solid var(--border); 
    background: color-mix(in oklab, var(--bg) 40%, transparent); 
    color: var(--silver); cursor: pointer; backdrop-filter: blur(14px); 
    transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
    -webkit-user-select: none; user-select: none; touch-action: manipulation; 
    min-height: 40px; display: flex; align-items: center; justify-content: center; 
    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
}
.btn:hover {
    background: var(--gold); border-color: var(--gold); color: #000; 
    transform: translateY(-2px); 
    box-shadow: 0 8px 20px color-mix(in oklab, var(--gold) 25%, transparent);
}

/* Symmetrical Copyright Footer */
#copyright {
    position: fixed; bottom: clamp(16px, 4vw, 28px); left: 50%; transform: translateX(-50%);
    font-family: var(--font-ui); font-size: 0.70rem; font-weight: 600;
    letter-spacing: 2px; text-transform: uppercase;
    color: color-mix(in oklab, var(--silver) 35%, transparent);
    z-index: 500; pointer-events: none; user-select: none; text-align: center; white-space: nowrap;
    transition: opacity 0.4s ease;
}
body.modal-open #copyright { opacity: 0; }

@media (max-width: 900px) {
  #actions { gap: 10px; }
  .btn { padding: 8px 16px; font-size: 0.7rem; min-height: 36px; }
}

#gl { position: fixed; inset: 0; width: 100%; height: 100%; display: block; z-index: 1; touch-action: none; user-select: none; transition: filter 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1); }

/* Breathing Animation for Depth Name */
@keyframes breath {
    0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.85; filter: blur(0.2px); }
    50% { transform: translate(-50%, -50%) scale(1.03); opacity: 1; filter: blur(0px); }
}

#depthName {
    position: fixed; left: 50%; top: 50%; 
    z-index: 650; pointer-events: none; 
    font-family: var(--font-main); font-weight: 300; letter-spacing: 0.06em;
    font-size: clamp(1.8rem, 6vw, 7rem); color: rgba(212,175,55,0.20); 
    text-shadow: 0 0 60px rgba(212,175,55,0.15); 
    white-space: nowrap; text-align: center; width: 100%; line-height: 1; 
    animation: breath 8s infinite ease-in-out;
    transition: opacity 0.5s ease;
}
#depthName::after {
    content: ""; position: absolute; inset: -30px -80px; 
    background: radial-gradient(closest-side, rgba(232,232,234,0.08), rgba(0,0,0,0.0) 70%); 
    z-index: -1; filter: blur(12px); opacity: 0.50;
}
#orbitHint {
    position: fixed; inset: 0; z-index: 600; pointer-events: none; opacity: 0.55; 
    background: radial-gradient(circle at 50% 50%, rgba(212,175,55,0.08) 0%, rgba(212,175,55,0.04) 20%, rgba(232,232,234,0.02) 34%, rgba(0,0,0,0.0) 60%),
                conic-gradient(from 220deg at 50% 50%, rgba(212,175,55,0.10), rgba(122,166,255,0.04), rgba(232,232,234,0.06), rgba(212,175,55,0.10));
    mask: radial-gradient(circle at 50% 50%, rgba(0,0,0,0) 0 26%, rgba(0,0,0,1) 34% 42%, rgba(0,0,0,0) 60%); 
    -webkit-mask: radial-gradient(circle at 50% 50%, rgba(0,0,0,0) 0 26%, rgba(0,0,0,1) 34% 42%, rgba(0,0,0,0) 60%); 
    filter: blur(0.6px);
    transition: opacity 0.5s ease;
}

/* ==========================================================================
   SEAMLESS READER MODAL
   ========================================================================== */
#modal { position: fixed; inset: 0; z-index: 2000; display: none; background: rgba(0,0,0,0.3); touch-action: manipulation; opacity: 0; transition: opacity 0.5s cubic-bezier(0.2, 0.8, 0.2, 1); }
#modal.open { display: block; opacity: 1; }

/* Progress Bar */
#readProgress {
    position: fixed; top: 0; left: 0; height: 3px; background: var(--gold);
    width: 0%; z-index: 2100; transition: width 0.1s;
    box-shadow: 0 0 10px var(--gold);
}

#modalBody {
    position: absolute; inset: 0;
    overflow-y: auto; overflow-x: hidden;
    padding: clamp(60px, 10vw, 120px) 20px; 
    -webkit-user-select: text; user-select: text; touch-action: pan-y;
    scroll-behavior: smooth;
    display: flex; justify-content: center; align-items: flex-start;
}

/* Elegant Scrollbar */
#modalBody::-webkit-scrollbar { width: 8px; background: transparent; }
#modalBody::-webkit-scrollbar-track { background: transparent; }
#modalBody::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 10px; border: 2px solid var(--paper-bg); }
#modalBody::-webkit-scrollbar-thumb:hover { background: var(--gold); }

/* Floating Close Button */
#closeBtn {
    position: fixed; top: clamp(20px, 4vw, 36px); right: clamp(20px, 4vw, 48px);
    width: 52px; height: 52px; border-radius: 50%;
    background: rgba(20, 20, 20, 0.8); border: 1px solid var(--paper-border);
    color: var(--silver); cursor: pointer;
    display: flex; justify-content: center; align-items: center;
    box-shadow: 0 8px 30px rgba(0,0,0,0.4);
    z-index: 2010; transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
}
#closeBtn:hover {
    transform: scale(1.1) rotate(90deg);
    background: var(--gold); color: #000; border-color: var(--gold);
    box-shadow: 0 12px 30px color-mix(in oklab, var(--gold) 40%, transparent);
}
#closeBtn svg { width: 24px; height: 24px; stroke: currentColor; stroke-width: 2.2; stroke-linecap: round; stroke-linejoin: round; }

/* The "Paper" */
.article-wrapper {
    background: var(--paper-bg);
    border: 1px solid var(--paper-border);
    box-shadow: var(--paper-shadow);
    border-radius: 16px;
    width: 100%;
    max-width: 860px;
    padding: clamp(50px, 8vw, 100px) clamp(30px, 7vw, 90px);
    transform: translateY(60px) scale(0.96);
    opacity: 0;
    position: relative;
}

/* Subtle paper texture */
.article-wrapper::before {
    content: ""; position: absolute; inset: 0; border-radius: inherit;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.03'/%3E%3C/svg%3E");
    pointer-events: none; z-index: -1;
}

#modal.open .article-wrapper {
    animation: paperRise 0.8s cubic-bezier(0.16, 1, 0.3, 1) forwards;
}

@keyframes paperRise {
    0% { transform: translateY(60px) scale(0.96); opacity: 0; }
    100% { transform: translateY(0) scale(1); opacity: 1; }
}

/* Absolute Typography Enforcement (Latin Modern ONLY) */
.article-header { margin-bottom: 4rem; text-align: center; }

.article-header .meta {
    font-family: var(--font-ui) !important;
    font-size: 0.85rem;
    color: var(--silver-dim);
    letter-spacing: 2.5px;
    text-transform: uppercase;
    display: flex; justify-content: center; gap: 16px; align-items: center;
    margin-bottom: 1.8rem;
}
.article-header .pill {
    background: color-mix(in oklab, var(--gold) 12%, transparent);
    color: var(--gold);
    padding: 6px 14px;
    border-radius: 30px;
    font-weight: 800;
    border: 1px solid color-mix(in oklab, var(--gold) 25%, transparent);
}

.article-content { 
    font-family: var(--font-main) !important;
    font-size: 1.22rem;
    line-height: 1.95;
    color: color-mix(in oklab, var(--silver) 94%, var(--silver-dim));
    text-align: justify;
    text-justify: inter-word;
    letter-spacing: 0.3px;
}

.article-content h1, .article-content h2, .article-content h3, .article-content h4 {
    font-family: var(--font-main) !important;
    color: var(--silver);
    line-height: 1.35;
    margin: 3rem 0 1.5rem;
    text-align: left;
    font-weight: normal;
}

.article-header h1 { 
    font-size: clamp(2.6rem, 5.5vw, 4rem); 
    color: var(--gold); 
    margin: 0; 
    line-height: 1.15;
    text-align: center;
    letter-spacing: -0.5px;
    text-shadow: 0 4px 20px rgba(212,175,55,0.1);
}

.article-content h2 { 
    font-size: 2.1rem; 
    border-bottom: 1px solid var(--border); 
    padding-bottom: 0.8rem;
    margin-top: 4rem;
}

.article-content h3 { 
    font-size: 1.5rem; 
    font-style: italic; 
    color: var(--gold-soft);
}

.article-content p { margin: 0 0 2rem; }
.article-content p:first-of-type::first-letter {
    font-size: 3.8rem;
    line-height: 0.85;
    float: left;
    margin-right: 0.6rem;
    margin-top: 0.25rem;
    color: var(--gold);
    font-family: var(--font-main) !important;
}

.article-content a { 
    color: var(--gold); text-decoration: underline; 
    text-decoration-color: color-mix(in oklab, var(--gold) 35%, transparent); 
    text-underline-offset: 6px; transition: all 0.3s; 
}
.article-content a:hover { color: var(--silver); text-decoration-color: var(--silver); }

.article-content ul, .article-content ol { margin: 0 0 2rem; padding-left: 2.2rem; }
.article-content li { margin-bottom: 0.8rem; padding-left: 0.5rem;}
.article-content li::marker { color: var(--gold); }

/* Beautiful Academic Blockquotes */
.article-content blockquote { 
    margin: 3rem 0; 
    padding: 2rem 2.5rem 2rem 3.5rem; 
    background: color-mix(in oklab, var(--border) 15%, transparent); 
    font-style: italic; 
    border-radius: 12px;
    position: relative;
    border: 1px solid var(--border);
    color: color-mix(in oklab, var(--silver) 85%, var(--silver-dim));
}
.article-content blockquote::before {
    content: "“";
    position: absolute;
    left: 0.8rem;
    top: 0.8rem;
    font-family: var(--font-main) !important;
    font-size: 4.5rem;
    color: var(--gold);
    line-height: 1;
    opacity: 0.4;
}

/* Math blocks styling */
.article-content .katex-display {
    overflow-x: auto;
    overflow-y: hidden;
    padding: 1.5rem 0;
    margin: 2.5rem 0;
    background: color-mix(in oklab, var(--border) 8%, transparent);
    border-radius: 12px;
}

#err { position: fixed; inset: 0; z-index: 9999; display: none; padding: 96px 18px 18px; background: var(--bg); color: var(--silver); font-family: var(--font-ui); -webkit-user-select: text; user-select: text; touch-action: pan-y; }
#err h2 { margin: 0 0 12px; font-weight: 900; letter-spacing: 1px; color: var(--gold); text-transform: uppercase; }
#err pre { margin: 12px 0 0; padding: 12px; border-radius: 14px; border: 1px solid var(--border); background: rgba(18,18,18,0.6); overflow: auto; max-height: 55vh; white-space: pre-wrap; line-height: 1.5; opacity: 0.9; }
</style>
</head>

<body>
<nav id="nav" aria-label="Primary">
  <button id="brand" type="button" aria-label="Reset View">Anıl Kaya</button>
  <div id="actions">
    <a class="btn" href="https://www.linkedin.com/in/anillkaya" target="_blank" rel="noopener noreferrer">LinkedIn</a>
  </div>
</nav>

<canvas id="gl" aria-hidden="true"></canvas>
<div id="orbitHint" aria-hidden="true"></div>
<div id="depthName" aria-hidden="true">In Econometrics We Trust</div>

<!-- SYMMETRICAL COPYRIGHT FOOTER -->
<div id="copyright" aria-hidden="true">© 2026 Anıl Kaya</div>

<div id="readProgress" aria-hidden="true"></div>
<div id="modal" role="dialog" aria-modal="true" aria-label="Content reader">
  <button id="closeBtn" aria-label="Close Article">
      <svg viewBox="0 0 24 24" fill="none"><path d="M18 6L6 18M6 6l12 12"></path></svg>
  </button>
  <div id="modalBody">
      <div class="article-wrapper">
          <div class="article-content" id="articleContentArea">
              <!-- Content injected here -->
          </div>
      </div>
  </div>
</div>

<div id="err"><h2>Render error</h2><div>Error details</div><pre id="errText"></pre></div>

<script>
(function(){
"use strict";

function sanitizeHTML(str) {
    if (window.DOMPurify) return window.DOMPurify.sanitize(str);
    if (!str) return "";
    let safe = str.replace(/<script\b[^>]*>([\s\S]*?)<\/script>/gim, "")
                  .replace(/<(iframe|object|embed|form)\b[^>]*>([\s\S]*?)<\/\1>/gim, "");
    safe = safe.replace(/\s+on\w+="[^"]*"/gim, "").replace(/\s+on\w+='[^']*'/gim, "").replace(/href=["']javascript:[^"']*["']/gim, "href='#'");
    return safe;
}

const FocusTrap = {
    firstFocusable: null, lastFocusable: null, lastActive: null,
    activate: (el) => {
        FocusTrap.lastActive = document.activeElement;
        const focusable = el.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        if (focusable.length === 0) return;
        FocusTrap.firstFocusable = focusable[0];
        FocusTrap.lastFocusable = focusable[focusable.length - 1];
        FocusTrap.firstFocusable.focus();
        el.addEventListener('keydown', FocusTrap.handleKey);
    },
    deactivate: (el) => {
        el.removeEventListener('keydown', FocusTrap.handleKey);
        if (FocusTrap.lastActive) FocusTrap.lastActive.focus();
    },
    handleKey: (e) => {
        if (e.key === 'Tab') {
            if (e.shiftKey) { if (document.activeElement === FocusTrap.firstFocusable) { e.preventDefault(); FocusTrap.lastFocusable.focus(); } } 
            else { if (document.activeElement === FocusTrap.lastFocusable) { e.preventDefault(); FocusTrap.firstFocusable.focus(); } }
        }
        if (e.key === 'Escape') closeModal();
    }
};

/* ==========================================================================
   ARTICLE CONFIGURATION 
   ========================================================================== */
const ARTICLES = [
  { id:"options-pricing", file:"articles/options.html", category:"Financial Econometrics", title:"Options Pricing", date:"JAN 2026", textureKey:"moon", enabled:true },
  { id:"bvar", file:"articles/bvar.html", category:"Core Theory", title:"Bayesian Vector Autoregression", date:"DEC 2025", textureKey:"earth", enabled:true },
  { id:"stoch-vol", file:"articles/forecasting.html", category:"Time Series", title:"Why ML is almost useless", date:"JAN 2026", textureKey:"mars", enabled:true },
  { id:"game-theory-cb", file:"articles/game.html", category:"Monetary Economics", title:"Central Bank Credibility", date:"JAN 2026", textureKey:"jupiter", enabled:true },
  { id:"sign-rest", file:"articles/ERPT.html", category:"Macroeconometrics", title:"Exchange Rate Pass Through", date:"JAN 2026", textureKey:"venus", enabled:true },
  { id:"monte-carlo", file:"articles/monte-carlo.html", category:"Computational Methods", title:"Monte Carlo Simulation", date:"JAN 2026", textureKey:"mc", enabled:true },
  { id:"erpt-defense", file:"articles/price.html", category:"International Finance", title:"Currency Defense Game", date:"FEB 2026", textureKey:"erpt", enabled:true },
  { id:"Nash-Minimax Drift", file:"articles/nash.html", category:"Domestic Finance", title:"Nash Strategy of Portfolio Managing", date:"FEB 2026", textureKey:"NSH", enabled:true }
].filter(x=>x.enabled);

const $ = (id)=>document.getElementById(id);
function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
function showErr(e){
  const txt = $("errText");
  if(txt) txt.textContent = (e && (e.stack || e.message)) ? (e.stack || e.message) : String(e);
  const el = $("err");
  if(el) el.style.display = "block";
}

const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const lerp = (a,b,t)=>a+(b-a)*t;

const modal = $("modal");
const contentArea = $("articleContentArea");
let modalJustOpenedAt = 0;

// Progress Bar Logic
$("modalBody").addEventListener("scroll", (e) => {
    const el = e.target;
    const pct = el.scrollTop / Math.max(1, el.scrollHeight - el.clientHeight);
    $("readProgress").style.width = (pct * 100) + "%";
});

function closeModal(){ 
    modal.classList.remove("open"); 
    document.body.classList.remove("modal-open");
    const b = $("modalBody"); 
    if(b) b.scrollTop = 0; 
    $("readProgress").style.width = "0%";
    FocusTrap.deactivate(modal);
}

modal.addEventListener("click", (e)=>{ 
    if (performance.now() - modalJustOpenedAt < 250) return; 
    if (e.target === modal || e.target.id === 'modalBody') closeModal(); 
});
window.addEventListener("keydown", (e)=>{ if (e.key==="Escape" && modal.classList.contains("open")) closeModal(); }, { passive:true });
$("closeBtn").addEventListener("click", closeModal);

function renderModal(a, content, isLoading){
  const safeContent = sanitizeHTML(content);
  
  const headerHtml = `
     <header class="article-header">
        <div class="meta"><span class="pill">${a.category}</span><span>•</span><span>${a.date}</span></div>
        <h1>${a.title}</h1>
     </header>
  `;
  contentArea.innerHTML = headerHtml + safeContent;
}

// Generates beautiful fallback content if the HTML file isn't available
function generateMockContent(a) {
    return `
      <p style="font-style: italic; color: var(--gold); border-left: 2px solid var(--gold); padding-left: 1rem;">
        Note: Displaying simulated preview. The original source file (<code>${a.file}</code>) is unavailable in this environment.
      </p>
      <p>This manuscript explores the foundational concepts surrounding <strong>${a.title}</strong>, offering critical insights into its underlying methodologies and empirical applications within the field of ${a.category}.</p>
      <h2>Theoretical Framework</h2>
      <p>The primary hypothesis centers around optimizing the variables that influence systemic outcomes. By establishing a rigorous standard of measurement, we can isolate the core dynamics.</p>
      <blockquote>"In data we trust; all others must bring proof. A model is only as robust as the assumptions it dares to challenge."</blockquote>
      <h3>Mathematical Definition</h3>
      <p>The dynamic relationship can be elegantly captured using the following stochastic framework:</p>
      <div class="katex-display">dS_t = \\mu S_t dt + \\sigma S_t dW_t</div>
      <p>Where $S_t$ represents the asset path, $\\mu$ is the drift coefficient, and $dW_t$ is the standard Brownian motion increment. This serves as the bedrock for further analytical derivations.</p>
      <h2>Empirical Analysis</h2>
      <p>Our simulation indicates a robust convergence under high-volatility conditions, confirming the initial theoretical postulates. Further research will involve integrating a Bayesian updating mechanism to refine the predictive intervals.</p>
    `;
}

async function openArticle(a){
  modalJustOpenedAt = performance.now();
  modal.classList.add("open");
  document.body.classList.add("modal-open");
  FocusTrap.activate(modal);

  renderModal(a, "<p style='text-align:center; margin-top: 4rem; font-style:italic;'>Loading manuscript...</p>", true);
  
  try{
    const targetUrl = new URL(a.file, document.baseURI).href;
    if(new URL(targetUrl).origin !== window.location.origin) throw new Error("Cross origin fetch blocked");

    const res = await fetch(targetUrl);
    if(!res.ok) throw new Error("HTTP "+res.status);
    const txt = await res.text();
    const doc = new DOMParser().parseFromString(txt, "text/html");
    const c = doc.querySelector(".content") || doc.body;
    renderModal(a, c.innerHTML, false);
    
  } catch(e){
    // Elegant fallback if file is missing (ensures a flawless experience locally/in previews)
    renderModal(a, generateMockContent(a), false);
  }

  // Render LaTeX math blocks
  if(window.renderMathInElement) {
      window.renderMathInElement(contentArea, {
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '\\[', right: '\\]', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false}
          ]
      });
  }
}

/* ==========================================================================
   3D PLANET TEXTURE GENERATION
   ========================================================================== */
function fract(x){ return x - Math.floor(x); }
function hash2(x,y,s){ return fract(Math.sin(x*127.1 + y*311.7 + s*74.7) * 43758.5453123); }
function smoothstep(a,b,x){ const t = clamp((x-a)/(b-a), 0, 1); return t*t*(3-2*t); }
function noise2(u,v,s){
  const x = Math.floor(u), y = Math.floor(v);
  const fx = u - x, fy = v - y;
  const a = hash2(x,y,s), b = hash2(x+1,y,s), c = hash2(x,y+1,s), d = hash2(x+1,y+1,s);
  const ux = fx*fx*(3-2*fx), uy = fy*fy*(3-2*fy);
  return (a*(1-ux) + b*ux)*(1-uy) + (c*(1-ux) + d*ux)*uy;
}
function fbm2(u,v,s){
  let f=0, amp=0.5, freq=1.0;
  for(let i=0;i<5;i++){ f += amp * noise2(u*freq, v*freq, s + i*19.19); freq *= 2.02; amp *= 0.5; }
  return f;
}
function mix(a,b,t){ return a + (b-a)*t; }
function clamp01(x){ return clamp(x,0,1); }
function rgb(r,g,b){ return [r,g,b]; }
function to255(x){ return Math.round(clamp01(x)*255); }

function makeCanvasTexture(drawFn, size){
  const c = document.createElement("canvas"); c.width = c.height = size;
  const g = c.getContext("2d", { willReadFrequently:true }); drawFn(g, size);
  const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace;
  tex.anisotropy = 16; tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.needsUpdate = true;
  return tex;
}

function drawEarth(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  const deep = rgb(0.04,0.13,0.32), shallow = rgb(0.07,0.22,0.46), green = rgb(0.10,0.33,0.18), brown = rgb(0.32,0.28,0.14), sand  = rgb(0.52,0.46,0.25);
  for(let y=0;y<size;y++){
    const v = y/(size-1), lat = Math.abs(v-0.5)*2;
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const n1 = fbm2(u*6.0, v*6.0, 1.3), n2 = fbm2(u*14.0, v*14.0, 7.7);
      const continent = n1 + 0.35*n2 - 0.52 + 0.10*Math.sin((v-0.5)*Math.PI*2);
      const ice = smoothstep(0.72, 0.98, lat), land = smoothstep(-0.04, 0.05, continent);
      const seaVar = fbm2(u*18.0+3.0, v*18.0+9.0, 4.2);
      let oc = [mix(deep[0], shallow[0], seaVar), mix(deep[1], shallow[1], seaVar), mix(deep[2], shallow[2], seaVar)];
      const elev = fbm2(u*10.0+20.0, v*10.0+10.0, 2.6), dryness = fbm2(u*8.0+2.0, v*8.0+8.0, 9.1);
      let lc = [mix(green[0], brown[0], elev), mix(green[1], brown[1], elev), mix(green[2], brown[2], elev)];
      const des = smoothstep(0.58, 0.78, dryness) * (1.0 - ice);
      lc = [mix(lc[0], sand[0], des), mix(lc[1], sand[1], des), mix(lc[2], sand[2], des)];
      let c = [mix(oc[0], lc[0], land), mix(oc[1], lc[1], land), mix(oc[2], lc[2], land)];
      const cloudN = fbm2(u*26.0+31.0, v*26.0+17.0, 1.0), cloud = smoothstep(0.67, 0.82, cloudN) * (0.65 + 0.35*(1.0-land));
      c = [mix(c[0], 0.92, cloud*0.45), mix(c[1], 0.92, cloud*0.45), mix(c[2], 0.95, cloud*0.45)];
      c = [mix(c[0], 0.94, ice*0.85), mix(c[1], 0.94, ice*0.85), mix(c[2], 0.98, ice*0.85)];
      const i = (y*size + x)*4; d[i+0] = to255(c[0]); d[i+1] = to255(c[1]); d[i+2] = to255(c[2]); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function drawMoon(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const base = 0.55 + 0.18*(fbm2(u*8.0, v*8.0, 3.1)-0.5);
      const crater = smoothstep(0.55, 0.86, fbm2(u*22.0+4.0, v*22.0+9.0, 8.8));
      const ray = smoothstep(0.70, 0.92, fbm2(u*30.0+17.0, v*30.0+3.0, 1.7));
      let c = clamp01(base - crater*0.18 + ray*0.10);
      const i = (y*size + x)*4; d[i+0] = to255(c*0.98); d[i+1] = to255(c*0.99); d[i+2] = to255(c*1.02); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function drawMars(g, size){
  const img = g.createImageData(size,size); const d = img.data; const baseR = 0.62, baseG = 0.24, baseB = 0.10;
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const n = fbm2(u*10.0, v*10.0, 5.5), ridges = fbm2(u*20.0+3.0, v*20.0+11.0, 2.2);
      const dust = smoothstep(0.45, 0.78, n), dark = smoothstep(0.58, 0.86, ridges);
      let r = baseR + 0.18*dust - 0.16*dark, gg = baseG + 0.06*dust - 0.08*dark, b = baseB + 0.02*dust - 0.04*dark;
      const lat = Math.abs(v-0.5)*2, ice = smoothstep(0.82, 0.98, lat);
      r = mix(r, 0.92, ice*0.45); gg = mix(gg, 0.92, ice*0.45); b = mix(b, 0.96, ice*0.45);
      const i = (y*size + x)*4; d[i+0] = to255(r); d[i+1] = to255(gg); d[i+2] = to255(b); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function drawVenus(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const swirl = 0.5 + 0.5*Math.sin((u*10.0 + v*2.0)*Math.PI*2);
      const n = fbm2(u*14.0+swirl*3.0, v*14.0, 6.6), band = smoothstep(0.35, 0.75, n);
      let r = mix(0.82, 0.98, band), gg = mix(0.64, 0.86, band), b = mix(0.36, 0.62, band);
      const haze = smoothstep(0.60, 0.92, fbm2(u*26.0+7.0, v*26.0+19.0, 1.2));
      r = mix(r, 1.0, haze*0.18); gg = mix(gg, 1.0, haze*0.18); b = mix(b, 1.0, haze*0.18);
      const i = (y*size + x)*4; d[i+0] = to255(r); d[i+1] = to255(gg); d[i+2] = to255(b); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function drawMonteCarlo(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const n = fbm2(u*16.0, v*16.0, 10.1);
      const grid = (Math.abs(fract(u*24.0)-0.5)<0.01 || Math.abs(fract(v*24.0)-0.5)<0.01) ? 1.0 : 0.0;
      const speck = smoothstep(0.88, 0.98, fbm2(u*52.0+3.0, v*52.0+9.0, 21.7));
      let r = 0.08 + 0.12*n, gg = 0.10 + 0.14*n, b = 0.16 + 0.22*n;
      r = mix(r, 0.40, grid*0.10); gg = mix(gg, 0.55, grid*0.10); b = mix(b, 0.95, grid*0.10);
      r = mix(r, 0.95, speck*0.55); gg = mix(gg, 0.90, speck*0.55); b = mix(b, 0.98, speck*0.55);
      const i = (y*size + x)*4; d[i+0] = to255(r); d[i+1] = to255(gg); d[i+2] = to255(b); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function drawERPT(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  const cShield = [0.1, 0.6, 0.6]; 
  const cDefense = [0.2, 0.1, 0.4]; 
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const hex = fbm2(u*30.0, v*30.0, 4.4);
      const grid = smoothstep(0.4, 0.6, Math.abs(Math.sin(u*40.0)*Math.sin(v*40.0)));
      
      const n = fbm2(u*8.0, v*8.0, 2.2);
      let r = mix(cDefense[0], cShield[0], n);
      let gg = mix(cDefense[1], cShield[1], n);
      let b = mix(cDefense[2], cShield[2], n);
      
      const crack = smoothstep(0.45, 0.50, fbm2(u*50.0, v*50.0, 9.9));
      r += 0.2 * grid; gg += 0.2 * grid; b += 0.3 * grid;
      
      if(crack > 0.48 && crack < 0.52) { r=0.9; gg=0.8; b=0.2; } 
      
      const i = (y*size + x)*4; d[i+0] = to255(r); d[i+1] = to255(gg); d[i+2] = to255(b); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function buildBaseTextures(){
  const SZ = 512;
  return { 
      earth: makeCanvasTexture(drawEarth, SZ), 
      moon: makeCanvasTexture(drawMoon, SZ), 
      mars: makeCanvasTexture(drawMars, SZ), 
      venus: makeCanvasTexture(drawVenus, SZ), 
      mc: makeCanvasTexture(drawMonteCarlo, SZ), 
      erpt: makeCanvasTexture(drawERPT, SZ) 
  };
}

if (!window.THREE){ showErr(new Error("Three.js unavailable")); return; }
try{
  const canvas = $("gl");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false, powerPreference: "high-performance" });
  const DPR = ()=>Math.min(window.devicePixelRatio || 1, 2);
  renderer.setPixelRatio(DPR()); renderer.setSize(window.innerWidth, window.innerHeight, false);
  renderer.outputColorSpace = THREE.SRGBColorSpace; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.08;

  const scene = new THREE.Scene(); scene.background = new THREE.Color(cssVar("--bg") || "#050505");
  const camera = new THREE.PerspectiveCamera(52, window.innerWidth/window.innerHeight, 0.1, 5000); camera.position.set(0, 0, 220);

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const key = new THREE.DirectionalLight(0xffffff, 1.85); key.position.set(160, 190, 130); scene.add(key);
  const fill = new THREE.DirectionalLight(0xfff1cc, 0.72); fill.position.set(-210, 70, 160); scene.add(fill);
  const rim = new THREE.PointLight(0xd4af37, 1.35, 1200, 1.4); rim.position.set(0, 0, -320); scene.add(rim);

  const pointer = new THREE.Vector2(0,0); let px=0, py=0, pointerActive=false;
  const galaxy = new THREE.Group(); scene.add(galaxy);

  function buildStars(){
    const starCount = 35000;
    const geom = new THREE.BufferGeometry(), pos = new Float32Array(starCount*3), col = new Float32Array(starCount*3), size = new Float32Array(starCount);
    const cGold = new THREE.Color(0xD4AF37), cSilver = new THREE.Color(0xe8e8ea), cOrange = new THREE.Color(0xff9900), cBlue = new THREE.Color(0x001d4a);
    
    for (let i=0;i<starCount;i++){
      const r = Math.pow(Math.random(), 0.42) * 1100;
      const theta = Math.random() * Math.PI*2;
      const y = (Math.random()-0.5) * (20 + 200*(1-r/1100));
      pos[i*3+0] = Math.cos(theta)*r + (Math.random()-0.5)*15;
      pos[i*3+1] = y;
      pos[i*3+2] = Math.sin(theta)*r + (Math.random()-0.5)*15;
      
      const rand = Math.random();
      let c;
      if(rand < 0.6) c = cSilver;
      else if(rand < 0.8) c = cGold;
      else if(rand < 0.95) c = cBlue;
      else c = cOrange;
      
      col[i*3+0]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
      size[i] = 0.6 + Math.random()*2.4;
    }
    geom.setAttribute("position", new THREE.BufferAttribute(pos,3)); geom.setAttribute("color", new THREE.BufferAttribute(col,3)); geom.setAttribute("aSize", new THREE.BufferAttribute(size,1));
    const mat = new THREE.ShaderMaterial({
      transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, uniforms: { uTime: { value: 0 }, uDpr: { value: DPR() } },
      vertexShader: `attribute float aSize; attribute vec3 color; varying vec3 vColor; uniform float uTime; uniform float uDpr; void main(){ vColor = color; vec3 p = position; float tw = sin(uTime*0.18 + p.x*0.01 + p.z*0.01) * 0.30; p.y += tw; vec4 mv = modelViewMatrix * vec4(p, 1.0); gl_Position = projectionMatrix * mv; float s = aSize * (300.0 / -mv.z); gl_PointSize = clamp(s * uDpr, 1.0, 10.0); }`,
      fragmentShader: `varying vec3 vColor; void main(){ vec2 uv = gl_PointCoord.xy - 0.5; float d = dot(uv, uv); float a = smoothstep(0.25, 0.0, d); float halo = smoothstep(0.48, 0.10, d) * 0.55; vec3 c = vColor * (1.2*a + 0.9*halo); gl_FragColor = vec4(c, (a + halo) * 0.85); }`
    });
    return new THREE.Points(geom, mat);
  }
  const stars = buildStars(); stars.rotation.x = -0.34; galaxy.add(stars);

  const nebula = new THREE.Mesh(
    new THREE.SphereGeometry(1900, 48, 48),
    new THREE.ShaderMaterial({
      side: THREE.BackSide,
      uniforms: { uTime: { value: 0 }, uPointer: { value: new THREE.Vector2(0,0) }, uGold: { value: new THREE.Color(cssVar("--gold") || "#D4AF37") }, uSilver: { value: new THREE.Color(cssVar("--silver") || "#e8e8ea") }, uBg: { value: new THREE.Color(cssVar("--bg") || "#050505") } },
      vertexShader: `varying vec3 vP; uniform float uTime; uniform vec2 uPointer; void main(){ vec3 p = position; float band = exp(-abs(p.y) / 240.0); float swirl = sin(uTime*0.08 + p.x*0.002 + p.z*0.002) * 22.0 * band; p.x += swirl; p.z -= swirl * 0.55; p.x += uPointer.x * 12.0 * band; p.y += uPointer.y * 6.0 * band; vP = p; gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0); }`,
      fragmentShader: `varying vec3 vP; uniform float uTime; uniform vec3 uGold; uniform vec3 uSilver; uniform vec3 uBg; float noise(vec3 p){ vec3 i = floor(p); vec3 f = fract(p); f = f*f*(3.0-2.0*f); float n000 = fract(sin(dot(i, vec3(1.0,57.0,113.0))) * 43758.5453); float n100 = fract(sin(dot(i+vec3(1,0,0), vec3(1.0,57.0,113.0))) * 43758.5453); float n010 = fract(sin(dot(i+vec3(0,1,0), vec3(1.0,57.0,113.0))) * 43758.5453); float n110 = fract(sin(dot(i+vec3(1,1,0), vec3(1.0,57.0,113.0))) * 43758.5453); float n001 = fract(sin(dot(i+vec3(0,0,1), vec3(1.0,57.0,113.0))) * 43758.5453); float n101 = fract(sin(dot(i+vec3(1,0,1), vec3(1.0,57.0,113.0))) * 43758.5453); float n011 = fract(sin(dot(i+vec3(0,1,1), vec3(1.0,57.0,113.0))) * 43758.5453); float n111 = fract(sin(dot(i+vec3(1,1,1), vec3(1.0,57.0,113.0))) * 43758.5453); float n00 = mix(n000, n100, f.x); float n10 = mix(n010, n110, f.x); float n01 = mix(n001, n101, f.x); float n11 = mix(n011, n111, f.x); float n0 = mix(n00, n10, f.y); float n1 = mix(n01, n11, f.y); return mix(n0, n1, f.z); } float fbm(vec3 p){ float v = 0.0; float a = 0.5; for(int i=0;i<5;i++){ v += a * noise(p); p *= 2.02; a *= 0.5; } return v; } void main(){ float band = exp(-abs(vP.y) / 170.0); vec3 q = vP * 0.0018 + vec3(0.0, 0.0, uTime*0.015); float n = fbm(q*3.0); float m = fbm(q*6.0 + 12.3); float cloud = smoothstep(0.35, 0.92, n) * band; float dust = smoothstep(0.25, 0.85, m) * band; float grad = clamp(0.5 + 0.5*sin(vP.x*0.002 + uTime*0.06), 0.0, 1.0); vec3 mixc = mix(uSilver, uGold, grad); vec3 c = uBg; c += mixc * (0.18*cloud + 0.12*dust); c += uGold * (0.06 * band); c = clamp(c, 0.0, 1.0); gl_FragColor = vec4(c, 1.0); }`
    })
  );
  scene.add(nebula);

  const planets = new THREE.Group(); scene.add(planets);
  const ringGroup = new THREE.Group(); planets.add(ringGroup);
  const ringTiltX = 0.38, ringTiltZ = -0.12; ringGroup.rotation.x = ringTiltX; ringGroup.rotation.z = ringTiltZ;
  const raycaster = new THREE.Raycaster(); let hovered = null;

  function labelSprite(text){
    const w=1200, h=380, c=document.createElement("canvas"); c.width=w; c.height=h; const g=c.getContext("2d");
    g.shadowColor = "rgba(0,0,0,0.8)"; g.shadowBlur = 18;
    g.fillStyle = "rgba(255,255,255,0.95)"; g.textAlign = "center"; g.textBaseline = "middle"; 
    g.font = "800 90px 'Latin Modern Sans','Latin Modern Roman',system-ui,sans-serif";
    const pad=48, maxW=w-pad*2, words=String(text).split(/\s+/).filter(Boolean);
    let line="", lines=[]; for(let i=0;i<words.length;i++){ const test=line? (line+" "+words[i]) : words[i]; if(g.measureText(test).width<=maxW) line=test; else{ lines.push(line); line=words[i]; } } if(line) lines.push(line);
    const lineH=104, y0=h/2 - ((lines.length-1)*lineH)/2; for(let i=0;i<lines.length;i++) g.fillText(lines[i], w/2, y0+i*lineH);
    const tex=new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; tex.anisotropy = 8;
    const spr=new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false })); spr.scale.set(100, 36, 1); spr.userData._labelText = text; return spr;
  }

  const baseTextures = buildBaseTextures();
  const planetMaterial = (art) => {
    let map = baseTextures.earth; if(art.textureKey==="moon") map=baseTextures.moon; else if(art.textureKey==="mars") map=baseTextures.mars; else if(art.textureKey==="venus") map=baseTextures.venus; else if(art.textureKey==="mc") map=baseTextures.mc; else if(art.textureKey==="erpt") map=baseTextures.erpt;
    return new THREE.MeshStandardMaterial({ map, roughness:0.75, metalness:0.15 });
  };
  const atmosphereMaterial = (color, opacity) => new THREE.ShaderMaterial({
    transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, uniforms:{ uColor:{ value:new THREE.Color(color) }, uOpacity:{ value:opacity } },
    vertexShader: `varying vec3 vNormal; void main(){ vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
    fragmentShader: `varying vec3 vNormal; uniform vec3 uColor; uniform float uOpacity; void main(){ float i = pow(0.65 - dot(vNormal, vec3(0,0,1)), 2.8); gl_FragColor = vec4(uColor, i*uOpacity); }`
  });

  const entries = [];
  function buildSaturnRings(innerR, outerR){
    ringGroup.clear(); const gold = new THREE.Color(cssVar("--gold") || "#D4AF37"), silv = new THREE.Color(cssVar("--silver") || "#e8e8ea");
    const makeRing = (r0, r1, opacity, z, tintMix)=>{
      const geo = new THREE.RingGeometry(r0, r1, 192, 1);
      const mat = new THREE.ShaderMaterial({
        transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
        uniforms:{ uTime:{ value:0 }, uGold:{ value: gold.clone() }, uSilv:{ value: silv.clone() }, uOpacity:{ value: opacity }, uTint:{ value: tintMix } },
        vertexShader: `varying vec2 vUv; varying vec3 vPos; void main(){ vUv = uv; vec4 wp = modelMatrix * vec4(position,1.0); vPos = wp.xyz; gl_Position = projectionMatrix * viewMatrix * wp; }`,
        fragmentShader: `varying vec2 vUv; varying vec3 vPos; uniform float uTime; uniform vec3 uGold; uniform vec3 uSilv; uniform float uOpacity; uniform float uTint; float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); } float noise(vec2 p){ vec2 i = floor(p); vec2 f = fract(p); f = f*f*(3.0-2.0*f); float a = hash(i); float b = hash(i+vec2(1.0,0.0)); float c = hash(i+vec2(0.0,1.0)); float d = hash(i+vec2(1.0,1.0)); return mix(mix(a,b,f.x), mix(c,d,f.x), f.y); } void main(){ float r = length(vUv - 0.5) * 2.0; float g = noise((vUv-0.5)*vec2(180.0, 28.0) + uTime*0.02); float streak = noise((vUv-0.5)*vec2(420.0, 44.0) - uTime*0.01); float a = (0.55 + 0.45*g) * (0.55 + 0.45*streak); float edge = smoothstep(0.98, 0.65, r) * smoothstep(0.02, 0.18, r); a *= edge; vec3 c = mix(uSilv, uGold, uTint + 0.15*sin(vUv.x*20.0)); gl_FragColor = vec4(c, a * uOpacity); }`
      });
      const m = new THREE.Mesh(geo, mat); m.position.z = z; ringGroup.add(m); return m;
    };
    const rings = []; rings.push(makeRing(innerR, outerR, 0.22, 0.0, 0.55)); rings.push(makeRing(innerR*1.02, outerR*0.985, 0.16, 0.06, 0.35)); rings.push(makeRing(innerR*1.06, outerR*0.96, 0.12, -0.06, 0.70)); return rings;
  }

  function wrapAngle(a){ const two = Math.PI*2; a = a % two; return a < 0 ? a + two : a; }
  function angleDist(a,b){ const two = Math.PI*2; let d = Math.abs(a-b) % two; return d > Math.PI ? two - d : d; }
  function enforceAngularSeparation(){
    const n = entries.length; if (n <= 1) return; const minGapBase = 0.64;
    for (let it=0; it<22; it++){
      let moved = 0; const idx = entries.map((p)=>p).sort((a,b)=>a.angle - b.angle);
      for (let k=0;k<n;k++){ const A = idx[k], B = idx[(k+1)%n], gapNeed = minGapBase + 0.010*(A.radius + B.radius), d = angleDist(A.angle, B.angle); if (d < gapNeed){ const push = (gapNeed - d) * 0.5; A.angle = wrapAngle(A.angle - push); B.angle = wrapAngle(B.angle + push); moved++; } } if (!moved) break;
    }
  }
  function applyOrbitPosition(p){
    const r = p.ringR * (1.0 + p.rMod), x = Math.cos(p.angle) * r, y = Math.sin(p.angle) * r, z = p.zMod;
    const pos = new THREE.Vector3(x,y,0); pos.applyEuler(new THREE.Euler(ringTiltX, 0, ringTiltZ, "XYZ")); pos.z += z;
    p.mesh.position.copy(pos); p.atmo.position.copy(pos); p.label.position.copy(pos);
    const offset = (p.radius + 42 * p.scale * p.labelScaleMult), up = new THREE.Vector3(0,1,0).applyEuler(new THREE.Euler(ringTiltX, 0, ringTiltZ, "XYZ")), sign = (y >= 0) ? 1 : -1;
    p.label.position.addScaledVector(up, offset * sign * 0.6); 
    p.label.quaternion.copy(camera.quaternion);
  }
  function disposeObject(obj){ obj.traverse((o)=>{ if (o.geometry) o.geometry.dispose(); if (o.material){ if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose && m.dispose()); else o.material.dispose && o.material.dispose(); } if (o.material && o.material.map) o.material.map.dispose && o.material.map.dispose(); }); }
  function rebuildLabelTextures(){
    for (const p of entries){ const spr = p.label; if (!spr || !spr.userData || !spr.userData._labelText) continue; const newSpr = labelSprite(spr.userData._labelText); newSpr.scale.copy(spr.scale); newSpr.position.copy(spr.position); newSpr.quaternion.copy(spr.quaternion); newSpr.userData.article = spr.userData.article; planets.remove(spr); planets.add(newSpr); p.label = newSpr; }
  }

  let ringMeshes = [];
  function buildPlanets(){
    for (let i = planets.children.length - 1; i >= 0; i--) { const ch = planets.children[i]; if (ch !== ringGroup) { planets.remove(ch); try{ disposeObject(ch); }catch(_){} } }
    entries.length = 0;
    let w = window.innerWidth, h = window.innerHeight; if (!w || !h) { w = 1024; h = 768; } const isMobile = w < 800, aspect = w / h, dist = 220, vH = 2 * dist * Math.tan((52 * Math.PI / 180) / 2), vW = vH * aspect;
    let scale = Math.min(vW / 560, vH / 560); if (!Number.isFinite(scale)) scale = 1.0;
    const finalScale = Math.max(scale, 0.22), ringR = 142 * finalScale, ringInner = ringR * 0.78, ringOuter = ringR * 1.12;
    ringMeshes = buildSaturnRings(ringInner, ringOuter);
    const planetBaseRadius = isMobile ? 50 : 25, labelScaleMult = isMobile ? 2.05 : 1.0;
    const n = ARTICLES.length;
    for (let i=0;i<n;i++){
      const art = ARTICLES[i], radius = planetBaseRadius * finalScale;
      const mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 64, 64), planetMaterial(art)); mesh.userData.article = art; mesh.userData.radius = radius;
      let atColor = "#90b0ff"; if(art.textureKey==="earth") atColor = "#0066ff"; else if(art.textureKey==="mars") atColor = "#ff4400"; else if(art.textureKey==="venus") atColor = "#ffd080"; else if(art.textureKey==="mc") atColor = "#a7b7ff"; else if(art.textureKey==="erpt") atColor = "#00e5ff"; else atColor = "#cfd3ff";
      const atmo = new THREE.Mesh(new THREE.SphereGeometry(radius*1.06, 64, 64), atmosphereMaterial(atColor, 0.45)); atmo.userData.article = art;
      const label = labelSprite(art.title); label.scale.multiplyScalar(finalScale * labelScaleMult); label.userData.article = art;
      const baseAngle = (i / n) * Math.PI*2 + Math.PI/5;
      entries.push({ mesh, atmo, label, radius, angle: baseAngle, angVel: 0, rMod: 0, zMod: 0, ringR, hoverPull: 0, scale: finalScale, labelScaleMult });
      planets.add(mesh); planets.add(atmo); planets.add(label);
    }
    enforceAngularSeparation(); for (const p of entries) applyOrbitPosition(p);
  }
  buildPlanets();
  if (document.fonts && document.fonts.ready) { document.fonts.ready.then(()=>rebuildLabelTextures()).catch(()=>{}); }

  function getClientXY(ev){ if (ev && ev.changedTouches && ev.changedTouches.length) return { x: ev.changedTouches[0].clientX, y: ev.changedTouches[0].clientY }; if (ev && ev.touches && ev.touches.length) return { x: ev.touches[0].clientX, y: ev.touches[0].clientY }; return { x: ev.clientX, y: ev.clientY }; }
  function setPointerFromEvent(ev){ const r = canvas.getBoundingClientRect(); const p = getClientXY(ev); const x = (p.x - r.left) / Math.max(1, r.width); const y = (p.y - r.top) / Math.max(1, r.height); pointer.x = x * 2 - 1; pointer.y = -(y * 2 - 1); px = clamp(p.x - r.left, 0, r.width); py = clamp(p.y - r.top, 0, r.height); pointerActive = true; }
  let lastTapAt = 0, tapStart = null;
  
  // Refined Click/Touch handling
  function tryPick(ev){ 
    if (document.body.classList.contains("modal-open")) return; 
    setPointerFromEvent(ev); 
    raycaster.setFromCamera(pointer, camera); 
    const hits = raycaster.intersectObjects(planets.children, true); 
    const hit = hits.find(h => h.object && h.object.userData && h.object.userData.article); 
    if (hit) openArticle(hit.object.userData.article);
  }
  function onTapStart(ev){ if (document.body.classList.contains("modal-open")) return; const p = getClientXY(ev); tapStart = { x: p.x, y: p.y, t: performance.now() }; setPointerFromEvent(ev); }
  function onTapEnd(ev){ 
      if (!tapStart) return; 
      const p = getClientXY(ev); const dt = performance.now() - tapStart.t; const dx = Math.abs(p.x - tapStart.x); const dy = Math.abs(p.y - tapStart.y); 
      tapStart = null; 
      // If duration is short and finger didn't move much, treat as a click.
      if (dt < 450 && dx < 14 && dy < 14) tryPick(ev); 
  }
  
  function onPointerMove(e){ setPointerFromEvent(e); }
  canvas.addEventListener("pointermove", onPointerMove, { passive:true }); 
  canvas.addEventListener("touchstart", onTapStart, { passive:true }); 
  canvas.addEventListener("touchend", onTapEnd, { passive:true }); 
  canvas.addEventListener("touchcancel", ()=>{ tapStart = null; }, { passive:true }); 
  canvas.addEventListener("click", (e)=>{ tryPick(e); }, { passive:true });

  const clock = new THREE.Clock(); const starAnim = { time: 0, rotY: 0, rotZ: 0 };
  const _targetScale = new THREE.Vector3();

  function tick(){
    requestAnimationFrame(tick);
    
    // Performance optimization: Halt complex rendering when modal is open to save battery and CPU cycles
    if (document.body.classList.contains("modal-open")) return; 
    
    const dt = Math.min(0.033, clock.getDelta()), t = clock.getElapsedTime();
    const rect = canvas.getBoundingClientRect(); const nx = pointerActive ? (px / Math.max(1, rect.width) - 0.5) : 0.0, ny = pointerActive ? (py / Math.max(1, rect.height) - 0.5) : 0.0;
    
    // Drastically Reduced Mouse Tracking Reaction for smoother aesthetics
    const targetCamX = nx * 12;
    const targetCamY = (-ny) * 6;
    camera.position.x = lerp(camera.position.x, targetCamX, 0.15); 
    camera.position.y = lerp(camera.position.y, targetCamY, 0.15); 
    camera.lookAt(0,0,0);
    nebula.material.uniforms.uTime.value = t; nebula.material.uniforms.uPointer.value.set(nx, -ny);
    
    if (pointerActive){ raycaster.setFromCamera(pointer, camera); const hits = raycaster.intersectObjects(planets.children, true); const hit = hits.find(h => h.object && h.object.userData && h.object.userData.article); const newHover = hit ? hit.object : null; if (hovered !== newHover){ hovered = newHover; document.body.style.cursor = hovered ? "pointer" : "default"; } } else { if (hovered !== null){ hovered = null; document.body.style.cursor = "default"; } }
    
    const isHoveringPlanet = !!(hovered && hovered.userData && hovered.userData.article);
    if (!isHoveringPlanet){ starAnim.time += dt; starAnim.rotY += dt * 0.05; starAnim.rotZ = Math.cos(starAnim.time*0.04)*0.06; }
    stars.material.uniforms.uTime.value = starAnim.time; stars.material.uniforms.uDpr.value = DPR(); 
    
    // Drastically Reduced Star Parallax Response
    const targetGalY = starAnim.rotY + nx * 0.08;
    const targetGalX = -0.34 + ny * 0.08;
    galaxy.rotation.y = lerp(galaxy.rotation.y, targetGalY, 0.15); 
    galaxy.rotation.x = lerp(galaxy.rotation.x, targetGalX, 0.15);
    galaxy.rotation.z = starAnim.rotZ;

    if (ringMeshes && ringMeshes.length){ ringMeshes.forEach(m=>{ if (m.material && m.material.uniforms) m.material.uniforms.uTime.value = t; }); ringGroup.rotation.y = Math.sin(t*0.05)*0.06; }
    const n = entries.length;
    for (let i=0;i<n;i++){
      const p = entries[i], m = p.mesh; m.rotation.y += dt * (0.65 + i*0.03); m.rotation.x += dt * 0.008;
      const isHover = isHoveringPlanet && (hovered.userData.article === m.userData.article);
      p.hoverPull = lerp(p.hoverPull, isHover ? 1 : 0, 0.12);
      const baseSpin = 0.012, steer = pointerActive ? (nx * 0.015) : 0.0, hoverSteer = p.hoverPull * (nx*0.20) * 0.02;
      p.angVel = lerp(p.angVel, baseSpin + steer + hoverSteer, 0.05);
      const wob = Math.sin(t*0.7 + i*1.7) * 0.0009; p.angle = wrapAngle(p.angle + (p.angVel + wob) * dt);
      const rTarget = isHover ? 0.030 : 0.0; p.rMod = lerp(p.rMod, rTarget, 0.09);
      const zTarget = isHover ? 24.0 : 0.0; p.zMod = lerp(p.zMod, zTarget, 0.10);
    }
    for (let it=0; it<2; it++) enforceAngularSeparation();
    for (let i=0;i<n;i++){ 
        const p = entries[i]; 
        const isHover = isHoveringPlanet && (hovered.userData.article === p.mesh.userData.article); 
        applyOrbitPosition(p); 
        
        // Premium Hover Scaling Effect
        const s = isHover ? 1.15 : 1.0; 
        _targetScale.set(s, s, s); 
        p.mesh.scale.lerp(_targetScale, 0.12); 
        _targetScale.set(s*1.08, s*1.08, s*1.08); 
        p.atmo.scale.lerp(_targetScale, 0.12); 
    }
    
    renderer.render(scene, camera); 
  }

  function onResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setPixelRatio(DPR()); renderer.setSize(window.innerWidth, window.innerHeight, false); buildPlanets(); if (document.fonts && document.fonts.ready) document.fonts.ready.then(()=>rebuildLabelTextures()).catch(()=>{}); }
  window.addEventListener("resize", onResize, { passive:true });
  
  const brand = document.getElementById("brand");
  brand.addEventListener("click", ()=>camera.position.set(0,0,220)); brand.addEventListener("keydown", (e)=>{ if (e.key==="Enter"||e.key===" "){ e.preventDefault(); camera.position.set(0,0,220); } });
  
  tick();

}catch(e){ showErr(e); }
})();
</script>
</body>
</html>
