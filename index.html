<!doctype html>
<html lang="en" data-theme="dark" prefix="og: http://ogp.me/ns#">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>
<meta name="theme-color" content="#050505"/>

<!-- SEO & Metadata -->
<title>Anıl Kaya | Econometrics Labs & Research</title>
<meta name="description" content="Advanced interactive econometrics laboratory: IV/2SLS, VAR, VECM, ARDL, OU, MCMC simulations with academic-grade diagnostics. 3D visualization by Anıl Kaya.">
<meta name="keywords" content="Econometrics, Instrumental Variables, 2SLS, VAR, VECM, ARDL, Ornstein-Uhlenbeck, MCMC, Time Series, Granger Causality, Impulse Response, Anıl Kaya, Data Science">
<meta name="author" content="Anıl Kaya">
<meta name="robots" content="index, follow">
<link rel="canonical" href="https://anilkaya.com/">

<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://anilkaya.com/">
<meta property="og:title" content="Anıl Kaya | Econometrics Labs">
<meta property="og:description" content="Interactive simulations for advanced econometric models with Q1-journal standard diagnostics.">
<meta property="og:image" content="https://anilkaya.com/og-image.jpg">

<!-- Structured Data -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "Anıl Kaya Econometrics Lab",
  "description": "Simulation platform for IV, VAR, VECM, ARDL, OU, MCMC models.",
  "author": { "@type": "Person", "name": "Anıl Kaya" }
}
</script>

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin/>
<link rel="preconnect" href="https://unpkg.com" crossorigin/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sugina-dev/latin-modern-web@1.0.1/style/latinmodern-roman.css"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sugina-dev/latin-modern-web@1.0.1/style/latinmodern-sans.css"/>

<!-- Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
:root{color-scheme:dark;--font-main:"Latin Modern Roman","Times New Roman",Times,serif;--font-ui:"Latin Modern Sans","Latin Modern Roman",serif;--safe-top:env(safe-area-inset-top,0px);--safe-bottom:env(safe-area-inset-bottom,0px);--nav-h:64px;--bg:#050505;--panel:rgba(18,18,18,0.62);--panel-strong:rgba(10,10,10,0.86);--border:rgba(255,255,255,0.10);--silver:#e8e8ea;--silver-dim:rgba(232,232,234,0.72);--gold:#D4AF37;--gold-soft:#F7E7CE}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--silver);font-family:var(--font-main);overflow:hidden;overscroll-behavior:none;-webkit-font-smoothing:antialiased;-webkit-user-select:none;user-select:none;touch-action:none}
*{box-sizing:border-box}
a{color:var(--gold-soft);text-decoration:none}
a:hover{opacity:0.9}
:focus-visible{outline:2px solid color-mix(in oklab,var(--gold) 65%,#fff);outline-offset:3px;border-radius:14px}

#nav{position:fixed;top:0;left:0;right:0;height:calc(var(--nav-h) + var(--safe-top));padding-top:var(--safe-top);padding-left:clamp(14px,4vw,44px);padding-right:clamp(14px,4vw,44px);display:flex;align-items:center;justify-content:space-between;z-index:1000;border-bottom:1px solid var(--border);background:radial-gradient(1200px 600px at 20% 30%,rgba(212,175,55,0.11),rgba(0,0,0,0.0) 60%),linear-gradient(135deg,rgba(10,10,10,0.80),rgba(18,18,18,0.58));backdrop-filter:blur(18px)}
#brand{font-family:var(--font-ui);font-size:0.92rem;font-weight:900;letter-spacing:2px;text-transform:uppercase;color:color-mix(in oklab,var(--gold) 70%,var(--silver));user-select:none;white-space:nowrap;cursor:pointer;-webkit-user-select:none}
#actions{display:flex;align-items:center;gap:10px}
.btn{font-family:var(--font-ui);font-size:0.75rem;letter-spacing:1.0px;text-transform:uppercase;padding:8px 10px;border-radius:12px;border:1px solid rgba(212,175,55,0.25);background:linear-gradient(135deg,rgba(18,18,18,0.58),rgba(18,18,18,0.34));color:var(--silver);cursor:pointer;backdrop-filter:blur(14px);transition:all 0.3s ease;-webkit-user-select:none;user-select:none;touch-action:manipulation;min-height: 38px; display: flex; align-items: center;}
.btn:hover{background:rgba(212,175,55,0.15);border-color:rgba(212,175,55,0.5)}

/* Lab Styles */
.lab-container { display: grid; grid-template-columns: 360px 1fr; gap: 0; height: 100%; overflow: hidden; font-family: var(--font-ui); background: #050505; }
.lab-controls { padding: 24px; background: #080808; border-right: 1px solid var(--border); overflow-y: auto; display: flex; flex-direction: column; gap: 20px; z-index: 10; box-shadow: 2px 0 15px rgba(0,0,0,0.5); }
.lab-main { padding: 40px 32px; overflow-y: auto; display: flex; flex-direction: column; gap: 32px; background: #0b0b0b; position: relative; z-index: 5; scroll-behavior: smooth; }
.lab-group { display: flex; flex-direction: column; gap: 8px; border-bottom:1px solid rgba(255,255,255,0.08); padding-bottom:16px; }
.lab-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1.2px; color: var(--gold); font-weight:700; }
.lab-input-row { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
.lab-slider { flex: 1; accent-color: var(--gold); cursor: pointer; height: 32px; }
.lab-checkbox { accent-color: var(--gold); transform: scale(1.4); cursor: pointer; margin-right: 10px; }
.lab-select { background: #1a1a1a; border: 1px solid var(--border); color: #fff; padding: 12px; border-radius: 6px; font-family: var(--font-ui); font-size: 0.9rem; width: 100%; margin-top: 4px; cursor: pointer; }
.lab-val { font-variant-numeric: tabular-nums; width: 60px; text-align: right; font-size: 0.95rem; color: #fff; font-weight: 600; }
.lab-hint { font-size: 0.75rem; color: #888; font-style: italic; margin-top: -4px; line-height: 1.2; }

/* Chart Box */
.lab-chart-box { background: #121212; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 20px; position: relative; min-height: 400px; box-shadow: 0 4px 20px rgba(0,0,0,0.4); display: flex; flex-direction: column; margin-bottom: 20px; }
.lab-chart-box canvas { flex: 1; width: 100% !important; height: 100% !important; }
.lab-chart-row { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; min-height: 350px; }

/* Metrics */
.lab-metrics-table { width: 100%; border-collapse: collapse; font-size: 0.95rem; font-variant-numeric: tabular-nums; margin-top:10px; background: #161616; border-radius: 8px; overflow: hidden; border: 1px solid var(--border); }
.lab-metrics-table th { text-align: left; color: var(--gold); padding: 14px; border-bottom: 1px solid rgba(255,255,255,0.15); font-size: 0.8rem; text-transform: uppercase; background: #1a1a1a; letter-spacing: 0.5px; }
.lab-metrics-table td { padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,0.08); color: #e0e0e0; }
.lab-metrics-table tr:last-child td { border-bottom: none; }

/* Specification Window - Robust & Compact */
.lab-spec-container { 
    background: #000; 
    padding: 14px 20px; 
    border-radius: 6px; 
    border: 1px solid rgba(212,175,55,0.25); 
    box-shadow: inset 0 0 20px rgba(255,255,255,0.02); 
    margin-bottom: 20px; 
    color: #fff; 
    display: flex; 
    flex-direction: row; 
    align-items: center; 
    justify-content: flex-start;
    gap: 15px; 
    margin-top: 5px; 
    flex-wrap: wrap; 
    max-width: 100%;
}
.lab-spec-title { 
    font-family: var(--font-ui); 
    color: var(--gold); 
    font-size: 0.7rem; 
    text-transform: uppercase; 
    letter-spacing: 1.2px; 
    font-weight: 800; 
    border-right: 1px solid rgba(255,255,255,0.15); 
    padding-right: 15px; 
    margin-right: 5px; 
    white-space: nowrap; 
    flex-shrink: 0;
}
.lab-spec-eq { 
    font-family: var(--font-main); 
    font-size: 1.1rem; 
    text-align: left; 
    margin: 0; 
    line-height: 1.4; 
    flex: 1 1 auto; 
    min-width: 200px; 
    overflow-x: auto; 
    overflow-y: hidden;
}
.lab-spec-vec { 
    font-family: var(--font-main); 
    font-size: 0.95rem; 
    color: #aaa; 
    border-left: 1px solid rgba(255,255,255,0.1); 
    padding-left: 15px; 
    margin-left: auto; 
    white-space: normal; 
    flex: 0 1 auto; 
    text-align: right;
    word-break: break-word;
}
.lab-spec-container .katex-display { margin: 0.3em 0 !important; }
.lab-spec-container .katex { font-size: 1.0em; }

.lab-regen-btn { width: 100%; padding: 16px; background: rgba(212,175,55,0.1); border: 1px solid var(--gold); color: var(--gold); border-radius: 8px; font-weight: 700; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s; margin-bottom: 15px; font-size: 0.9rem; }
.lab-regen-btn:hover { background: rgba(212,175,55,0.25); color: #fff; }

.robustness-box { padding: 18px; background: #1a0a0a; border-left: 4px solid #ff4444; border-radius: 6px; font-size: 0.95rem; line-height: 1.6; color: #ffdddd; margin-top: 16px; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
.robustness-box.ok { background: #0a140f; border-left-color: #44ff88; color: #d0ffe0; }
.robustness-title { font-weight: 900; text-transform: uppercase; display: block; margin-bottom: 6px; letter-spacing: 0.5px; font-size: 0.85rem; opacity: 1; }

@media (max-width: 900px) {
  .lab-container { grid-template-columns: 1fr; grid-template-rows: auto 1fr; overflow-y: auto; }
  .lab-controls { border-right: none; border-bottom: 1px solid var(--border); max-height: none; height: auto; padding: 20px; }
  .lab-chart-row { grid-template-columns: 1fr; gap: 20px; }
  .lab-chart-box { min-height: 300px; }
  .lab-main { padding: 20px; overflow-y: visible; }
  #actions { gap: 4px; flex-wrap: wrap; justify-content: center; }
  .btn { padding: 6px 8px; font-size: 0.65rem; min-height: 32px; }
  .lab-spec-container { flex-direction: column; align-items: stretch; gap: 8px; }
  .lab-spec-title { border-right: none; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; padding-right: 0; margin-right: 0; width: 100%; text-align: center; }
  .lab-spec-vec { border-left: none; padding-left: 0; margin-left: 0; text-align: center; border-top: 1px solid rgba(255,255,255,0.1); padding-top:8px;}
  .lab-spec-eq { text-align: center; }
}

#gl{position:fixed;inset:0;width:100%;height:100%;display:block;z-index:1;touch-action:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}
#eqLayer{position:fixed;inset:0;z-index:700;pointer-events:none;overflow:hidden}
.eq{position:absolute;will-change:transform,opacity,filter;opacity:0.0;transform:translate3d(0,0,0);filter:drop-shadow(0 0 14px rgba(212,175,55,0.24));color:rgba(232,232,234,0.92);mix-blend-mode:screen}
.eq .katex{font-size:clamp(18px,2.1vw,28px)}
/* Fix scale for mobile */
#depthName{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:650;pointer-events:none;font-family:var(--font-main);font-weight:300;letter-spacing:0.08em;
font-size:clamp(1.5rem,5.5vw,6.5rem); color:rgba(212,175,55,0.24);text-shadow:0 0 55px rgba(212,175,55,0.18);filter:blur(0.2px);opacity:0.95;white-space:normal;text-align:center;width:90%;max-width:800px;line-height:1.1;}
#depthName::after{content:"";position:absolute;inset:-30px -80px;background:radial-gradient(closest-side,rgba(232,232,234,0.10),rgba(0,0,0,0.0) 70%);z-index:-1;filter:blur(10px);opacity:0.55}
#orbitHint{position:fixed;inset:0;z-index:600;pointer-events:none;opacity:0.55;background:radial-gradient(circle at 50% 50%,rgba(212,175,55,0.10) 0%,rgba(212,175,55,0.06) 20%,rgba(232,232,234,0.04) 34%,rgba(0,0,0,0.0) 60%),conic-gradient(from 220deg at 50% 50%,rgba(212,175,55,0.12),rgba(122,166,255,0.06),rgba(232,232,234,0.08),rgba(212,175,55,0.12));mask:radial-gradient(circle at 50% 50%,rgba(0,0,0,0) 0 26%,rgba(0,0,0,1) 34% 42%,rgba(0,0,0,0) 60%);filter:blur(0.6px)}

/* FULL SCREEN MODAL UPDATE */
#modal{position:fixed;inset:0;z-index:2000;display:none;background:rgba(0,0,0,0.85);backdrop-filter:blur(15px);touch-action:manipulation}
#modal.open{display:block}
#modalCard{position:absolute;top:0;left:0;width:100vw;height:100dvh;border-radius:0;border:none;background:#050505;display:grid;grid-template-rows:auto 1fr;overflow:hidden;}
#modalTop{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:16px 24px;border-bottom:1px solid rgba(255,255,255,0.10);background:#080808;}
#modalMeta{font-family:var(--font-ui);color:var(--silver-dim);letter-spacing:1.2px;text-transform:uppercase;font-size:0.85rem;display:flex;gap:10px;flex-wrap:wrap;align-items:center}
#modalMeta strong{color:var(--gold);font-weight:900}
#close{border-radius:4px;border:1px solid rgba(255,255,255,0.15);background:rgba(255,255,255,0.05);color:var(--silver);font-family:var(--font-ui);letter-spacing:1.2px;text-transform:uppercase;font-size:0.75rem;padding:8px 16px;cursor:pointer;transition:all 0.2s;touch-action:manipulation;font-weight:700;}
#close:hover{background:var(--gold); color:#000; border-color:var(--gold);}
#modalBody{overflow-y:auto;overflow-x:hidden;padding:0; -webkit-user-select:text;user-select:text;touch-action:pan-y; height: 100%;}
#modalBody::-webkit-scrollbar{width:8px;background:transparent}
#modalBody::-webkit-scrollbar-track{background:rgba(255,255,255,0.05)}
#modalBody::-webkit-scrollbar-thumb{background:#333;border-radius:4px;}
#modalBody::-webkit-scrollbar-thumb:hover{background:var(--gold)}

.article-content { padding: 40px clamp(20px, 5vw, 60px) 60px; max-width: 900px; margin: 0 auto; }
.article-content article{line-height:1.8;font-size:1.2rem;color:color-mix(in oklab, var(--silver) 88%, var(--silver-dim));text-align:justify;text-justify:inter-word}
.article-content h1,.article-content h2,.article-content h3{color:color-mix(in oklab,var(--gold-soft) 70%,var(--silver));line-height:1.15;margin:1.5rem 0 0.8rem;text-align:left}
.article-content h1{font-size:clamp(2.0rem,4vw,3.2rem);margin-top:0}
.article-content h2{font-size:clamp(1.5rem,3vw,2.2rem)}
.article-content h3{font-size:1.3rem;font-style:italic}
.article-content p{margin:0 0 1.5rem}

#err{position:fixed;inset:0;z-index:9999;display:none;padding:96px 18px 18px;background:#050505;color:#e8e8ea;font-family:var(--font-ui);-webkit-user-select:text;user-select:text;touch-action:pan-y}
#err h2{margin:0 0 12px;font-weight:900;letter-spacing:1px;color:#D4AF37;text-transform:uppercase}
#err pre{margin:12px 0 0;padding:12px;border-radius:14px;border:1px solid rgba(255,255,255,0.10);background:rgba(18,18,18,0.6);overflow:auto;max-height:55vh;white-space:pre-wrap;line-height:1.5;opacity:0.9}
</style>
</head>

<body>
<nav id="nav" aria-label="Primary">
  <div id="brand" role="button" tabindex="0">Anıl Kaya</div>
  <div id="actions">
    <button class="btn lab-btn" onclick="Lab.open('IV')">IV / 2SLS</button>
    <button class="btn lab-btn" onclick="Lab.open('VAR')">VAR</button>
    <button class="btn lab-btn" onclick="Lab.open('VECM')">VECM</button>
    <button class="btn lab-btn" onclick="Lab.open('ARDL')">ARDL</button>
    <button class="btn lab-btn" onclick="Lab.open('OU')">OU Process</button>
    <button class="btn lab-btn" onclick="Lab.open('MCMC')">MCMC</button>
    <a class="btn" href="https://www.linkedin.com/in/anillkaya" target="_blank" rel="noopener noreferrer">LinkedIn</a>
    <button class="btn" id="theme" type="button" aria-label="Toggle theme">Light</button>
  </div>
</nav>

<canvas id="gl" aria-hidden="true"></canvas>
<div id="orbitHint" aria-hidden="true"></div>
<div id="depthName" aria-hidden="true">In Econometrics, We Trust</div>
<div id="eqLayer" aria-hidden="true"></div>

<div id="modal" role="dialog" aria-modal="true" aria-label="Content reader">
  <div id="react-app"></div>
</div>

<div id="err"><h2>Render error</h2><div>Error details:</div><pre id="errText"></pre></div>

<script>
(function(){
"use strict";

/* =========================
   MATH ENGINE
   ========================= */
const MathLab = {
  sum: (arr) => arr.reduce((a,b)=>a+b, 0),
  mean: (arr) => arr.reduce((a,b)=>a+b,0)/arr.length,
  variance: (arr, m) => {
    const mean = m !== undefined ? m : MathLab.mean(arr);
    return arr.reduce((a,b)=>a+(b-mean)**2,0)/(arr.length-1);
  },
  pnorm: (z) => {
    const b1 =  0.319381530; const b2 = -0.356563782; const b3 =  1.781477937; const b4 = -1.821255978; const b5 =  1.330274429;
    const p  =  0.2316419; const c2 =  0.39894228;
    const a = Math.abs(z); const t = 1.0 / (1.0 + a*p);
    const b = c2 * Math.exp((-z*z)/2.0);
    const n = ((((b5*t+b4)*t+b3)*t+b2)*t+b1)*t;
    const val = 1.0 - b*n; return (z < 0.0) ? 1.0 - val : val;
  },
  pValT: (t, df) => 2 * (1 - MathLab.pnorm(Math.abs(t))),
  pValF: (f, df1, df2) => (f < 0.1) ? 0.99 : 1 / (1 + f),
  generateRandom: (type, params) => {
    if(type === 'normal') {
      const { mean, std } = params;
      let u=0,v=0; while(u===0)u=Math.random(); while(v===0)v=Math.random();
      return mean + std * Math.sqrt(-2.0*Math.log(u)) * Math.cos(2.0*Math.PI*v);
    } else if(type === 'uniform') {
      const { min, max } = params; return min + Math.random()*(max-min);
    } else if(type === 't') {
      const { df, std } = params;
      let u=0,v=0; while(u===0)u=Math.random(); while(v===0)v=Math.random();
      const norm = Math.sqrt(-2.0*Math.log(u)) * Math.cos(2.0*Math.PI*v);
      let chi = 0;
      for(let i=0;i<df;i++){
         let a=0,b=0; while(a===0)a=Math.random(); while(b===0)b=Math.random();
         let z = Math.sqrt(-2.0*Math.log(a)) * Math.cos(2.0*Math.PI*b);
         chi += z*z;
      }
      return (norm / Math.sqrt(chi/df)) * std; 
    }
    return 0;
  },
  acf: (series, lag) => {
    const n = series.length; const m = MathLab.mean(series);
    let num=0, den=0;
    for(let i=0;i<n;i++) den += (series[i]-m)**2;
    for(let i=lag;i<n;i++) num += (series[i]-m)*(series[i-lag]-m);
    return num/den;
  },
  pacf: (series, maxLag) => {
    let acfs = []; for(let i=0;i<=maxLag;i++) acfs.push(MathLab.acf(series,i));
    let res = [1.0];
    for(let k=1; k<=maxLag; k++){
       let R = []; for(let i=0;i<k;i++){ let row = []; for(let j=0;j<k;j++) row.push(acfs[Math.abs(i-j)]); R.push(row); }
       let r = []; for(let i=1;i<=k;i++) r.push(acfs[i]);
       const sol = MathLab.solveLinear(R, r); res.push(sol[sol.length-1]);
    }
    return res;
  },
  solveLinear: (A, b) => {
    const n = A.length; let M = A.map((row, i) => [...row, b[i]]);
    for (let i = 0; i < n; i++) {
        let maxRow = i; for (let k = i + 1; k < n; k++) if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;
        [M[i], M[maxRow]] = [M[maxRow], M[i]];
        for (let k = i + 1; k < n; k++) { const f = M[k][i] / M[i][i]; for (let j = i; j <= n; j++) M[k][j] -= M[i][j] * f; }
    }
    const x = new Array(n).fill(0);
    for (let i = n - 1; i >= 0; i--) { let sum = 0; for (let j = i + 1; j < n; j++) sum += M[i][j] * x[j]; x[i] = (M[i][n] - sum) / M[i][i]; }
    return x;
  },
  olsMultivariate: (y, X) => {
    const n = y.length; const k = X[0].length;
    let XtX = Array(k).fill(0).map(()=>Array(k).fill(0)); let Xty = Array(k).fill(0);
    for(let i=0; i<n; i++){
        for(let r=0; r<k; r++){ Xty[r] += X[i][r] * y[i]; for(let c=0; c<k; c++){ XtX[r][c] += X[i][r] * X[i][c]; } }
    }
    const beta = MathLab.solveLinear(XtX, Xty);
    let rss = 0; for(let i=0; i<n; i++){ let yhat = 0; for(let j=0; j<k; j++) yhat += X[i][j] * beta[j]; rss += (y[i] - yhat)**2; }
    return { rss, beta };
  },
  grangerTest: (y, x, lags=1) => {
    const n = y.length; const effN = n - lags;
    let Y_target = [], X_restr = [], X_unrestr = [];
    for(let i=lags; i<n; i++){
        Y_target.push(y[i]); let rowR = [1], rowU = [1];
        for(let l=1; l<=lags; l++) rowR.push(y[i-l]);
        for(let l=1; l<=lags; l++) rowU.push(y[i-l]);
        for(let l=1; l<=lags; l++) rowU.push(x[i-l]);
        X_restr.push(rowR); X_unrestr.push(rowU);
    }
    const resR = MathLab.olsMultivariate(Y_target, X_restr);
    const resU = MathLab.olsMultivariate(Y_target, X_unrestr);
    const p = lags; const k = 2*lags + 1;
    return ((resR.rss - resU.rss) / p) / (resU.rss / (effN - k));
  },
  ols: (x, y) => {
    const n = x.length; const mx = MathLab.mean(x); const my = MathLab.mean(y);
    let num=0, den=0; for(let i=0;i<n;i++){ num += (x[i]-mx)*(y[i]-my); den += (x[i]-mx)**2; }
    const beta = num/den; const alpha = my - beta*mx;
    const yhat = x.map(xi => alpha + beta*xi);
    const resid = y.map((yi,i) => yi - yhat[i]);
    const ssr = resid.reduce((a,b)=>a+b**2, 0); const sst = y.reduce((a,b)=>a+(b-my)**2, 0);
    const r2 = 1 - (ssr/sst); const sigma2 = ssr/(n-2); const seBeta = Math.sqrt(sigma2/den);
    const tStat = beta/seBeta; const pVal = MathLab.pValT(tStat, n-2); const fStat = (r2/1) / ((1-r2)/(n-2)); 
    return { alpha, beta, r2, tStat, pVal, seBeta, resid, yhat, fStat, sigma2 };
  },
  iv2sls: (y, x, z) => {
    const n = y.length;
    const stage1 = MathLab.ols(z, x); // X = pi0 + pi1*Z + v
    const xHat = stage1.yhat;
    const stage2 = MathLab.ols(xHat, y); // Y = beta0 + beta1*xHat + e
    const resid = y.map((yi, i) => yi - (stage2.alpha + stage2.beta * x[i]));
    const ssr = resid.reduce((a,b)=>a+b**2, 0);
    const sigma2 = ssr/(n-2);
    const mxHat = MathLab.mean(xHat);
    let SxxHat = 0; for(let i=0;i<n;i++) SxxHat += (xHat[i]-mxHat)**2;
    const seBetaIV = Math.sqrt(sigma2 / SxxHat);
    const tStat = stage2.beta / seBetaIV; const pVal = MathLab.pValT(tStat, n-2);
    return { stage1, alpha: stage2.alpha, beta: stage2.beta, seBeta: seBetaIV, tStat, pVal, resid, yhat: stage2.yhat };
  },
  bootstrapOLS: (x, y, B=100) => {
     const n = x.length; const est = MathLab.ols(x, y); const resids = est.resid;
     let betas = [];
     for(let b=0; b<B; b++){
         let y_boot = [];
         for(let i=0; i<n; i++){ const idx = Math.floor(Math.random() * n); y_boot.push(est.yhat[i] + resids[idx]); }
         betas.push(MathLab.ols(x, y_boot).beta);
     }
     betas.sort((a,b)=>a-b);
     return { betas, lower: betas[Math.floor(B*0.025)], upper: betas[Math.floor(B*0.975)] };
  },
  matVec2: (A, v) => [ A[0][0]*v[0] + A[0][1]*v[1], A[1][0]*v[0] + A[1][1]*v[1] ]
};

/* =========================
   LAB LOGIC
   ========================= */
const Lab = {
  chartInstances: [],
  state: { distType: 'normal', distDf: 5, shockSize: 1, showCI: false, initDiseq: 10, het: 0, rho: 0, instRel: 0.8, endog: 0.5, ouMean: 0, ouTheta: 0.5, ouSigma: 0.5, mcmcIter: 2000, bootstrap: false, varNoise: 1, constTerm: 0 },
  
  open: (type) => {
    modal.classList.add("open");
    Lab.renderUI(type);
  },

  renderUI: (type) => {
    const html = `
      <div id="modalCard">
         <div id="modalTop">
           <div id="modalMeta"><strong>Interactive Lab</strong><span>•</span><span>${type}</span></div>
           <button id="close">Close &times;</button>
         </div>
         <div id="modalBody">
            <div class="lab-container">
               <div class="lab-controls" id="labControls"></div>
               <div class="lab-main" id="labMain"></div>
            </div>
         </div>
      </div>
    `;
    modal.innerHTML = html;
    document.getElementById("close").onclick = closeModal;
    
    Chart.defaults.color = '#c0c0c0';
    Chart.defaults.borderColor = 'rgba(255,255,255,0.1)';
    Chart.defaults.scale.grid.display = false;
    
    Lab.chartInstances.forEach(c => c.destroy());
    Lab.chartInstances = [];

    if(type === 'IV') Lab.initIV();
    if(type === 'VAR') Lab.initVAR();
    if(type === 'VECM') Lab.initVECM();
    if(type === 'ARDL') Lab.initARDL();
    if(type === 'OU') Lab.initOU();
    if(type === 'MCMC') Lab.initMCMC();
    
    Lab.renderMath();
  },
  
  renderMath: () => {
    setTimeout(() => { 
        if(window.renderMathInElement) {
            window.renderMathInElement(document.getElementById("modalBody"), {
               delimiters: [ {left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false} ]
            });
        }
    }, 100);
  },

  createControl: (label, id, min, max, step, val, hint, onChange) => {
    const div = document.createElement("div");
    div.className = "lab-group";
    div.innerHTML = `
      <div class="lab-input-row"><span class="lab-label">${label}</span><span class="lab-val" id="val_${id}">${val}</span></div>
      <div class="lab-hint">${hint}</div>
      <input type="range" id="${id}" class="lab-slider" min="${min}" max="${max}" step="${step}" value="${val}">
    `;
    div.querySelector("input").addEventListener("input", (e) => {
      document.getElementById(`val_${id}`).textContent = e.target.value;
      onChange(parseFloat(e.target.value));
    });
    return div;
  },

  createToggle: (label, id, checked, onChange) => {
    const div = document.createElement("div");
    div.className = "lab-group";
    div.innerHTML = `
      <div class="lab-input-row">
        <span class="lab-label">${label}</span>
        <input type="checkbox" id="${id}" class="lab-checkbox" ${checked ? "checked" : ""}>
      </div>
    `;
    div.querySelector("input").addEventListener("change", (e) => {
      onChange(e.target.checked);
    });
    return div;
  },

  createDistSelector: (onUpdate) => {
    const div = document.createElement("div");
    div.className = "lab-group";
    div.innerHTML = `
      <span class="lab-label">Stochastic Error Process</span>
      <select id="distSelect" class="lab-select">
        <option value="normal">Normal (Gaussian) White Noise</option>
        <option value="t">Student-t (Fat Tails/Outliers)</option>
        <option value="uniform">Uniform Distribution</option>
      </select>
      <div id="dfControl" style="display:none; margin-top:5px;">
        <div class="lab-input-row"><span class="lab-label">Deg. Freedom</span><span class="lab-val" id="val_df">5</span></div>
        <input type="range" id="dfRange" class="lab-slider" min="3" max="30" step="1" value="5">
      </div>
    `;
    const sel = div.querySelector("select");
    const dfC = div.querySelector("#dfControl");
    const dfR = div.querySelector("#dfRange");
    
    sel.addEventListener("change", (e)=>{
        Lab.state.distType = e.target.value;
        dfC.style.display = (e.target.value === 't') ? 'block' : 'none';
        onUpdate();
    });
    dfR.addEventListener("input", (e)=>{
        document.getElementById("val_df").innerText = e.target.value;
        Lab.state.distDf = parseInt(e.target.value);
        onUpdate();
    });
    return div;
  },

  generateButton: (txt, onClick) => {
    const btn = document.createElement("button");
    btn.className = "lab-regen-btn";
    btn.innerText = txt;
    btn.onclick = onClick;
    return btn;
  },

  getNoise: (std) => {
     if(Lab.state.distType === 'uniform') return MathLab.generateRandom('uniform', {min: -std*1.73, max: std*1.73}); 
     if(Lab.state.distType === 't') return MathLab.generateRandom('t', {df: Lab.state.distDf, std: std});
     return MathLab.generateRandom('normal', {mean: 0, std: std});
  },
  
  renderACFPACF: (resid, containerId, titleSuffix) => {
    const lags = 12;
    let acfVal = [];
    let pacfVal = MathLab.pacf(resid, lags).slice(1);
    for(let i=1;i<=lags;i++) acfVal.push(MathLab.acf(resid, i));

    const ctx = document.getElementById(containerId).getContext('2d');
    const labels = Array.from({length:lags}, (_,i)=>i+1);
    const crit = 1.96 / Math.sqrt(resid.length);
    const critArrPos = new Array(lags).fill(crit);
    const critArrNeg = new Array(lags).fill(-crit);

    if(Chart.getChart(containerId)) Chart.getChart(containerId).destroy();

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                { label: 'ACF', data: acfVal, backgroundColor: 'rgba(212,175,55,0.9)', barPercentage: 0.6 },
                { label: 'PACF', data: pacfVal, backgroundColor: 'rgba(122,166,255,0.9)', barPercentage: 0.6 },
                { label: '95% CI', data: critArrPos, type:'line', borderColor:'rgba(255,255,255,0.4)', pointRadius:0, borderWidth:1, borderDash:[5,5] },
                { label: '95% CI', data: critArrNeg, type:'line', borderColor:'rgba(255,255,255,0.4)', pointRadius:0, borderWidth:1, borderDash:[5,5] }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { title: { display: true, text: `ACF & PACF ${titleSuffix}`, color: '#e8e8ea', font: {size:14} }, legend: {display:false} },
            scales: { y: { min: -1, max: 1, grid:{display:false} }, x: { grid:{display:false} } }
        }
    });
  },

  updateSpecPanel: (eq, vec) => {
     document.getElementById("labSpecContainer").innerHTML = `
        <div class="lab-spec-title">Model Specification</div>
        <div class="lab-spec-eq">${eq}</div>
        <div class="lab-spec-vec">${vec}</div>
     `;
  },

  // --- IV LAB ---
  initIV: () => {
    Lab.state = { ...Lab.state, beta0: 10, beta1: 1.5, n: 200, endog: 0.7, instRel: 0.8, showCI: true, bootstrap: false };
    const controls = document.getElementById("labControls");
    const main = document.getElementById("labMain");
    
    controls.appendChild(Lab.generateButton("Simulate New Data", Lab.updateIV));
    controls.appendChild(Lab.createDistSelector(Lab.updateIV));
    controls.appendChild(Lab.createControl("Endogeneity (Corr X,u)", "endog", -0.9, 0.9, 0.1, 0.7, "Degree of correlation between regressor and error term.", v=>{Lab.state.endog=v; Lab.updateIV();}));
    controls.appendChild(Lab.createControl("Instrument Relevance (Corr Z,X)", "instRel", 0, 0.9, 0.1, 0.8, "Strength of the instrument. Values < 0.3 imply Weak IV.", v=>{Lab.state.instRel=v; Lab.updateIV();}));
    controls.appendChild(Lab.createControl("True Slope (β₁)", "b1", 0, 3, 0.1, 1.5, "Structural Parameter to estimate.", v=>{Lab.state.beta1=v; Lab.updateIV();}));
    controls.appendChild(Lab.createControl("Sample Size (N)", "n", 50, 2000, 50, 200, "Number of observations.", v=>{Lab.state.n=v; Lab.updateIV();}));
    controls.appendChild(Lab.createToggle("Bootstrap 95% CI", "bootstrap", false, v=>{Lab.state.bootstrap=v; Lab.updateIV();}));

    main.innerHTML = `
      <div class="lab-spec-container" id="labSpecContainer"></div>
      <div class="lab-chart-box"><canvas id="ivChart"></canvas></div>
      <div class="lab-chart-row">
        <div class="lab-chart-box"><canvas id="residChart"></canvas></div>
        <div class="lab-chart-box"><canvas id="ivACF"></canvas></div>
      </div>
      <div class="lab-chart-box" style="min-height:auto; height:auto; padding:0; background:transparent; border:none; box-shadow:none;"><div id="ivMetrics"></div></div>
      <div id="ivRobustness"></div>
    `;
    Lab.updateIV();
  },

  updateIV: () => {
    const { beta0, beta1, n, endog, instRel, bootstrap } = Lab.state;
    let x = [], y = [], z = [];
    
    // Simulate Data
    for(let i=0; i<n; i++){
        let u = Lab.getNoise(1);
        let v_indep = Lab.getNoise(1);
        let v = endog * u + Math.sqrt(1 - endog*endog) * v_indep;
        
        let zi = Lab.getNoise(1);
        let xi = instRel * zi + v;
        let yi = beta0 + beta1 * xi + u;
        
        x.push(xi); y.push(yi); z.push(zi);
    }
    
    const olsEst = MathLab.ols(x, y);
    const ivEst = MathLab.iv2sls(y, x, z);
    
    let bootInfo = "";
    if(bootstrap){
       const bootRes = MathLab.bootstrapOLS(x, y, 500);
       bootInfo = `<br><span style="color:#D4AF37">Bootstrap 95% CI (OLS): [${bootRes.lower.toFixed(3)}, ${bootRes.upper.toFixed(3)}]</span>`;
    }

    const fStat1 = ivEst.stage1.fStat;
    const weakIV = fStat1 < 10;
    const hausmanStat = Math.abs(olsEst.beta - ivEst.beta) / Math.sqrt(Math.abs(ivEst.seBeta**2 - olsEst.seBeta**2));
    const endogDetected = hausmanStat > 1.96;
    let sigIV = ivEst.pVal < 0.05 ? "**" : "";

    Lab.updateSpecPanel(
      `$$ Y = \\beta_0 + \\beta_1 X + u $$ <br> $$ X = \\pi_0 + \\pi_1 Z + v $$`,
      `$$ \\hat{\\beta}_{OLS} = ${olsEst.beta.toFixed(3)}, \\quad \\hat{\\beta}_{2SLS} = ${ivEst.beta.toFixed(3)} $$`
    );

    document.getElementById("ivMetrics").innerHTML = `
      <table class="lab-metrics-table">
        <thead><tr><th>Estimator</th><th>$\\hat{\\beta}_1$</th><th>Std. Error</th><th>Bias</th><th>t-Stat</th></tr></thead>
        <tbody>
          <tr><td>OLS (Biased)</td><td>${olsEst.beta.toFixed(4)}</td><td>${olsEst.seBeta.toFixed(4)}</td><td style="color:${Math.abs(olsEst.beta-beta1)>0.2?'#ff4444':'#888'}">${(olsEst.beta-beta1).toFixed(3)}</td><td>${olsEst.tStat.toFixed(2)}</td></tr>
          <tr><td>2SLS (Consistent)</td><td>${ivEst.beta.toFixed(4)} ${sigIV}</td><td>${ivEst.seBeta.toFixed(4)}</td><td style="color:#44ff88">${(ivEst.beta-beta1).toFixed(3)}</td><td>${ivEst.tStat.toFixed(2)}</td></tr>
        </tbody>
      </table>
      <div style="margin-top:10px; font-size:0.9rem;">${bootInfo}</div>
    `;
    
    document.getElementById("ivRobustness").innerHTML = `
       <div class="robustness-box ${weakIV?'warn':'ok'}">
         <span class="robustness-title">WEAK INSTRUMENT TEST (First Stage F-Stat)</span>
         F = ${fStat1.toFixed(2)}. ${weakIV ? "Warning: F < 10. Instrument is weak. 2SLS may be biased." : "Passed: Instrument is strong."}
       </div>
       <div class="robustness-box ${endogDetected?'ok':'warn'}">
         <span class="robustness-title">HAUSMAN SPECIFICATION TEST</span>
         Stat = ${hausmanStat.toFixed(2)}. ${endogDetected ? "Reject H0: Endogeneity present. Use IV." : "Fail to reject H0: OLS may be consistent."}
       </div>
    `;

    // FIX: Generate mathematically correct regression lines using range
    const minX = Math.min(...x), maxX = Math.max(...x);
    const lineOLS = [{x: minX, y: olsEst.alpha + olsEst.beta*minX}, {x: maxX, y: olsEst.alpha + olsEst.beta*maxX}];
    const lineIV = [{x: minX, y: ivEst.alpha + ivEst.beta*minX}, {x: maxX, y: ivEst.alpha + ivEst.beta*maxX}];
    
    if(Lab.chartInstances[0]) Lab.chartInstances[0].destroy();
    Lab.chartInstances[0] = new Chart(document.getElementById('ivChart').getContext('2d'), {
         type: 'scatter',
         data: { datasets: [
             { label: 'Observed Data', data: x.map((v,i)=>({x:v,y:y[i]})), backgroundColor: 'rgba(255,255,255,0.1)', pointRadius:3 },
             { label: 'Biased OLS Fit', data: lineOLS, type:'line', borderColor: '#ff4444', borderWidth:2, pointRadius:0, fill:false },
             { label: 'Consistent 2SLS Fit', data: lineIV, type:'line', borderColor: '#44ff88', borderWidth:3, pointRadius:0, fill:false }
         ]},
         options: { 
             responsive: true, maintainAspectRatio: false, 
             plugins: { title: { display: true, text: '2SLS vs OLS Estimates', color:'#e8e8ea', font:{size:16} }, legend:{labels:{color:'#bbb'}} },
             scales: { x: { grid:{display:false}, ticks:{color:'#888'} }, y:{grid:{display:false}, ticks:{color:'#888'}} } 
         }
    });

    if(Lab.chartInstances[1]) Lab.chartInstances[1].destroy();
    Lab.chartInstances[1] = new Chart(document.getElementById('residChart').getContext('2d'), {
         type: 'bar',
         data: { labels: x.map((_,i)=>i), datasets: [{ label: 'IV Residuals', data: ivEst.resid, backgroundColor: 'rgba(212,175,55,0.6)' }] },
         options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Residual Diagnostics', color:'#e8e8ea' } }, scales:{ x:{ticks:{display:false}, grid:{display:false}}, y:{grid:{display:false}} } }
    });

    Lab.renderACFPACF(ivEst.resid, 'ivACF', '(IV Residuals)');
    Lab.renderMath();
  },

  // --- VAR LAB ---
  initVAR: () => {
    Lab.state = { ...Lab.state, a11: 0.7, a12: 0.2, a21: 0.1, a22: 0.6, lag: 1, T: 100, noise: 1, shockSize: 1, rho: 0, constTerm: 0.5 };
    const controls = document.getElementById("labControls");
    const main = document.getElementById("labMain");
    
    controls.appendChild(Lab.generateButton("Simulate System", Lab.updateVAR));
    controls.appendChild(Lab.createDistSelector(Lab.updateVAR));
    controls.appendChild(Lab.createControl("A[1,1] Persistence", "a11", -1.2, 1.2, 0.05, 0.7, "Impact of Y1(t-1) on Y1(t).", v=>{Lab.state.a11=v; Lab.updateVAR();}));
    controls.appendChild(Lab.createControl("A[1,2] Feedback", "a12", -1, 1, 0.05, 0.2, "Impact of Y2(t-1) on Y1(t).", v=>{Lab.state.a12=v; Lab.updateVAR();}));
    controls.appendChild(Lab.createControl("A[2,1] Feedback", "a21", -1, 1, 0.05, 0.1, "Impact of Y1(t-1) on Y2(t).", v=>{Lab.state.a21=v; Lab.updateVAR();}));
    controls.appendChild(Lab.createControl("A[2,2] Persistence", "a22", -1.2, 1.2, 0.05, 0.6, "Impact of Y2(t-1) on Y2(t).", v=>{Lab.state.a22=v; Lab.updateVAR();}));
    controls.appendChild(Lab.createControl("Error Corr (ρ)", "rho", -0.9, 0.9, 0.1, 0, "Correlation between structural shocks.", v=>{Lab.state.rho=v; Lab.updateVAR();}));
    controls.appendChild(Lab.createControl("Shock Magnitude", "shockSize", 0.5, 5, 0.5, 1, "Size of unit impulse.", v=>{Lab.state.shockSize=v; Lab.updateVAR();}));
    controls.appendChild(Lab.createControl("Intercept Term", "constTerm", -2, 2, 0.1, 0.5, "Constant drift parameter.", v=>{Lab.state.constTerm=v; Lab.updateVAR();}));

    main.innerHTML = `
      <div class="lab-spec-container" id="labSpecContainer"></div>
      <div class="lab-chart-box"><canvas id="varSeries"></canvas></div>
      <div class="lab-chart-row">
         <div class="lab-chart-box"><canvas id="varIRF"></canvas></div>
         <div class="lab-chart-box"><canvas id="varACF"></canvas></div>
      </div>
      <div class="lab-chart-box" style="min-height:auto; height:auto; padding:0; background:transparent; border:none; box-shadow:none;"><div id="varMetrics"></div></div>
      <div id="varRobustness"></div>
    `;
    Lab.updateVAR();
  },

  updateVAR: () => {
    const { a11, a12, a21, a22, T, noise, shockSize, rho, constTerm } = Lab.state;
    const tr = a11 + a22;
    const det = a11*a22 - a12*a21;
    const delta = Math.sqrt(Math.abs(tr*tr - 4*det));
    const maxEig = Math.max(Math.abs((tr+delta)/2), Math.abs((tr-delta)/2));
    const isStable = maxEig < 1.0;

    let y1 = [0], y2 = [0];
    for(let t=1; t<T; t++){
       let u1 = Lab.getNoise(noise);
       let u2_indep = Lab.getNoise(noise);
       let u2 = rho * u1 + Math.sqrt(1 - rho*rho) * u2_indep;
       let ny1 = constTerm + a11*y1[t-1] + a12*y2[t-1] + u1;
       let ny2 = constTerm + a21*y1[t-1] + a22*y2[t-1] + u2;
       y1.push(ny1); y2.push(ny2);
    }
    
    const fStatGranger = MathLab.grangerTest(y1, y2, 1);
    const grangerP = MathLab.pValF(fStatGranger, 1, T-3); 
    const grangerMsg = grangerP < 0.05 ? "Reject H0 (Y2 causes Y1)" : "Fail to Reject H0";

    // CIRF CALCULATION
    let irf1 = [], irf2 = [];
    let cirf1 = [shockSize], cirf2 = [0];
    let current = [shockSize, 0]; // Initial shock
    let cum1 = shockSize, cum2 = 0;
    
    const A = [[a11, a12], [a21, a22]];
    for(let h=1; h<=20; h++){
       current = MathLab.matVec2(A, current);
       cum1 += current[0];
       cum2 += current[1];
       cirf1.push(cum1); 
       cirf2.push(cum2);
    }
    
    Lab.updateSpecPanel(
      `$$ Y_t = C + A Y_{t-1} + u_t, \\quad \\Sigma = \\sigma^2 \\begin{bmatrix} 1 & ${rho.toFixed(2)} \\\\ ${rho.toFixed(2)} & 1 \\end{bmatrix} $$`,
      `$$ A = \\begin{bmatrix} ${a11.toFixed(2)} & ${a12.toFixed(2)} \\\\ ${a21.toFixed(2)} & ${a22.toFixed(2)} \\end{bmatrix}, \\quad \\lambda_{max} = ${maxEig.toFixed(3)} $$`
    );

    document.getElementById("varMetrics").innerHTML = `
      <table class="lab-metrics-table">
        <thead><tr><th>Metric</th><th>Value</th><th>Interpretation</th></tr></thead>
        <tbody>
          <tr><td>Max Eigenvalue</td><td>${maxEig.toFixed(4)}</td><td>${isStable ? "Stable (<1)" : "Unstable (>1)"}</td></tr>
          <tr><td>System Determinant</td><td>${det.toFixed(4)}</td><td>Cross-equation feedback</td></tr>
          <tr><td>Granger F-Stat</td><td>${fStatGranger.toFixed(2)}</td><td>${grangerMsg}</td></tr>
        </tbody>
      </table>
    `;
    
    let stabStatus = isStable ? "ok" : "warn";
    document.getElementById("varRobustness").innerHTML = `
       <div class="robustness-box ${stabStatus}">
         <span class="robustness-title">STABILITY CONDITION (Roots of Characteristic Polynomial)</span>
         Max Root Modulus = ${maxEig.toFixed(3)}. ${isStable ? "PASSED: All roots lie inside the unit circle." : "FAILED: Explosive roots detected."}
       </div>
       <div class="robustness-box ok">
         <span class="robustness-title">MULTIVARIATE GRANGER CAUSALITY TEST ($Y_2 \\to Y_1$)</span>
         F-Stat: ${fStatGranger.toFixed(2)} (p &approx; ${grangerP.toFixed(3)}). ${grangerMsg}.
       </div>
    `;

    if(Lab.chartInstances[0]) Lab.chartInstances[0].destroy();
    Lab.chartInstances[0] = new Chart(document.getElementById('varSeries').getContext('2d'), {
         type: 'line',
         data: { labels: Array.from({length: T}, (_, i) => i), datasets: [{ label: 'Y1', data: y1, borderColor: '#D4AF37', borderWidth:1.5, pointRadius:0 }, { label: 'Y2', data: y2, borderColor: '#7aa6ff', borderWidth:1.5, pointRadius:0 }] },
         options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Simulated VAR(1) Process', color:'#e8e8ea' } }, scales:{ x:{grid:{display:false}}, y:{grid:{display:false}} } }
    });

    if(Lab.chartInstances[1]) Lab.chartInstances[1].destroy();
    Lab.chartInstances[1] = new Chart(document.getElementById('varIRF').getContext('2d'), {
         type: 'line',
         data: { labels: Array.from({length: 21}, (_, i) => i), datasets: [{ label: 'Cumulative Response Y1', data: cirf1, borderColor: '#D4AF37', borderDash:[5,5] }, { label: 'Cumulative Response Y2', data: cirf2, borderColor: '#7aa6ff' }] },
         options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: `Cumulative Impulse Response (CIRF) to Y1 Shock`, color:'#e8e8ea' } }, scales:{ x:{grid:{display:false}}, y:{grid:{display:false}} } }
    });
    
    Lab.renderACFPACF(y1, 'varACF', 'of Y1 Series');
    Lab.renderMath();
  },

  // --- VECM LAB ---
  initVECM: () => {
    Lab.state = { ...Lab.state, vecmBeta: 2.0, alphaY: -0.3, alphaX: 0.1, n: 200, noise: 1 };
    const controls = document.getElementById("labControls");
    const main = document.getElementById("labMain");
    
    controls.appendChild(Lab.generateButton("Simulate System", Lab.updateVECM));
    controls.appendChild(Lab.createDistSelector(Lab.updateVECM));
    controls.appendChild(Lab.createControl("Cointegration (β)", "vecmBeta", 0.1, 4.0, 0.1, 2.0, "Long-run equilibrium slope: Y = βX", v=>{Lab.state.vecmBeta=v; Lab.updateVECM();}));
    controls.appendChild(Lab.createControl("Adj. Speed Y (α_y)", "alphaY", -1.0, 0.0, 0.05, -0.3, "Speed of convergence for Y.", v=>{Lab.state.alphaY=v; Lab.updateVECM();}));
    controls.appendChild(Lab.createControl("Adj. Speed X (α_x)", "alphaX", 0.0, 1.0, 0.05, 0.1, "Speed of convergence for X.", v=>{Lab.state.alphaX=v; Lab.updateVECM();}));
    controls.appendChild(Lab.createControl("Sample Size (N)", "n", 50, 500, 50, 200, "Number of observations.", v=>{Lab.state.n=v; Lab.updateVECM();}));

    main.innerHTML = `
      <div class="lab-spec-container" id="labSpecContainer"></div>
      <div class="lab-chart-box"><canvas id="vecmSeries"></canvas></div>
      <div class="lab-chart-row">
         <div class="lab-chart-box"><canvas id="vecmScatter"></canvas></div>
         <div class="lab-chart-box"><canvas id="vecmECT"></canvas></div>
      </div>
      <div class="robustness-box ok" id="vecmStatus"></div>
    `;
    Lab.updateVECM();
  },

  updateVECM: () => {
    const { vecmBeta, alphaY, alphaX, n, noise } = Lab.state;
    
    let x = [10], y = [10 * vecmBeta];
    let ectSeries = [0];

    for(let t=1; t<n; t++){
       let prevX = x[t-1];
       let prevY = y[t-1];
       let ect = prevY - vecmBeta * prevX;
       ectSeries.push(ect);

       let dx = alphaX * ect + Lab.getNoise(noise);
       let dy = alphaY * ect + Lab.getNoise(noise);

       x.push(prevX + dx);
       y.push(prevY + dy);
    }
    const est = MathLab.ols(x, y);
    
    Lab.updateSpecPanel(
      `$$ \\Delta Y_t = \\alpha_y(Y_{t-1} - \\beta X_{t-1}) + \\epsilon_{y,t} \\quad \\Delta X_t = \\alpha_x(Y_{t-1} - \\beta X_{t-1}) + \\epsilon_{x,t} $$`,
      `$$ \\text{True } \\beta = ${vecmBeta}, \\quad \\text{OLS Est } \\hat{\\beta} = ${est.beta.toFixed(4)} $$`
    );

    if(Lab.chartInstances[0]) Lab.chartInstances[0].destroy();
    Lab.chartInstances[0] = new Chart(document.getElementById("vecmSeries").getContext('2d'), {
       type: 'line',
       data: { labels: Array.from({length:n},(_,i)=>i), datasets: [
          {label:'Y (Non-stationary)', data:y, borderColor:'#D4AF37', borderWidth:1.5, pointRadius:0},
          {label:'X (Non-stationary)', data:x, borderColor:'#7aa6ff', borderWidth:1.5, pointRadius:0}
       ]},
       options: { responsive:true, maintainAspectRatio:false, plugins:{title:{display:true, text:'Cointegrated Series', color:'#e8e8ea'}}, scales:{x:{display:false}, y:{grid:{display:false}}} }
    });

    if(Lab.chartInstances[1]) Lab.chartInstances[1].destroy();
    Lab.chartInstances[1] = new Chart(document.getElementById("vecmScatter").getContext('2d'), {
       type: 'scatter',
       data: { datasets: [{label:'Y vs X', data: x.map((v,i)=>({x:v, y:y[i]})), backgroundColor:'rgba(255,255,255,0.2)', pointRadius:2}] },
       options: { responsive:true, maintainAspectRatio:false, plugins:{title:{display:true, text:'Attractor (Long Run Equilibrium)', color:'#e8e8ea'}}, scales:{x:{grid:{display:false}}, y:{grid:{display:false}}} }
    });

    if(Lab.chartInstances[2]) Lab.chartInstances[2].destroy();
    Lab.chartInstances[2] = new Chart(document.getElementById("vecmECT").getContext('2d'), {
       type: 'line',
       data: { labels: Array.from({length:n},(_,i)=>i), datasets: [{label:'Error Correction Term (Stationary)', data:ectSeries, borderColor:'#ff4444', borderWidth:1, pointRadius:0}] },
       options: { responsive:true, maintainAspectRatio:false, plugins:{title:{display:true, text:'Error Correction Term (Residuals)', color:'#e8e8ea'}}, scales:{x:{display:false}, y:{grid:{display:false}}} }
    });

    document.getElementById("vecmStatus").innerHTML = `
       <span class="robustness-title">System Diagnostics</span>
       Estimated Cointegration Vector: [1, ${-est.beta.toFixed(3)}]. 
       Residual Stationarity: The ECT series should visually resemble white noise (stationary) despite X and Y being non-stationary.
    `;
    Lab.renderMath();
  },

  // --- ORNSTEIN-UHLENBECK LAB ---
  initOU: () => {
    Lab.state = { ...Lab.state, ouMean: 0, ouTheta: 0.5, ouSigma: 0.5, T: 200, dt: 0.05, ouStart: 0 };
    const controls = document.getElementById("labControls");
    const main = document.getElementById("labMain");
    
    controls.appendChild(Lab.generateButton("Simulate Path", Lab.updateOU));
    controls.appendChild(Lab.createControl("Long-Run Mean (μ)", "ouMean", -5, 5, 0.5, 0, "Equilibrium Level", v=>{Lab.state.ouMean=v; Lab.updateOU();}));
    controls.appendChild(Lab.createControl("Mean Reversion (θ)", "ouTheta", 0.01, 2, 0.05, 0.5, "Speed of Reversion", v=>{Lab.state.ouTheta=v; Lab.updateOU();}));
    controls.appendChild(Lab.createControl("Volatility (σ)", "ouSigma", 0.1, 2, 0.1, 0.5, "Noise Amplitude", v=>{Lab.state.ouSigma=v; Lab.updateOU();}));
    controls.appendChild(Lab.createControl("Start Value", "ouStart", -5, 5, 0.5, 2, "Initial condition X(0)", v=>{Lab.state.ouStart=v; Lab.updateOU();}));
    controls.appendChild(Lab.createControl("Time Step (dt)", "dt", 0.01, 0.5, 0.01, 0.05, "Discretization step", v=>{Lab.state.dt=v; Lab.updateOU();}));
    controls.appendChild(Lab.createControl("Steps (T)", "T", 100, 2000, 50, 400, "Duration", v=>{Lab.state.T=v; Lab.updateOU();}));

    main.innerHTML = `
      <div class="lab-spec-container" id="labSpecContainer"></div>
      <div class="lab-chart-box"><canvas id="ouChart"></canvas></div>
      <div class="lab-chart-box"><canvas id="ouHist"></canvas></div>
    `;
    Lab.updateOU();
  },

  updateOU: () => {
    const { ouMean, ouTheta, ouSigma, T, dt, ouStart } = Lab.state;
    let x = [ouStart]; 
    for(let i=1; i<T; i++){
       let dW = MathLab.generateRandom('normal', {mean:0, std:1}) * Math.sqrt(dt);
       let dx = ouTheta * (ouMean - x[i-1]) * dt + ouSigma * dW;
       x.push(x[i-1] + dx);
    }
    
    Lab.updateSpecPanel(
      `$$ dX_t = \\theta(\\mu - X_t)dt + \\sigma dW_t $$`,
      `$$ \\theta = ${ouTheta}, \\quad \\mu = ${ouMean}, \\quad \\sigma = ${ouSigma} $$`
    );
    
    if(Lab.chartInstances[0]) Lab.chartInstances[0].destroy();
    Lab.chartInstances[0] = new Chart(document.getElementById("ouChart").getContext('2d'), {
       type: 'line',
       data: { labels: Array.from({length:T},(_,i)=>i), datasets: [{ label: 'OU Process Path', data: x, borderColor: '#D4AF37', borderWidth:1.5, pointRadius:0 }] },
       options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Mean Reverting Process (Vasicek Model)', color:'#fff' } }, scales:{ x:{display:false}, y:{grid:{display:false}} } }
    });

    const bins = 30;
    const minX = Math.min(...x), maxX = Math.max(...x);
    const range = maxX - minX;
    const step = range/bins;
    let freq = new Array(bins).fill(0);
    x.forEach(v => {
        let bin = Math.floor((v - minX) / step);
        if(bin>=bins) bin=bins-1;
        freq[bin]++;
    });
    
    if(Lab.chartInstances[1]) Lab.chartInstances[1].destroy();
    Lab.chartInstances[1] = new Chart(document.getElementById("ouHist").getContext('2d'), {
       type: 'bar',
       data: { labels: freq.map((_,i)=>(minX+i*step).toFixed(1)), datasets: [{ label: 'Empirical Distribution', data: freq, backgroundColor: '#7aa6ff' }] },
       options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Stationary Distribution Density', color:'#fff' } }, scales:{ x:{grid:{display:false}}, y:{display:false} } }
    });
    
    Lab.renderMath();
  },

  // --- MCMC LAB ---
  initMCMC: () => {
    Lab.state = { ...Lab.state, mcmcIter: 2000, targetMean: 5, targetStd: 2, proposalStd: 1.0 };
    const controls = document.getElementById("labControls");
    const main = document.getElementById("labMain");
    
    controls.appendChild(Lab.generateButton("Run Sampler", Lab.updateMCMC));
    controls.appendChild(Lab.createControl("Target Mean", "targetMean", -10, 10, 1, 5, "True Posterior Mean", v=>{Lab.state.targetMean=v; Lab.updateMCMC();}));
    controls.appendChild(Lab.createControl("Target Std Dev", "targetStd", 0.5, 5, 0.5, 2, "True Posterior Width", v=>{Lab.state.targetStd=v; Lab.updateMCMC();}));
    controls.appendChild(Lab.createControl("Proposal Width", "proposalStd", 0.1, 5, 0.1, 1.0, "Step size of random walk", v=>{Lab.state.proposalStd=v; Lab.updateMCMC();}));
    controls.appendChild(Lab.createControl("Iterations", "mcmcIter", 500, 10000, 500, 2000, "Chain Length", v=>{Lab.state.mcmcIter=v; Lab.updateMCMC();}));
    
    main.innerHTML = `
       <div class="lab-spec-container" id="labSpecContainer"></div>
       <div class="lab-chart-box"><canvas id="mcmcTrace"></canvas></div>
       <div class="lab-chart-box"><canvas id="mcmcHist"></canvas></div>
    `;
    Lab.updateMCMC();
  },

  updateMCMC: () => {
     const { targetMean, targetStd, mcmcIter, proposalStd } = Lab.state;
     let chain = [0]; 
     let accepted = 0;
     const logLikelihood = (x) => -0.5 * Math.pow((x - targetMean)/targetStd, 2);
     
     for(let i=1; i<mcmcIter; i++){
         let current = chain[i-1];
         let proposal = current + MathLab.generateRandom('normal', {mean:0, std:proposalStd});
         let ratio = Math.exp(logLikelihood(proposal) - logLikelihood(current));
         if(Math.random() < ratio) { chain.push(proposal); accepted++; } else { chain.push(current); }
     }
     
     const acceptanceRate = (accepted / mcmcIter * 100).toFixed(1);
     Lab.updateSpecPanel(
        `$$ P(\\theta | D) \\propto e^{-\\frac{(\\theta - \\mu)^2}{2\\sigma^2}} $$`,
        `Metropolis-Hastings Sampler. Acc. Rate: ${acceptanceRate}%`
     );

     if(Lab.chartInstances[0]) Lab.chartInstances[0].destroy();
     Lab.chartInstances[0] = new Chart(document.getElementById("mcmcTrace").getContext('2d'), {
         type: 'line',
         data: { labels: Array.from({length:Math.min(1000, mcmcIter)},(_,i)=>i), datasets: [{ label: 'Trace Plot (Last 1000)', data: chain.slice(-1000), borderColor: '#44ff88', borderWidth:1, pointRadius:0 }] },
         options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'MCMC Trace (Mixing)', color:'#fff' } }, scales:{ x:{display:false}, y:{grid:{display:false}} } }
     });

     const bins = 40;
     const min = Math.min(...chain), max = Math.max(...chain);
     const step = (max-min)/bins;
     let freq = new Array(bins).fill(0);
     chain.forEach(v=>{ let b = Math.floor((v-min)/step); if(b>=bins) b=bins-1; freq[b]++; });
     
     if(Lab.chartInstances[1]) Lab.chartInstances[1].destroy();
     Lab.chartInstances[1] = new Chart(document.getElementById("mcmcHist").getContext('2d'), {
        type: 'bar',
        data: { labels: freq.map((_,i)=>(min+i*step).toFixed(1)), datasets: [{ label: 'Posterior Distribution', data: freq, backgroundColor: '#D4AF37' }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Estimated Posterior Density', color:'#fff' } }, scales:{ x:{grid:{display:false}}, y:{display:false} } }
     });
     
     Lab.renderMath();
  },

  initARDL: () => { Lab.initVAR(); } // Placeholder
};
window.Lab = Lab;
// ... (Rest of existing Three.js / Articles code remains exactly same)
const ARTICLES = [
  { id:"options-pricing", file:"articles/options.html", category:"Financial Econometrics", title:"Options Pricing", date:"JAN 2026", textureKey:"moon", enabled:true },
  { id:"bvar", file:"articles/bvar.html", category:"Core Theory", title:"Bayesian Vector Autoregression", date:"DEC 2025", textureKey:"earth", enabled:true },
  { id:"stoch-vol", file:"articles/forecasting.html", category:"Time Series", title:"Why ML is (almost) useless?", date:"JAN 2026", textureKey:"mars", enabled:true },
  { id:"game-theory-cb", file:"articles/game.html", category:"Monetary Economics", title:"Central Bank Credibility", date:"JAN 2026", textureKey:"jupiter", enabled:true },
  { id:"sign-rest", file:"articles/ERPT.html", category:"Macroeconometrics", title:"ERPT", date:"JAN 2026", textureKey:"venus", enabled:true },
  { id:"monte-carlo", file:"articles/monte-carlo.html", category:"Computational Methods", title:"Monte Carlo Simulation", date:"JAN 2026", textureKey:"mc", enabled:true }
].filter(x=>x.enabled);

const TEX = [
  String.raw`Y_t = A_1Y_{t-1}+\cdots+A_pY_{t-p}+u_t`, String.raw`u_t\sim\mathcal{N}(0,\Sigma)`,
  String.raw`p(\theta\mid Y)\propto p(Y\mid\theta)p(\theta)`, String.raw`E[y_t\mid\mathcal{I}_{t-1}]`,
  String.raw`h_t=\mu+\phi(h_{t-1}-\mu)+\sigma_h\xi_t`, String.raw`\nabla\mathcal{L}(\theta)`,
  String.raw`\Sigma = A^{-1}\Lambda A^{-1\prime}`
];

const $ = (id)=>document.getElementById(id);
function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
function showErr(e){
  const txt = $("errText");
  if(txt) txt.textContent = (e && (e.stack || e.message)) ? (e.stack || e.message) : String(e);
  const el = $("err");
  if(el) el.style.display = "block";
}
const root = document.documentElement;
const themeBtn = $("theme");
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const lerp = (a,b,t)=>a+(b-a)*t;

const LS_KEY = "theme";
function applyTheme(theme, persist){
  root.setAttribute("data-theme", theme);
  if (persist) localStorage.setItem(LS_KEY, theme);
  if (theme === "light"){
    root.style.setProperty("--bg", "#fbfbfc");
    root.style.setProperty("--panel", "rgba(255,255,255,0.82)");
    root.style.setProperty("--silver", "#1b1b1c");
    root.style.setProperty("--silver-dim", "rgba(27,27,28,0.72)");
    root.style.setProperty("--gold", "#B88A00");
    root.style.setProperty("--gold-soft", "#7A5A00");
    themeBtn.textContent = "Dark";
    $("depthName").style.color = "rgba(184,138,0,0.20)";
    $("depthName").style.textShadow = "0 0 55px rgba(184,138,0,0.14)";
  } else {
    root.removeAttribute("style");
    themeBtn.textContent = "Light";
    $("depthName").style.color = "rgba(212,175,55,0.24)";
    $("depthName").style.textShadow = "0 0 55px rgba(212,175,55,0.18)";
  }
  if (window.__RECOLOR__) window.__RECOLOR__();
}
function getInitialTheme(){
  const saved = localStorage.getItem(LS_KEY);
  return (saved === "light" || saved === "dark") ? saved : "dark";
}

const modal = $("modal");
let modalJustOpenedAt = 0;
function closeModal(){ modal.classList.remove("open"); const b = document.getElementById("modalBody"); if(b) b.scrollTop = 0; }
modal.addEventListener("click", (e)=>{ if (performance.now() - modalJustOpenedAt < 250) return; if (e.target === modal) closeModal(); });
window.addEventListener("keydown", (e)=>{ if (e.key==="Escape" && modal.classList.contains("open")) closeModal(); }, { passive:true });

function renderModal(a, content, isLoading, errorText){
  const html = `
    <div id="modalCard">
       <div id="modalTop"><div id="modalMeta"><strong>Reading</strong></div><button id="close">Close</button></div>
       <div id="modalBody"><div class="article-content">${content}</div></div>
    </div>`;
  modal.innerHTML = html;
  document.getElementById("close").onclick = closeModal;
}

async function openArticle(a){
  modalJustOpenedAt = performance.now();
  modal.classList.add("open");
  const html = `
    <header class="article-header">
       <div class="meta"><span class="pill">${a.category}</span><span>•</span><span>${a.date}</span></div>
       <h1>${a.title}</h1>
    </header>
    <div class="content"><p>Loading article content...</p></div>`;
  renderModal(a, html, false, "");
  
  try{
    const targetUrl = new URL(a.file, document.baseURI).href;
    let txt = cache.get(targetUrl);
    if (!txt){
       const res = await fetch(targetUrl);
       if(!res.ok) throw new Error("HTTP "+res.status);
       txt = await res.text();
       cache.set(targetUrl, txt);
    }
    const doc = new DOMParser().parseFromString(txt, "text/html");
    const c = doc.querySelector(".content") || doc.body;
    renderModal(a, c.innerHTML, false, "");
    if(window.renderMathInElement) window.renderMathInElement(modal);
  } catch(e){
    renderModal(a, `<p>Error loading article: ${e.message}</p>`, false, "");
  }
}

/* =========================
   3D PROCEDURAL VISUALS
   ========================= */
function fract(x){ return x - Math.floor(x); }
function hash2(x,y,s){ return fract(Math.sin(x*127.1 + y*311.7 + s*74.7) * 43758.5453123); }
function smoothstep(a,b,x){ const t = clamp((x-a)/(b-a), 0, 1); return t*t*(3-2*t); }
function noise2(u,v,s){
  const x = Math.floor(u), y = Math.floor(v);
  const fx = u - x, fy = v - y;
  const a = hash2(x,y,s), b = hash2(x+1,y,s), c = hash2(x,y+1,s), d = hash2(x+1,y+1,s);
  const ux = fx*fx*(3-2*fx), uy = fy*fy*(3-2*fy);
  return (a*(1-ux) + b*ux)*(1-uy) + (c*(1-ux) + d*ux)*uy;
}
function fbm2(u,v,s){
  let f=0, amp=0.5, freq=1.0;
  for(let i=0;i<5;i++){ f += amp * noise2(u*freq, v*freq, s + i*19.19); freq *= 2.02; amp *= 0.5; }
  return f;
}
function mix(a,b,t){ return a + (b-a)*t; }
function clamp01(x){ return clamp(x,0,1); }
function rgb(r,g,b){ return [r,g,b]; }
function to255(x){ return Math.round(clamp01(x)*255); }

function makeCanvasTexture(drawFn, size){
  const c = document.createElement("canvas"); c.width = c.height = size;
  const g = c.getContext("2d", { willReadFrequently:true }); drawFn(g, size);
  const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace;
  tex.anisotropy = 16; tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.needsUpdate = true;
  return tex;
}

function drawEarth(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  const deep = rgb(0.04,0.13,0.32), shallow = rgb(0.07,0.22,0.46), green = rgb(0.10,0.33,0.18), brown = rgb(0.32,0.28,0.14), sand  = rgb(0.52,0.46,0.25);
  for(let y=0;y<size;y++){
    const v = y/(size-1), lat = Math.abs(v-0.5)*2;
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const n1 = fbm2(u*6.0, v*6.0, 1.3), n2 = fbm2(u*14.0, v*14.0, 7.7);
      const continent = n1 + 0.35*n2 - 0.52 + 0.10*Math.sin((v-0.5)*Math.PI*2);
      const ice = smoothstep(0.72, 0.98, lat), land = smoothstep(-0.04, 0.05, continent);
      const seaVar = fbm2(u*18.0+3.0, v*18.0+9.0, 4.2);
      let oc = [mix(deep[0], shallow[0], seaVar), mix(deep[1], shallow[1], seaVar), mix(deep[2], shallow[2], seaVar)];
      const elev = fbm2(u*10.0+20.0, v*10.0+10.0, 2.6), dryness = fbm2(u*8.0+2.0, v*8.0+8.0, 9.1);
      let lc = [mix(green[0], brown[0], elev), mix(green[1], brown[1], elev), mix(green[2], brown[2], elev)];
      const des = smoothstep(0.58, 0.78, dryness) * (1.0 - ice);
      lc = [mix(lc[0], sand[0], des), mix(lc[1], sand[1], des), mix(lc[2], sand[2], des)];
      let c = [mix(oc[0], lc[0], land), mix(oc[1], lc[1], land), mix(oc[2], lc[2], land)];
      const cloudN = fbm2(u*26.0+31.0, v*26.0+17.0, 1.0), cloud = smoothstep(0.67, 0.82, cloudN) * (0.65 + 0.35*(1.0-land));
      c = [mix(c[0], 0.92, cloud*0.45), mix(c[1], 0.92, cloud*0.45), mix(c[2], 0.95, cloud*0.45)];
      c = [mix(c[0], 0.94, ice*0.85), mix(c[1], 0.94, ice*0.85), mix(c[2], 0.98, ice*0.85)];
      const i = (y*size + x)*4; d[i+0] = to255(c[0]); d[i+1] = to255(c[1]); d[i+2] = to255(c[2]); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function drawMoon(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const base = 0.55 + 0.18*(fbm2(u*8.0, v*8.0, 3.1)-0.5);
      const crater = smoothstep(0.55, 0.86, fbm2(u*22.0+4.0, v*22.0+9.0, 8.8));
      const ray = smoothstep(0.70, 0.92, fbm2(u*30.0+17.0, v*30.0+3.0, 1.7));
      let c = clamp01(base - crater*0.18 + ray*0.10);
      const i = (y*size + x)*4; d[i+0] = to255(c*0.98); d[i+1] = to255(c*0.99); d[i+2] = to255(c*1.02); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function drawMars(g, size){
  const img = g.createImageData(size,size); const d = img.data; const baseR = 0.62, baseG = 0.24, baseB = 0.10;
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const n = fbm2(u*10.0, v*10.0, 5.5), ridges = fbm2(u*20.0+3.0, v*20.0+11.0, 2.2);
      const dust = smoothstep(0.45, 0.78, n), dark = smoothstep(0.58, 0.86, ridges);
      let r = baseR + 0.18*dust - 0.16*dark, gg = baseG + 0.06*dust - 0.08*dark, b = baseB + 0.02*dust - 0.04*dark;
      const lat = Math.abs(v-0.5)*2, ice = smoothstep(0.82, 0.98, lat);
      r = mix(r, 0.92, ice*0.45); gg = mix(gg, 0.92, ice*0.45); b = mix(b, 0.96, ice*0.45);
      const i = (y*size + x)*4; d[i+0] = to255(r); d[i+1] = to255(gg); d[i+2] = to255(b); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function drawVenus(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const swirl = 0.5 + 0.5*Math.sin((u*10.0 + v*2.0)*Math.PI*2);
      const n = fbm2(u*14.0+swirl*3.0, v*14.0, 6.6), band = smoothstep(0.35, 0.75, n);
      let r = mix(0.82, 0.98, band), gg = mix(0.64, 0.86, band), b = mix(0.36, 0.62, band);
      const haze = smoothstep(0.60, 0.92, fbm2(u*26.0+7.0, v*26.0+19.0, 1.2));
      r = mix(r, 1.0, haze*0.18); gg = mix(gg, 1.0, haze*0.18); b = mix(b, 1.0, haze*0.18);
      const i = (y*size + x)*4; d[i+0] = to255(r); d[i+1] = to255(gg); d[i+2] = to255(b); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function drawMonteCarlo(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const n = fbm2(u*16.0, v*16.0, 10.1);
      const grid = (Math.abs(fract(u*24.0)-0.5)<0.01 || Math.abs(fract(v*24.0)-0.5)<0.01) ? 1.0 : 0.0;
      const speck = smoothstep(0.88, 0.98, fbm2(u*52.0+3.0, v*52.0+9.0, 21.7));
      let r = 0.08 + 0.12*n, gg = 0.10 + 0.14*n, b = 0.16 + 0.22*n;
      r = mix(r, 0.40, grid*0.10); gg = mix(gg, 0.55, grid*0.10); b = mix(b, 0.95, grid*0.10);
      r = mix(r, 0.95, speck*0.55); gg = mix(gg, 0.90, speck*0.55); b = mix(b, 0.98, speck*0.55);
      const i = (y*size + x)*4; d[i+0] = to255(r); d[i+1] = to255(gg); d[i+2] = to255(b); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function buildBaseTextures(){
  const SZ = 512;
  return { earth: makeCanvasTexture(drawEarth, SZ), moon: makeCanvasTexture(drawMoon, SZ), mars: makeCanvasTexture(drawMars, SZ), venus: makeCanvasTexture(drawVenus, SZ), mc: makeCanvasTexture(drawMonteCarlo, SZ) };
}

function buildEquationLayer(){
  const layer = $("eqLayer"); layer.innerHTML = "";
  const count = 16, items = [];
  for (let i=0;i<count;i++){
    const el = document.createElement("div"); el.className = "eq"; el.style.color = (root.getAttribute("data-theme")==="light")?"rgba(20,20,20,0.92)":"rgba(232,232,234,0.92)";
    const tex = TEX[i % TEX.length];
    try{ el.innerHTML = window.katex.renderToString(tex, { throwOnError:false, displayMode:false }); } catch(_){ el.textContent = tex; }
    items.push({ el, a: Math.random()*Math.PI*2, r: 0.18 + Math.random()*0.82, s: 0.08 + Math.random()*0.18, ph: Math.random()*10, ox: (Math.random()-0.5)*140, oy: (Math.random()-0.5)*140 });
    layer.appendChild(el);
  }
  return items;
}

if (!window.THREE){ showErr(new Error("Three.js unavailable.")); return; }
try{
  const canvas = $("gl");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false, powerPreference: "high-performance" });
  const DPR = ()=>Math.min(window.devicePixelRatio || 1, 2);
  renderer.setPixelRatio(DPR()); renderer.setSize(window.innerWidth, window.innerHeight, false);
  renderer.outputColorSpace = THREE.SRGBColorSpace; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.08;

  const scene = new THREE.Scene(); scene.background = new THREE.Color(cssVar("--bg") || "#050505");
  const camera = new THREE.PerspectiveCamera(52, window.innerWidth/window.innerHeight, 0.1, 5000); camera.position.set(0, 0, 220);

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const key = new THREE.DirectionalLight(0xffffff, 1.85); key.position.set(160, 190, 130); scene.add(key);
  const fill = new THREE.DirectionalLight(0xfff1cc, 0.72); fill.position.set(-210, 70, 160); scene.add(fill);
  const rim = new THREE.PointLight(0xd4af37, 1.35, 1200, 1.4); rim.position.set(0, 0, -320); scene.add(rim);

  const pointer = new THREE.Vector2(0,0); let px=0, py=0, pointerActive=false;
  const galaxy = new THREE.Group(); scene.add(galaxy);

  function buildStars(){
    const starCount = 38000, geom = new THREE.BufferGeometry(), pos = new Float32Array(starCount*3), col = new Float32Array(starCount*3), size = new Float32Array(starCount);
    const gold = new THREE.Color(cssVar("--gold") || "#D4AF37"), silv = new THREE.Color(cssVar("--silver") || "#e8e8ea"), blue = new THREE.Color("#7aa6ff"), arms = 4;
    for (let i=0;i<starCount;i++){
      const r = Math.pow(Math.random(), 0.42) * 900, arm = (i % arms) * (Math.PI*2/arms), theta = Math.random() * Math.PI*2;
      const twist = (r/900) * 6.6, a = theta + arm + twist, thickness = (1 - r/900), y = (Math.random()-0.5) * (22 + 160*(1-thickness)) * (0.32 + 0.68*Math.random());
      pos[i*3+0] = Math.cos(a)*r + (Math.random()-0.5)*14; pos[i*3+1] = y; pos[i*3+2] = Math.sin(a)*r + (Math.random()-0.5)*14;
      const t = clamp(0.16 + 0.84*(1 - r/900), 0, 1); const c = silv.clone().lerp(gold, t); if (Math.random() < 0.10) c.lerp(blue, 0.55);
      col[i*3+0]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b; size[i] = 0.6 + Math.random()*2.4; if (Math.random() < 0.02) size[i] *= 3.0;
    }
    geom.setAttribute("position", new THREE.BufferAttribute(pos,3)); geom.setAttribute("color", new THREE.BufferAttribute(col,3)); geom.setAttribute("aSize", new THREE.BufferAttribute(size,1));
    const mat = new THREE.ShaderMaterial({
      transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, uniforms: { uTime: { value: 0 }, uDpr: { value: DPR() } },
      vertexShader: `attribute float aSize; attribute vec3 color; varying vec3 vColor; uniform float uTime; uniform float uDpr; void main(){ vColor = color; vec3 p = position; float tw = sin(uTime*0.18 + p.x*0.01 + p.z*0.01) * 0.30; p.y += tw; vec4 mv = modelViewMatrix * vec4(p, 1.0); gl_Position = projectionMatrix * mv; float s = aSize * (300.0 / -mv.z); gl_PointSize = clamp(s * uDpr, 1.0, 10.0); }`,
      fragmentShader: `varying vec3 vColor; void main(){ vec2 uv = gl_PointCoord.xy - 0.5; float d = dot(uv, uv); float a = smoothstep(0.25, 0.0, d); float halo = smoothstep(0.48, 0.10, d) * 0.55; vec3 c = vColor * (1.2*a + 0.9*halo); gl_FragColor = vec4(c, (a + halo) * 0.85); }`
    });
    return new THREE.Points(geom, mat);
  }
  const stars = buildStars(); stars.rotation.x = -0.34; galaxy.add(stars);

  const nebula = new THREE.Mesh(
    new THREE.SphereGeometry(1900, 48, 48),
    new THREE.ShaderMaterial({
      side: THREE.BackSide,
      uniforms: { uTime: { value: 0 }, uPointer: { value: new THREE.Vector2(0,0) }, uGold: { value: new THREE.Color(cssVar("--gold") || "#D4AF37") }, uSilver: { value: new THREE.Color(cssVar("--silver") || "#e8e8ea") }, uBg: { value: new THREE.Color(cssVar("--bg") || "#050505") } },
      vertexShader: `varying vec3 vP; uniform float uTime; uniform vec2 uPointer; void main(){ vec3 p = position; float band = exp(-abs(p.y) / 240.0); float swirl = sin(uTime*0.08 + p.x*0.002 + p.z*0.002) * 22.0 * band; p.x += swirl; p.z -= swirl * 0.55; p.x += uPointer.x * 40.0 * band; p.y += uPointer.y * 18.0 * band; vP = p; gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0); }`,
      fragmentShader: `varying vec3 vP; uniform float uTime; uniform vec3 uGold; uniform vec3 uSilver; uniform vec3 uBg; float noise(vec3 p){ vec3 i = floor(p); vec3 f = fract(p); f = f*f*(3.0-2.0*f); float n000 = fract(sin(dot(i, vec3(1.0,57.0,113.0))) * 43758.5453); float n100 = fract(sin(dot(i+vec3(1,0,0), vec3(1.0,57.0,113.0))) * 43758.5453); float n010 = fract(sin(dot(i+vec3(0,1,0), vec3(1.0,57.0,113.0))) * 43758.5453); float n110 = fract(sin(dot(i+vec3(1,1,0), vec3(1.0,57.0,113.0))) * 43758.5453); float n001 = fract(sin(dot(i+vec3(0,0,1), vec3(1.0,57.0,113.0))) * 43758.5453); float n101 = fract(sin(dot(i+vec3(1,0,1), vec3(1.0,57.0,113.0))) * 43758.5453); float n011 = fract(sin(dot(i+vec3(0,1,1), vec3(1.0,57.0,113.0))) * 43758.5453); float n111 = fract(sin(dot(i+vec3(1,1,1), vec3(1.0,57.0,113.0))) * 43758.5453); float n00 = mix(n000, n100, f.x); float n10 = mix(n010, n110, f.x); float n01 = mix(n001, n101, f.x); float n11 = mix(n011, n111, f.x); float n0 = mix(n00, n10, f.y); float n1 = mix(n01, n11, f.y); return mix(n0, n1, f.z); } float fbm(vec3 p){ float v = 0.0; float a = 0.5; for(int i=0;i<5;i++){ v += a * noise(p); p *= 2.02; a *= 0.5; } return v; } void main(){ float band = exp(-abs(vP.y) / 170.0); vec3 q = vP * 0.0018 + vec3(0.0, 0.0, uTime*0.015); float n = fbm(q*3.0); float m = fbm(q*6.0 + 12.3); float cloud = smoothstep(0.35, 0.92, n) * band; float dust = smoothstep(0.25, 0.85, m) * band; float grad = clamp(0.5 + 0.5*sin(vP.x*0.002 + uTime*0.06), 0.0, 1.0); vec3 mixc = mix(uSilver, uGold, grad); vec3 c = uBg; c += mixc * (0.18*cloud + 0.12*dust); c += uGold * (0.06 * band); c = clamp(c, 0.0, 1.0); gl_FragColor = vec4(c, 1.0); }`
    })
  );
  scene.add(nebula);

  const planets = new THREE.Group(); scene.add(planets);
  const ringGroup = new THREE.Group(); planets.add(ringGroup);
  const ringTiltX = 0.38, ringTiltZ = -0.12; ringGroup.rotation.x = ringTiltX; ringGroup.rotation.z = ringTiltZ;
  const raycaster = new THREE.Raycaster(); let hovered = null;

  function labelSprite(text){
    const w=1200, h=380, c=document.createElement("canvas"); c.width=w; c.height=h; const g=c.getContext("2d");
    const bg = g.createLinearGradient(0,0,w,h); bg.addColorStop(0,"rgba(232,232,234,0.16)"); bg.addColorStop(0.55,"rgba(212,175,55,0.12)"); bg.addColorStop(1,"rgba(232,232,234,0.08)");
    const r=52; g.beginPath(); g.moveTo(r,0); g.lineTo(w-r,0); g.quadraticCurveTo(w,0,w,r); g.lineTo(w,h-r); g.quadraticCurveTo(w,h,w-r,h); g.lineTo(r,h); g.quadraticCurveTo(0,h,0,h-r); g.lineTo(0,r); g.quadraticCurveTo(0,0,r,0); g.closePath(); g.fillStyle = bg; g.fill(); g.strokeStyle = "rgba(255,255,255,0.18)"; g.lineWidth = 2; g.stroke();
    g.shadowColor = "rgba(212,175,55,0.26)"; g.shadowBlur = 14;
    g.fillStyle = "rgba(255,255,255,0.94)"; g.textAlign = "center"; g.textBaseline = "middle"; g.font = "800 90px 'Latin Modern Sans','Latin Modern Roman',system-ui,sans-serif";
    const pad=48, maxW=w-pad*2, words=String(text).split(/\s+/).filter(Boolean);
    let line="", lines=[]; for(let i=0;i<words.length;i++){ const test=line? (line+" "+words[i]) : words[i]; if(g.measureText(test).width<=maxW) line=test; else{ lines.push(line); line=words[i]; } } if(line) lines.push(line);
    const lineH=104, y0=h/2 - ((lines.length-1)*lineH)/2; for(let i=0;i<lines.length;i++) g.fillText(lines[i], w/2, y0+i*lineH);
    const tex=new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; tex.anisotropy = 8;
    const spr=new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false })); spr.scale.set(100, 36, 1); spr.userData._labelText = text; return spr;
  }

  const baseTextures = buildBaseTextures();
  const planetMaterial = (art) => {
    let map = baseTextures.earth; if(art.textureKey==="moon") map=baseTextures.moon; else if(art.textureKey==="mars") map=baseTextures.mars; else if(art.textureKey==="venus") map=baseTextures.venus; else if(art.textureKey==="mc") map=baseTextures.mc;
    return new THREE.MeshStandardMaterial({ map, roughness:0.75, metalness:0.15 });
  };
  const atmosphereMaterial = (color, opacity) => new THREE.ShaderMaterial({
    transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, uniforms:{ uColor:{ value:new THREE.Color(color) }, uOpacity:{ value:opacity } },
    vertexShader: `varying vec3 vNormal; void main(){ vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
    fragmentShader: `varying vec3 vNormal; uniform vec3 uColor; uniform float uOpacity; void main(){ float i = pow(0.65 - dot(vNormal, vec3(0,0,1)), 2.8); gl_FragColor = vec4(uColor, i*uOpacity); }`
  });

  const entries = [];
  function buildSaturnRings(innerR, outerR){
    ringGroup.clear(); const gold = new THREE.Color(cssVar("--gold") || "#D4AF37"), silv = new THREE.Color(cssVar("--silver") || "#e8e8ea");
    const makeRing = (r0, r1, opacity, z, tintMix)=>{
      const geo = new THREE.RingGeometry(r0, r1, 192, 1);
      const mat = new THREE.ShaderMaterial({
        transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
        uniforms:{ uTime:{ value:0 }, uGold:{ value: gold.clone() }, uSilv:{ value: silv.clone() }, uOpacity:{ value: opacity }, uTint:{ value: tintMix } },
        vertexShader: `varying vec2 vUv; varying vec3 vPos; void main(){ vUv = uv; vec4 wp = modelMatrix * vec4(position,1.0); vPos = wp.xyz; gl_Position = projectionMatrix * viewMatrix * wp; }`,
        fragmentShader: `varying vec2 vUv; varying vec3 vPos; uniform float uTime; uniform vec3 uGold; uniform vec3 uSilv; uniform float uOpacity; uniform float uTint; float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); } float noise(vec2 p){ vec2 i = floor(p); vec2 f = fract(p); f = f*f*(3.0-2.0*f); float a = hash(i); float b = hash(i+vec2(1.0,0.0)); float c = hash(i+vec2(0.0,1.0)); float d = hash(i+vec2(1.0,1.0)); return mix(mix(a,b,f.x), mix(c,d,f.x), f.y); } void main(){ float r = length(vUv - 0.5) * 2.0; float g = noise((vUv-0.5)*vec2(180.0, 28.0) + uTime*0.02); float streak = noise((vUv-0.5)*vec2(420.0, 44.0) - uTime*0.01); float a = (0.55 + 0.45*g) * (0.55 + 0.45*streak); float edge = smoothstep(0.98, 0.65, r) * smoothstep(0.02, 0.18, r); a *= edge; vec3 c = mix(uSilv, uGold, uTint + 0.15*sin(vUv.x*20.0)); gl_FragColor = vec4(c, a * uOpacity); }`
      });
      const m = new THREE.Mesh(geo, mat); m.position.z = z; ringGroup.add(m); return m;
    };
    const rings = []; rings.push(makeRing(innerR, outerR, 0.22, 0.0, 0.55)); rings.push(makeRing(innerR*1.02, outerR*0.985, 0.16, 0.06, 0.35)); rings.push(makeRing(innerR*1.06, outerR*0.96, 0.12, -0.06, 0.70)); return rings;
  }

  function wrapAngle(a){ const two = Math.PI*2; a = a % two; return a < 0 ? a + two : a; }
  function angleDist(a,b){ const two = Math.PI*2; let d = Math.abs(a-b) % two; return d > Math.PI ? two - d : d; }
  function enforceAngularSeparation(){
    const n = entries.length; if (n <= 1) return; const minGapBase = 0.64;
    for (let it=0; it<22; it++){
      let moved = 0; const idx = entries.map((p)=>p).sort((a,b)=>a.angle - b.angle);
      for (let k=0;k<n;k++){ const A = idx[k], B = idx[(k+1)%n], gapNeed = minGapBase + 0.010*(A.radius + B.radius), d = angleDist(A.angle, B.angle); if (d < gapNeed){ const push = (gapNeed - d) * 0.5; A.angle = wrapAngle(A.angle - push); B.angle = wrapAngle(B.angle + push); moved++; } } if (!moved) break;
    }
  }
  function applyOrbitPosition(p){
    const r = p.ringR * (1.0 + p.rMod), x = Math.cos(p.angle) * r, y = Math.sin(p.angle) * r, z = p.zMod;
    const pos = new THREE.Vector3(x,y,0); pos.applyEuler(new THREE.Euler(ringTiltX, 0, ringTiltZ, "XYZ")); pos.z += z;
    p.mesh.position.copy(pos); p.atmo.position.copy(pos); p.label.position.copy(pos);
    const offset = (p.radius + 42 * p.scale * p.labelScaleMult), up = new THREE.Vector3(0,1,0).applyEuler(new THREE.Euler(ringTiltX, 0, ringTiltZ, "XYZ")), sign = (y >= 0) ? 1 : -1;
    p.label.position.addScaledVector(up, offset * sign * 0.6); // Slightly closer labels
    p.label.quaternion.copy(camera.quaternion);
  }
  function disposeObject(obj){ obj.traverse((o)=>{ if (o.geometry) o.geometry.dispose(); if (o.material){ if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose && m.dispose()); else o.material.dispose && o.material.dispose(); } if (o.material && o.material.map) o.material.map.dispose && o.material.map.dispose(); }); }
  function rebuildLabelTextures(){
    for (const p of entries){ const spr = p.label; if (!spr || !spr.userData || !spr.userData._labelText) continue; const newSpr = labelSprite(spr.userData._labelText); newSpr.scale.copy(spr.scale); newSpr.position.copy(spr.position); newSpr.quaternion.copy(spr.quaternion); newSpr.userData.article = spr.userData.article; planets.remove(spr); planets.add(newSpr); p.label = newSpr; }
  }

  let ringMeshes = [];
  function buildPlanets(){
    for (let i = planets.children.length - 1; i >= 0; i--) { const ch = planets.children[i]; if (ch !== ringGroup) { planets.remove(ch); try{ disposeObject(ch); }catch(_){} } }
    entries.length = 0;
    let w = window.innerWidth, h = window.innerHeight; if (!w || !h) { w = 1024; h = 768; } const isMobile = w < 800, aspect = w / h, dist = 220, vH = 2 * dist * Math.tan((52 * Math.PI / 180) / 2), vW = vH * aspect;
    let scale = Math.min(vW / 560, vH / 560); if (!Number.isFinite(scale)) scale = 1.0;
    const finalScale = Math.max(scale, 0.22), ringR = 142 * finalScale, ringInner = ringR * 0.78, ringOuter = ringR * 1.12;
    ringMeshes = buildSaturnRings(ringInner, ringOuter);
    const planetBaseRadius = isMobile ? 50 : 25, labelScaleMult = isMobile ? 2.05 : 1.0;
    const n = ARTICLES.length;
    for (let i=0;i<n;i++){
      const art = ARTICLES[i], radius = planetBaseRadius * finalScale;
      const mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 64, 64), planetMaterial(art)); mesh.userData.article = art; mesh.userData.radius = radius;
      let atColor = "#90b0ff"; if(art.textureKey==="earth") atColor = "#0066ff"; else if(art.textureKey==="mars") atColor = "#ff4400"; else if(art.textureKey==="venus") atColor = "#ffd080"; else if(art.textureKey==="mc") atColor = "#a7b7ff"; else atColor = "#cfd3ff";
      const atmo = new THREE.Mesh(new THREE.SphereGeometry(radius*1.06, 64, 64), atmosphereMaterial(atColor, 0.45)); atmo.userData.article = art;
      const label = labelSprite(art.title); label.scale.multiplyScalar(finalScale * labelScaleMult); label.userData.article = art;
      const baseAngle = (i / n) * Math.PI*2 + Math.PI/5;
      entries.push({ mesh, atmo, label, radius, angle: baseAngle, angVel: 0, rMod: 0, zMod: 0, ringR, hoverPull: 0, scale: finalScale, labelScaleMult });
      planets.add(mesh); planets.add(atmo); planets.add(label);
    }
    enforceAngularSeparation(); for (const p of entries) applyOrbitPosition(p);
  }
  buildPlanets();
  if (document.fonts && document.fonts.ready) { document.fonts.ready.then(()=>rebuildLabelTextures()).catch(()=>{}); }

  function getClientXY(ev){ if (ev && ev.changedTouches && ev.changedTouches.length) return { x: ev.changedTouches[0].clientX, y: ev.changedTouches[0].clientY }; if (ev && ev.touches && ev.touches.length) return { x: ev.touches[0].clientX, y: ev.touches[0].clientY }; return { x: ev.clientX, y: ev.clientY }; }
  function setPointerFromEvent(ev){ const r = canvas.getBoundingClientRect(); const p = getClientXY(ev); const x = (p.x - r.left) / Math.max(1, r.width); const y = (p.y - r.top) / Math.max(1, r.height); pointer.x = x * 2 - 1; pointer.y = -(y * 2 - 1); px = clamp(p.x - r.left, 0, r.width); py = clamp(p.y - r.top, 0, r.height); pointerActive = true; }
  let lastTapAt = 0, tapStart = null;
  function tryPick(ev){ if (modal.classList.contains("open")) return; setPointerFromEvent(ev); raycaster.setFromCamera(pointer, camera); const hits = raycaster.intersectObjects(planets.children, true).filter(h => h.object && h.object.userData && h.object.userData.article); if (hits.length > 0){ openArticle(hits[0].object.userData.article); } }
  function onTapStart(ev){ if (modal.classList.contains("open")) return; const p = getClientXY(ev); tapStart = { x: p.x, y: p.y, t: performance.now() }; setPointerFromEvent(ev); if (ev.cancelable) ev.preventDefault(); }
  function onTapEnd(ev){ if (!tapStart) { tryPick(ev); return; } const p = getClientXY(ev); const dt = performance.now() - tapStart.t; const dx = Math.abs(p.x - tapStart.x); const dy = Math.abs(p.y - tapStart.y); tapStart = null; if (dt < 450 && dx < 14 && dy < 14){ const now = performance.now(); if (now - lastTapAt < 220) return; lastTapAt = now; tryPick(ev); } if (ev.cancelable) ev.preventDefault(); }
  function onPointerMove(e){ setPointerFromEvent(e); }
  canvas.addEventListener("pointermove", onPointerMove, { passive:true }); canvas.addEventListener("pointerdown", onTapStart, { passive:false }); canvas.addEventListener("pointerup", onTapEnd, { passive:false }); canvas.addEventListener("touchstart", onTapStart, { passive:false }); canvas.addEventListener("touchend", onTapEnd, { passive:false }); canvas.addEventListener("touchcancel", ()=>{ tapStart = null; }, { passive:true }); canvas.addEventListener("click", (e)=>{ tryPick(e); }, { passive:true });

  const clock = new THREE.Clock(); let eqItems = buildEquationLayer(); const starAnim = { time: 0, rotY: 0, rotZ: 0 };
  window.__RECOLOR__ = function(){ nebula.material.uniforms.uGold.value.set(cssVar("--gold") || "#D4AF37"); nebula.material.uniforms.uSilver.value.set(cssVar("--silver") || "#e8e8ea"); nebula.material.uniforms.uBg.value.set(cssVar("--bg") || "#050505"); scene.background.set(cssVar("--bg") || "#050505"); if (ringMeshes && ringMeshes.length){ const gold = new THREE.Color(cssVar("--gold") || "#D4AF37"), silv = new THREE.Color(cssVar("--silver") || "#e8e8ea"); ringMeshes.forEach(m=>{ if (m.material && m.material.uniforms){ m.material.uniforms.uGold.value.copy(gold); m.material.uniforms.uSilv.value.copy(silv); } }); } };
  const _targetScale = new THREE.Vector3();

  function tick(){
    const dt = Math.min(0.033, clock.getDelta()), t = clock.getElapsedTime();
    const rect = canvas.getBoundingClientRect(); const nx = pointerActive ? (px / Math.max(1, rect.width) - 0.5) : 0.0, ny = pointerActive ? (py / Math.max(1, rect.height) - 0.5) : 0.0;
    camera.position.x = lerp(camera.position.x, nx * 26, 0.06); camera.position.y = lerp(camera.position.y, (-ny) * 12, 0.06); camera.lookAt(0,0,0);
    nebula.material.uniforms.uTime.value = t; nebula.material.uniforms.uPointer.value.set(nx, -ny);
    if (pointerActive && !modal.classList.contains("open")){ raycaster.setFromCamera(pointer, camera); const hits = raycaster.intersectObjects(planets.children, true); const hit = hits.find(h => h.object && h.object.userData && h.object.userData.article); const newHover = hit ? hit.object : null; if (hovered !== newHover){ hovered = newHover; document.body.style.cursor = hovered ? "pointer" : "default"; } } else { if (hovered !== null){ hovered = null; document.body.style.cursor = "default"; } }
    const isHoveringPlanet = !!(hovered && hovered.userData && hovered.userData.article);
    if (!isHoveringPlanet){ starAnim.time += dt; starAnim.rotY += dt * 0.05; starAnim.rotZ = Math.cos(starAnim.time*0.04)*0.06; }
    stars.material.uniforms.uTime.value = starAnim.time; stars.material.uniforms.uDpr.value = DPR(); galaxy.rotation.y = starAnim.rotY; galaxy.rotation.z = starAnim.rotZ;
    if (ringMeshes && ringMeshes.length){ ringMeshes.forEach(m=>{ if (m.material && m.material.uniforms) m.material.uniforms.uTime.value = t; }); ringGroup.rotation.y = Math.sin(t*0.05)*0.06; }
    const n = entries.length;
    for (let i=0;i<n;i++){
      const p = entries[i], m = p.mesh; m.rotation.y += dt * (0.65 + i*0.03); m.rotation.x += dt * 0.008;
      const isHover = isHoveringPlanet && (hovered.userData.article === m.userData.article);
      p.hoverPull = lerp(p.hoverPull, isHover ? 1 : 0, 0.12);
      const baseSpin = 0.012, steer = pointerActive ? (nx * 0.015) : 0.0, hoverSteer = p.hoverPull * (nx*0.20) * 0.02;
      p.angVel = lerp(p.angVel, baseSpin + steer + hoverSteer, 0.05);
      const wob = Math.sin(t*0.7 + i*1.7) * 0.0009; p.angle = wrapAngle(p.angle + (p.angVel + wob) * dt);
      const rTarget = isHover ? 0.030 : 0.0; p.rMod = lerp(p.rMod, rTarget, 0.09);
      const zTarget = isHover ? 24.0 : 0.0; p.zMod = lerp(p.zMod, zTarget, 0.10);
    }
    for (let it=0; it<2; it++) enforceAngularSeparation();
    for (let i=0;i<n;i++){ const p = entries[i]; const isHover = isHoveringPlanet && (hovered.userData.article === p.mesh.userData.article); applyOrbitPosition(p); const s = isHover ? 1.10 : 1.0; _targetScale.set(s, s, s); p.mesh.scale.lerp(_targetScale, 0.10); _targetScale.set(s*1.02, s*1.02, s*1.02); p.atmo.scale.lerp(_targetScale, 0.10); }
    $("depthName").style.transform = "translate(-50%, -50%)";
    const w = window.innerWidth, h = window.innerHeight;
    for (let i=0;i<eqItems.length;i++){ const it = eqItems[i]; it.a += dt * it.s; const rr = (0.18 + it.r*0.82), x = (0.5 + 0.46*Math.cos(it.a) * rr) * w + it.ox, y = (0.5 + 0.36*Math.sin(it.a*0.92 + it.ph) * rr) * h + it.oy, op = 0.18 + 0.12*(0.5+0.5*Math.sin(t*0.35 + i)); it.el.style.opacity = String(op); it.el.style.transform = `translate3d(${x}px, ${y}px, 0) rotate(${Math.sin(it.a)*2.0}deg)`; }
    renderer.render(scene, camera); requestAnimationFrame(tick);
  }

  function onResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setPixelRatio(DPR()); renderer.setSize(window.innerWidth, window.innerHeight, false); buildPlanets(); eqItems = buildEquationLayer(); if (document.fonts && document.fonts.ready) document.fonts.ready.then(()=>rebuildLabelTextures()).catch(()=>{}); }
  window.addEventListener("resize", onResize, { passive:true });
  const brand = $("brand"); brand.addEventListener("click", ()=>camera.position.set(0,0,220)); brand.addEventListener("keydown", (e)=>{ if (e.key==="Enter"||e.key===" "){ e.preventDefault(); camera.position.set(0,0,220); } });
  themeBtn.addEventListener("click", ()=>{ const cur = root.getAttribute("data-theme") || "dark"; applyTheme(cur === "dark" ? "light" : "dark", true); });
  applyTheme(getInitialTheme(), false); tick();

}catch(e){ showErr(e); }
})();
</script>
</body>
</html>
