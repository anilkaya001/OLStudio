<!doctype html>
<html lang="en" data-theme="dark">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>
<meta name="theme-color" content="#050505"/>
<title>Anıl Kaya</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin/>
<link rel="preconnect" href="https://unpkg.com" crossorigin/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sugina-dev/latin-modern-web@1.0.1/style/latinmodern-roman.css"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sugina-dev/latin-modern-web@1.0.1/style/latinmodern-sans.css"/>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<style>
:root{color-scheme:dark;--font-main:"Latin Modern Roman","Times New Roman",Times,serif;--font-ui:"Latin Modern Sans","Latin Modern Roman",serif;--safe-top:env(safe-area-inset-top,0px);--safe-bottom:env(safe-area-inset-bottom,0px);--nav-h:64px;--bg:#050505;--panel:rgba(18,18,18,0.62);--panel-strong:rgba(10,10,10,0.86);--border:rgba(255,255,255,0.10);--silver:#e8e8ea;--silver-dim:rgba(232,232,234,0.72);--gold:#D4AF37;--gold-soft:#F7E7CE}html,body{height:100%}body{margin:0;background:var(--bg);color:var(--silver);font-family:var(--font-main);overflow:hidden;overscroll-behavior:none;-webkit-font-smoothing:antialiased;-webkit-user-select:none;user-select:none;touch-action:none}*{box-sizing:border-box}a{color:var(--gold-soft);text-decoration:none}a:hover{opacity:0.9}:focus-visible{outline:2px solid color-mix(in oklab,var(--gold) 65%,#fff);outline-offset:3px;border-radius:14px}#nav{position:fixed;top:0;left:0;right:0;height:calc(var(--nav-h) + var(--safe-top));padding-top:var(--safe-top);padding-left:clamp(14px,4vw,44px);padding-right:clamp(14px,4vw,44px);display:flex;align-items:center;justify-content:space-between;z-index:1000;border-bottom:1px solid var(--border);background:radial-gradient(1200px 600px at 20% 30%,rgba(212,175,55,0.11),rgba(0,0,0,0.0) 60%),linear-gradient(135deg,rgba(10,10,10,0.80),rgba(18,18,18,0.58));backdrop-filter:blur(18px)}#brand{font-family:var(--font-ui);font-size:0.92rem;font-weight:900;letter-spacing:2px;text-transform:uppercase;color:color-mix(in oklab,var(--gold) 70%,var(--silver));user-select:none;white-space:nowrap;cursor:pointer;-webkit-user-select:none}#actions{display:flex;align-items:center;gap:10px}.btn{font-family:var(--font-ui);font-size:0.82rem;letter-spacing:1.2px;text-transform:uppercase;padding:10px 12px;border-radius:14px;border:1px solid rgba(212,175,55,0.25);background:linear-gradient(135deg,rgba(18,18,18,0.58),rgba(18,18,18,0.34));color:var(--silver);cursor:pointer;backdrop-filter:blur(14px);transition:all 0.3s ease;-webkit-user-select:none;user-select:none;touch-action:manipulation}.btn:hover{background:rgba(212,175,55,0.15);border-color:rgba(212,175,55,0.5)}#gl{position:fixed;inset:0;width:100%;height:100%;display:block;z-index:1;touch-action:none;-webkit-touch-callout:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}#eqLayer{position:fixed;inset:0;z-index:700;pointer-events:none;overflow:hidden}.eq{position:absolute;will-change:transform,opacity,filter;opacity:0.0;transform:translate3d(0,0,0);filter:drop-shadow(0 0 14px rgba(212,175,55,0.24));color:rgba(232,232,234,0.92);mix-blend-mode:screen}.eq .katex{font-size:clamp(18px,2.1vw,28px)}#depthName{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:650;pointer-events:none;font-family:var(--font-main);font-weight:300;letter-spacing:0.08em;font-size:clamp(3.0rem,9.0vw,7.6rem);color:rgba(212,175,55,0.24);text-shadow:0 0 55px rgba(212,175,55,0.18);filter:blur(0.2px);opacity:0.95;white-space:nowrap}#depthName::after{content:"";position:absolute;inset:-30px -80px;background:radial-gradient(closest-side,rgba(232,232,234,0.10),rgba(0,0,0,0.0) 70%);z-index:-1;filter:blur(10px);opacity:0.55}#orbitHint{position:fixed;inset:0;z-index:600;pointer-events:none;opacity:0.55;background:radial-gradient(circle at 50% 50%,rgba(212,175,55,0.10) 0%,rgba(212,175,55,0.06) 20%,rgba(232,232,234,0.04) 34%,rgba(0,0,0,0.0) 60%),conic-gradient(from 220deg at 50% 50%,rgba(212,175,55,0.12),rgba(122,166,255,0.06),rgba(232,232,234,0.08),rgba(212,175,55,0.12));mask:radial-gradient(circle at 50% 50%,rgba(0,0,0,0) 0 26%,rgba(0,0,0,1) 34% 42%,rgba(0,0,0,0) 60%);filter:blur(0.6px)}#modal{position:fixed;inset:0;z-index:2000;display:none;background:rgba(0,0,0,0.56);backdrop-filter:blur(10px);touch-action:manipulation}#modal.open{display:block}#modalCard{position:absolute;left:50%;top:calc(var(--nav-h) + var(--safe-top) + 18px);transform:translateX(-50%);width:min(1120px,calc(100vw - 28px));height:min(calc(100dvh - (var(--nav-h) + var(--safe-top) + var(--safe-bottom) + 36px)),920px);border-radius:22px;border:1px solid rgba(212,175,55,0.24);background:radial-gradient(900px 650px at 22% 22%,rgba(232,232,234,0.10),rgba(212,175,55,0.08) 40%,rgba(0,0,0,0.0) 70%),linear-gradient(135deg,rgba(10,10,10,0.84),rgba(18,18,18,0.56));box-shadow:0 26px 90px -46px rgba(0,0,0,0.92);overflow:hidden;display:grid;grid-template-rows:auto 1fr}#modalTop{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,0.10);background:linear-gradient(135deg,rgba(10,10,10,0.72),rgba(18,18,18,0.40))}#modalMeta{font-family:var(--font-ui);color:var(--silver-dim);letter-spacing:1.2px;text-transform:uppercase;font-size:0.76rem;display:flex;gap:10px;flex-wrap:wrap;align-items:center}#modalMeta strong{color:var(--gold);font-weight:900}#close{border-radius:14px;border:1px solid rgba(255,255,255,0.10);background:rgba(18,18,18,0.46);color:var(--silver);font-family:var(--font-ui);letter-spacing:1.2px;text-transform:uppercase;font-size:0.78rem;padding:10px 12px;cursor:pointer;transition:background 0.2s;touch-action:manipulation}#close:hover{background:rgba(255,255,255,0.15)}#modalBody{overflow:auto;-webkit-overflow-scrolling:touch;padding:18px clamp(14px,3vw,28px) 28px;-webkit-user-select:text;user-select:text;touch-action:pan-y}#modalBody article{max-width:820px;margin:0 auto;line-height:1.75;font-size:1.14rem;color:color-mix(in oklab,var(--silver) 88%,var(--silver-dim))}#modalBody h1,#modalBody h2,#modalBody h3{color:color-mix(in oklab,var(--gold-soft) 70%,var(--silver));line-height:1.15;margin:1.2rem 0 0.6rem}#modalBody h1{font-size:clamp(1.8rem,3.6vw,2.8rem);margin-top:0}#modalBody h2{font-size:clamp(1.35rem,2.8vw,1.9rem)}#modalBody h3{font-size:1.2rem;font-style:italic}#modalBody p{margin:0 0 1.25rem}.article-header .meta{display:flex;gap:10px;align-items:center;flex-wrap:wrap;font-family:var(--font-ui);font-size:0.80rem;letter-spacing:1.1px;text-transform:uppercase;color:var(--silver-dim);margin-bottom:10px}.article-header .pill{border:1px solid rgba(212,175,55,0.22);background:rgba(212,175,55,0.10);color:color-mix(in oklab,var(--gold) 75%,var(--silver));padding:6px 10px;border-radius:999px;font-weight:800;font-family:var(--font-ui)}#err{position:fixed;inset:0;z-index:9999;display:none;padding:96px 18px 18px;background:#050505;color:#e8e8ea;font-family:var(--font-ui);-webkit-user-select:text;user-select:text;touch-action:pan-y}#err h2{margin:0 0 12px;font-weight:900;letter-spacing:1px;color:#D4AF37;text-transform:uppercase}#err pre{margin:12px 0 0;padding:12px;border-radius:14px;border:1px solid rgba(255,255,255,0.10);background:rgba(18,18,18,0.6);overflow:auto;max-height:55vh;white-space:pre-wrap;line-height:1.5;opacity:0.9}
</style>
</head>
<body>
<nav id="nav" aria-label="Primary">
<div id="brand" role="button" tabindex="0">Anıl Kaya</div>
<div id="actions">
<a class="btn" href="https://www.linkedin.com/in/anillkaya" target="_blank" rel="noopener noreferrer">LinkedIn</a>
<button class="btn" id="theme" type="button" aria-label="Toggle theme">Light</button>
</div>
</nav>
<canvas id="gl" aria-hidden="true"></canvas>
<div id="orbitHint" aria-hidden="true"></div>
<div id="depthName" aria-hidden="true">Anıl Kaya</div>
<div id="eqLayer" aria-hidden="true"></div>
<div id="modal" role="dialog" aria-modal="true" aria-label="Article reader">
<div id="react-app"></div>
</div>
<div id="err"><h2>Render error</h2><div>Error details:</div><pre id="errText"></pre></div>
<script>
(function(){
"use strict";
const ArticleHeader = ({ title, category, date }) => {
return React.createElement('header', { className: 'article-header' },
React.createElement('div', { className: 'meta' },
React.createElement('span', { className: 'pill' }, category),
React.createElement('span', {}, "•"),
React.createElement('span', {}, date)
),
React.createElement('h1', {}, title)
);
};
const ArticleBody = ({ content }) => {
const containerRef = React.useRef(null);
React.useEffect(() => {
if (containerRef.current && window.renderMathInElement) {
window.renderMathInElement(containerRef.current, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError: false
});
}
}, [content]);
return React.createElement('div', {
className: 'content',
ref: containerRef,
dangerouslySetInnerHTML: { __html: content }
});
};
const ArticleModal = ({ article, content, onClose, isLoading, errorText }) => {
React.useEffect(() => {
if(window.gsap) window.gsap.from("#modalCard", { y: 40, opacity: 0, duration: 0.4, ease: "power3.out", clearProps: "all" });
}, []);
return React.createElement('div', { id: 'modalCard' },
React.createElement('div', { id: 'modalTop' },
React.createElement('div', { id: 'modalMeta' },
React.createElement('strong', {}, 'Reading Mode'),
article ? React.createElement('span', {}, "•") : null,
article ? React.createElement('span', {}, article.category || "") : null
),
React.createElement('button', { id: 'close', onClick: onClose }, 'Close')
),
React.createElement('div', { id: 'modalBody' },
isLoading
? React.createElement('div', { style: {opacity:0.7, fontFamily:'var(--font-ui)', letterSpacing:'1px', padding:'20px'} }, 'Loading…')
: errorText
? React.createElement('article', null,
React.createElement('h1', null, 'Could not load article'),
React.createElement('p', null, 'Error loading file:'),
React.createElement('pre', { style: { border:'1px solid rgba(255,255,255,0.12)', background:'rgba(18,18,18,0.55)', borderRadius:'14px', padding:'12px', overflow:'auto' } }, errorText),
React.createElement('p', { style: {marginTop:'1em', fontSize:'0.9rem', opacity:0.8} }, 'NOTE: If testing locally (file://), this is expected due to CORS. Please test on a local server or GitHub Pages.')
)
: React.createElement(React.Fragment, null,
React.createElement(ArticleHeader, { title: article.title, category: article.category, date: article.date }),
React.createElement(ArticleBody, { content: content })
)
)
);
};
const ARTICLES = [
{ id:"options-pricing", file:"./articles/options.html", category:"Financial Econometrics", title:"Options Pricing", date:"JAN 2026", enabled:true },
{ id:"bvar", file:"./articles/bvar.html", category:"Core Theory", title:"Bayesian Vector Autoregression", date:"DEC 2025", enabled:true },
{ id:"stoch-vol", file:"./articles/forecasting.html", category:"Time Series", title:"Why ML is (almost) useless in Time Series Forecasting ?", date:"JAN 2026", enabled:true },
{ id:"sign-rest", file:"./articles/ERPT.html", category:"Macroeconometrics", title:"ERPT", date:"JAN 2026", enabled:true }
].filter(x=>x.enabled);
const TEX = [
String.raw`Y_t = A_1Y_{t-1}+\cdots+A_pY_{t-p}+u_t`,
String.raw`u_t\sim\mathcal{N}(0,\Sigma)`,
String.raw`p(\theta\mid Y)\propto p(Y\mid\theta)p(\theta)`,
String.raw`E[y_t\mid\mathcal{I}_{t-1}]`,
String.raw`h_t=\mu+\phi(h_{t-1}-\mu)+\sigma_h\xi_t,\ \ y_t=e^{h_t/2}\varepsilon_t`,
String.raw`\nabla\mathcal{L}(\theta)`,
String.raw`\Sigma = A^{-1}\Lambda A^{-1\prime}`
];
const $ = (id)=>document.getElementById(id);
const root = document.documentElement;
const themeBtn = $("theme");
const metaTheme = document.querySelector('meta[name="theme-color"]');
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const lerp = (a,b,t)=>a+(b-a)*t;
function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
function showErr(e){
$("errText").textContent = (e && (e.stack || e.message)) ? (e.stack || e.message) : String(e);
$("err").style.display = "block";
}
function isWebGLAvailable(){
try{
const c = document.createElement("canvas");
return !!(window.WebGLRenderingContext && (c.getContext("webgl") || c.getContext("experimental-webgl")));
}catch(_){ return false; }
}
const LS_KEY = "theme";
function applyTheme(theme, persist){
root.setAttribute("data-theme", theme);
if (persist) localStorage.setItem(LS_KEY, theme);
if (theme === "light"){
root.style.setProperty("--bg", "#fbfbfc");
root.style.setProperty("--panel", "rgba(255,255,255,0.82)");
root.style.setProperty("--panel-strong", "rgba(255,255,255,0.94)");
root.style.setProperty("--border", "rgba(0,0,0,0.10)");
root.style.setProperty("--silver", "#1b1b1c");
root.style.setProperty("--silver-dim", "rgba(27,27,28,0.72)");
root.style.setProperty("--gold", "#B88A00");
root.style.setProperty("--gold-soft", "#7A5A00");
themeBtn.textContent = "Dark";
metaTheme && metaTheme.setAttribute("content", "#fbfbfc");
$("depthName").style.color = "rgba(184,138,0,0.20)";
$("depthName").style.textShadow = "0 0 55px rgba(184,138,0,0.14)";
} else {
root.removeAttribute("style");
themeBtn.textContent = "Light";
metaTheme && metaTheme.setAttribute("content", "#050505");
$("depthName").style.color = "rgba(212,175,55,0.24)";
$("depthName").style.textShadow = "0 0 55px rgba(212,175,55,0.18)";
}
const eqs = document.querySelectorAll(".eq");
const isLight = theme==="light";
eqs.forEach(n=>{
n.style.color = isLight ? "rgba(20,20,20,0.92)" : "rgba(232,232,234,0.92)";
n.style.filter = isLight ? "drop-shadow(0 0 14px rgba(184,138,0,0.20))" : "drop-shadow(0 0 14px rgba(212,175,55,0.24))";
});
if (window.__RECOLOR__) window.__RECOLOR__();
}
function getInitialTheme(){
const saved = localStorage.getItem(LS_KEY);
return (saved === "light" || saved === "dark") ? saved : "dark";
}
const modal = $("modal");
const cache = new Map();
const container = document.getElementById('react-app');
let reactRoot = null;
let modalJustOpenedAt = 0;
function ensureRoot(){
if (!reactRoot){
if (ReactDOM && ReactDOM.createRoot) reactRoot = ReactDOM.createRoot(container);
else reactRoot = { render: (el)=>ReactDOM.render(el, container), unmount: ()=>ReactDOM.unmountComponentAtNode(container) };
}
return reactRoot;
}
function closeModal(){
modal.classList.remove("open");
if (reactRoot && reactRoot.unmount) reactRoot.unmount();
reactRoot = null;
}
modal.addEventListener("click", (e)=>{
if (performance.now() - modalJustOpenedAt < 250) return;
if (e.target === modal) closeModal();
});
window.addEventListener("keydown", (e)=>{
if (e.key==="Escape" && modal.classList.contains("open")) closeModal();
}, { passive:true });
async function openArticle(a){
modalJustOpenedAt = performance.now();
modal.classList.add("open");
const rr = ensureRoot();
rr.render(React.createElement(ArticleModal, { article: a, content: '', onClose: closeModal, isLoading: true, errorText: '' }));
try{
// ROBUST PATH HANDLING FOR GITHUB PAGES
const path = window.location.pathname;
const dir = path.substring(0, path.lastIndexOf('/') + 1);
const baseUrl = window.location.origin + dir;
const cleanFile = a.file.replace(/^\.\//, '');
const resolvedUrl = new URL(cleanFile, baseUrl).href;

let html = cache.get(resolvedUrl);
if (!html){
// TIMEOUT AND FETCH
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 8000);
const res = await fetch(resolvedUrl, { signal: controller.signal, headers: {'Accept': 'text/html'} });
clearTimeout(timeoutId);
if (!res.ok) throw new Error(`HTTP ${res.status} - ${res.statusText}`);
html = await res.text();
cache.set(resolvedUrl, html);
}
const doc = new DOMParser().parseFromString(html, "text/html");
const contentNode = doc.querySelector(".content") || doc.querySelector("article") || doc.body;
contentNode.querySelectorAll("#toc, .toc, nav.toc, .table-of-contents, .contents, [data-toc]").forEach(n=>n.remove());
rr.render(React.createElement(ArticleModal, { article: a, content: contentNode.innerHTML, onClose: closeModal, isLoading: false, errorText: '' }));
}catch(e){
rr.render(React.createElement(ArticleModal, { article: a, content: '', onClose: closeModal, isLoading: false, errorText: String(e) }));
}
}
function buildEquationLayer(){
const layer = $("eqLayer");
layer.innerHTML = "";
const isLight = (root.getAttribute("data-theme")==="light");
const color = isLight ? "rgba(20,20,20,0.92)" : "rgba(232,232,234,0.92)";
const count = 16;
const items = [];
for (let i=0;i<count;i++){
const el = document.createElement("div");
el.className = "eq";
el.style.color = color;
const tex = TEX[i % TEX.length];
try{ el.innerHTML = window.katex.renderToString(tex, { throwOnError:false, displayMode:false }); }
catch(_){ el.textContent = tex; }
items.push({ el, a: Math.random()*Math.PI*2, r: 0.18 + Math.random()*0.82, s: 0.08 + Math.random()*0.18, ph: Math.random()*10, ox: (Math.random()-0.5)*140, oy: (Math.random()-0.5)*140 });
layer.appendChild(el);
}
return items;
}
if (!window.THREE || !isWebGLAvailable()){
showErr(new Error("WebGL or Three.js unavailable."));
return;
}
try{
const canvas = $("gl");
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false, powerPreference: "high-performance" });
const DPR = ()=>Math.min(window.devicePixelRatio || 1, 2);
renderer.setPixelRatio(DPR());
renderer.setSize(window.innerWidth, window.innerHeight, false);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.08;
const scene = new THREE.Scene();
scene.background = new THREE.Color(cssVar("--bg") || "#050505");
const camera = new THREE.PerspectiveCamera(52, window.innerWidth/window.innerHeight, 0.1, 5000);
camera.position.set(0, 0, 220);
scene.add(new THREE.AmbientLight(0xffffff, 0.34));
const key = new THREE.DirectionalLight(0xffffff, 1.75); key.position.set(160, 190, 130); scene.add(key);
const fill = new THREE.DirectionalLight(0xfff1cc, 0.72); fill.position.set(-210, 70, 160); scene.add(fill);
const rim = new THREE.PointLight(0xd4af37, 1.35, 1200, 1.4); rim.position.set(0, 0, -320); scene.add(rim);
const pointer = new THREE.Vector2(0,0);
let px=0, py=0, pointerActive=false;
const galaxy = new THREE.Group();
scene.add(galaxy);
function buildStars(){
const starCount = 38000;
const geom = new THREE.BufferGeometry();
const pos = new Float32Array(starCount*3);
const col = new Float32Array(starCount*3);
const size = new Float32Array(starCount);
const gold = new THREE.Color(cssVar("--gold") || "#D4AF37");
const silv = new THREE.Color(cssVar("--silver") || "#e8e8ea");
const blue = new THREE.Color("#7aa6ff");
const arms = 4;
for (let i=0;i<starCount;i++){
const r = Math.pow(Math.random(), 0.42) * 900;
const arm = (i % arms) * (Math.PI*2/arms);
const theta = Math.random() * Math.PI*2;
const twist = (r/900) * 6.6;
const a = theta + arm + twist;
const thickness = (1 - r/900);
const y = (Math.random()-0.5) * (22 + 160*(1-thickness)) * (0.32 + 0.68*Math.random());
pos[i*3+0] = Math.cos(a)*r + (Math.random()-0.5)*14;
pos[i*3+1] = y;
pos[i*3+2] = Math.sin(a)*r + (Math.random()-0.5)*14;
const t = clamp(0.16 + 0.84*(1 - r/900), 0, 1);
const c = silv.clone().lerp(gold, t);
if (Math.random() < 0.10) c.lerp(blue, 0.55);
col[i*3+0]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
size[i] = 0.6 + Math.random()*2.4;
if (Math.random() < 0.02) size[i] *= 3.0;
}
geom.setAttribute("position", new THREE.BufferAttribute(pos,3));
geom.setAttribute("color", new THREE.BufferAttribute(col,3));
geom.setAttribute("aSize", new THREE.BufferAttribute(size,1));
const mat = new THREE.ShaderMaterial({
transparent: true,
depthWrite: false,
blending: THREE.AdditiveBlending,
uniforms: { uTime: { value: 0 }, uDpr: { value: DPR() } },
vertexShader: `
attribute float aSize;
attribute vec3 color;
varying vec3 vColor;
uniform float uTime;
uniform float uDpr;
void main(){
vColor = color;
vec3 p = position;
float tw = sin(uTime*0.18 + p.x*0.01 + p.z*0.01) * 0.30;
p.y += tw;
vec4 mv = modelViewMatrix * vec4(p, 1.0);
gl_Position = projectionMatrix * mv;
float s = aSize * (300.0 / -mv.z);
gl_PointSize = clamp(s * uDpr, 1.0, 10.0);
}
`,
fragmentShader: `
varying vec3 vColor;
void main(){
vec2 uv = gl_PointCoord.xy - 0.5;
float d = dot(uv, uv);
float a = smoothstep(0.25, 0.0, d);
float halo = smoothstep(0.48, 0.10, d) * 0.55;
vec3 c = vColor * (1.2*a + 0.9*halo);
gl_FragColor = vec4(c, (a + halo) * 0.85);
}
`
});
return new THREE.Points(geom, mat);
}
const stars = buildStars();
stars.rotation.x = -0.34;
galaxy.add(stars);
const nebula = new THREE.Mesh(
new THREE.SphereGeometry(1900, 48, 48),
new THREE.ShaderMaterial({
side: THREE.BackSide,
uniforms: {
uTime: { value: 0 },
uPointer: { value: new THREE.Vector2(0,0) },
uGold: { value: new THREE.Color(cssVar("--gold") || "#D4AF37") },
uSilver: { value: new THREE.Color(cssVar("--silver") || "#e8e8ea") },
uBg: { value: new THREE.Color(cssVar("--bg") || "#050505") }
},
vertexShader: `
varying vec3 vP;
uniform float uTime;
uniform vec2 uPointer;
void main(){
vec3 p = position;
float band = exp(-abs(p.y) / 240.0);
float swirl = sin(uTime*0.08 + p.x*0.002 + p.z*0.002) * 22.0 * band;
p.x += swirl;
p.z -= swirl * 0.55;
p.x += uPointer.x * 40.0 * band;
p.y += uPointer.y * 18.0 * band;
vP = p;
gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
}
`,
fragmentShader: `
varying vec3 vP;
uniform float uTime;
uniform vec3 uGold;
uniform vec3 uSilver;
uniform vec3 uBg;
float noise(vec3 p){
vec3 i = floor(p);
vec3 f = fract(p);
f = f*f*(3.0-2.0*f);
float n000 = fract(sin(dot(i, vec3(1.0,57.0,113.0))) * 43758.5453);
float n100 = fract(sin(dot(i+vec3(1,0,0), vec3(1.0,57.0,113.0))) * 43758.5453);
float n010 = fract(sin(dot(i+vec3(0,1,0), vec3(1.0,57.0,113.0))) * 43758.5453);
float n110 = fract(sin(dot(i+vec3(1,1,0), vec3(1.0,57.0,113.0))) * 43758.5453);
float n001 = fract(sin(dot(i+vec3(0,0,1), vec3(1.0,57.0,113.0))) * 43758.5453);
float n101 = fract(sin(dot(i+vec3(1,0,1), vec3(1.0,57.0,113.0))) * 43758.5453);
float n011 = fract(sin(dot(i+vec3(0,1,1), vec3(1.0,57.0,113.0))) * 43758.5453);
float n111 = fract(sin(dot(i+vec3(1,1,1), vec3(1.0,57.0,113.0))) * 43758.5453);
float n00 = mix(n000, n100, f.x);
float n10 = mix(n010, n110, f.x);
float n01 = mix(n001, n101, f.x);
float n11 = mix(n011, n111, f.x);
float n0 = mix(n00, n10, f.y);
float n1 = mix(n01, n11, f.y);
return mix(n0, n1, f.z);
}
float fbm(vec3 p){
float v = 0.0;
float a = 0.5;
for(int i=0;i<5;i++){
v += a * noise(p);
p *= 2.02;
a *= 0.5;
}
return v;
}
void main(){
float band = exp(-abs(vP.y) / 170.0);
vec3 q = vP * 0.0018 + vec3(0.0, 0.0, uTime*0.015);
float n = fbm(q*3.0);
float m = fbm(q*6.0 + 12.3);
float cloud = smoothstep(0.35, 0.92, n) * band;
float dust = smoothstep(0.25, 0.85, m) * band;
float grad = clamp(0.5 + 0.5*sin(vP.x*0.002 + uTime*0.06), 0.0, 1.0);
vec3 mixc = mix(uSilver, uGold, grad);
vec3 c = uBg;
c += mixc * (0.18*cloud + 0.12*dust);
c += uGold * (0.06 * band);
c = clamp(c, 0.0, 1.0);
gl_FragColor = vec4(c, 1.0);
}
`
})
);
scene.add(nebula);
const planets = new THREE.Group();
scene.add(planets);
const ringGroup = new THREE.Group();
planets.add(ringGroup);
const ringTiltX = 0.38;
const ringTiltZ = -0.12;
ringGroup.rotation.x = ringTiltX;
ringGroup.rotation.z = ringTiltZ;
const raycaster = new THREE.Raycaster();
let hovered = null;
const STYLES = [
{ seed: 2, a:"#0b1220", b:"#2f6be3", c:"#3c6e5f", at:"#6bb0ff", rough:0.70 },
{ seed: 5, a:"#2a2321", b:"#b08d5a", c:"#d8c9b0", at:"#f7e7ce", rough:0.60 },
{ seed: 8, a:"#3a2f26", b:"#d1b27a", c:"#f0eadf", at:"#f7e7ce", rough:0.58 },
{ seed: 13, a:"#281a12", b:"#b35c2a", c:"#efe7df", at:"#ffb07a", rough:0.82 },
{ seed: 21, a:"#081024", b:"#2f6be3", c:"#7aa6ff", at:"#7aa6ff", rough:0.66 },
{ seed: 34, a:"#1f1f22", b:"#9b9aa0", c:"#f2f2f4", at:"#e8e8ea", rough:0.92 }
];
function labelSprite(text){
const w=1200, h=380;
const c=document.createElement("canvas");
c.width=w; c.height=h;
const g=c.getContext("2d");
const bg = g.createLinearGradient(0,0,w,h);
bg.addColorStop(0,"rgba(232,232,234,0.16)");
bg.addColorStop(0.55,"rgba(212,175,55,0.12)");
bg.addColorStop(1,"rgba(232,232,234,0.08)");
const r=52;
g.beginPath();
g.moveTo(r,0); g.lineTo(w-r,0); g.quadraticCurveTo(w,0,w,r);
g.lineTo(w,h-r); g.quadraticCurveTo(w,h,w-r,h);
g.lineTo(r,h); g.quadraticCurveTo(0,h,0,h-r);
g.lineTo(0,r); g.quadraticCurveTo(0,0,r,0);
g.closePath();
g.fillStyle = bg;
g.fill();
g.strokeStyle = "rgba(255,255,255,0.18)";
g.lineWidth = 2;
g.stroke();
g.shadowColor = "rgba(212,175,55,0.26)";
g.shadowBlur = 14;
g.fillStyle = "rgba(255,255,255,0.94)";
g.textAlign = "center";
g.textBaseline = "middle";
g.font = "800 90px 'Latin Modern Sans','Latin Modern Roman',system-ui,sans-serif";
const pad=48;
const maxW=w-pad*2;
const words=String(text).split(/\s+/).filter(Boolean);
let line="", lines=[];
for(let i=0;i<words.length;i++){
const test=line? (line+" "+words[i]) : words[i];
if(g.measureText(test).width<=maxW) line=test;
else{ lines.push(line); line=words[i]; }
}
if(line) lines.push(line);
const lineH=104;
const y0=h/2 - ((lines.length-1)*lineH)/2;
for(let i=0;i<lines.length;i++) g.fillText(lines[i], w/2, y0+i*lineH);
const tex=new THREE.CanvasTexture(c);
tex.colorSpace = THREE.SRGBColorSpace;
tex.anisotropy = 8;
const spr=new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false }));
spr.scale.set(100, 36, 1);
spr.userData._labelText = text;
return spr;
}
function planetMaterial(style){
return new THREE.ShaderMaterial({
uniforms:{
uTime: { value: 0 },
uSeed: { value: style.seed },
uA: { value: new THREE.Color(style.a) },
uB: { value: new THREE.Color(style.b) },
uC: { value: new THREE.Color(style.c) },
uGold: { value: new THREE.Color(cssVar("--gold") || "#D4AF37") },
uRough: { value: style.rough }
},
vertexShader: `
varying vec3 vN;
varying vec3 vW;
void main(){
vN = normalize(normalMatrix * normal);
vec4 wpos = modelMatrix * vec4(position,1.0);
vW = wpos.xyz;
gl_Position = projectionMatrix * viewMatrix * wpos;
}
`,
fragmentShader: `
varying vec3 vN;
varying vec3 vW;
uniform float uTime;
uniform float uSeed;
uniform vec3 uA;
uniform vec3 uB;
uniform vec3 uC;
uniform vec3 uGold;
uniform float uRough;
float hash(vec3 p){
p = fract(p*0.3183099 + uSeed*0.07);
p *= 17.0;
return fract(p.x*p.y*p.z*(p.x+p.y+p.z));
}
float noise(vec3 p){
vec3 i = floor(p);
vec3 f = fract(p);
f = f*f*(3.0-2.0*f);
float n000 = hash(i);
float n100 = hash(i+vec3(1,0,0));
float n010 = hash(i+vec3(0,1,0));
float n110 = hash(i+vec3(1,1,0));
float n001 = hash(i+vec3(0,0,1));
float n101 = hash(i+vec3(1,0,1));
float n011 = hash(i+vec3(0,1,1));
float n111 = hash(i+vec3(1,1,1));
float n00 = mix(n000, n100, f.x);
float n10 = mix(n010, n110, f.x);
float n01 = mix(n001, n101, f.x);
float n11 = mix(n011, n111, f.x);
float n0 = mix(n00, n10, f.y);
float n1 = mix(n01, n11, f.y);
return mix(n0, n1, f.z);
}
float fbm(vec3 p){
float v=0.0;
float a=0.5;
for(int i=0;i<5;i++){
v += a*noise(p);
p *= 2.02;
a *= 0.5;
}
return v;
}
void main(){
vec3 N = normalize(vN);
vec3 V = normalize(cameraPosition - vW);
float lat = N.y * 0.5 + 0.5;
float bands = sin((lat*12.0 + uSeed*0.13 + uTime*0.02) * 6.28318) * 0.5 + 0.5;
vec3 p = N * 3.2 + vec3(0.0, 0.0, uTime*0.03);
float n = fbm(p + uSeed*0.1);
float m = fbm(p*2.0 + 10.0);
float t2 = smoothstep(0.35, 0.90, m);
vec3 base = mix(uA, uB, bands*0.75 + 0.15*n);
base = mix(base, uC, t2*0.35);
float glint = pow(max(0.0, dot(reflect(-V,N), normalize(vec3(0.2,0.7,0.6)))), 18.0);
base += uGold * (0.14 * glint);
vec3 L = normalize(vec3(0.35, 0.72, 0.58));
float diff = max(0.0, dot(N,L));
float fres = pow(1.0 - max(0.0, dot(V,N)), 3.0);
float spec = pow(max(0.0, dot(reflect(-L,N), V)), 28.0) * (1.0 - uRough);
vec3 c = base * (0.22 + 1.05*diff) + vec3(1.0)*spec*0.34;
c += uGold * fres * 0.08;
gl_FragColor = vec4(clamp(c,0.0,1.0), 1.0);
}
`
});
}
function atmosphereMaterial(hex){
return new THREE.ShaderMaterial({
transparent:true,
depthWrite:false,
blending:THREE.AdditiveBlending,
uniforms:{ uColor:{ value:new THREE.Color(hex) }, uIntensity:{ value:0.76 } },
vertexShader: `
varying vec3 vN;
varying vec3 vW;
void main(){
vN = normalize(normalMatrix * normal);
vec4 wpos = modelMatrix * vec4(position,1.0);
vW = wpos.xyz;
gl_Position = projectionMatrix * viewMatrix * wpos;
}
`,
fragmentShader: `
varying vec3 vN;
varying vec3 vW;
uniform vec3 uColor;
uniform float uIntensity;
void main(){
vec3 V = normalize(cameraPosition - vW);
float fres = pow(1.0 - max(0.0, dot(V, vN)), 3.0);
float a = fres * uIntensity;
gl_FragColor = vec4(uColor, a);
}
`
});
}
const entries = [];
function buildSaturnRings(innerR, outerR){
ringGroup.clear();
const gold = new THREE.Color(cssVar("--gold") || "#D4AF37");
const silv = new THREE.Color(cssVar("--silver") || "#e8e8ea");
const makeRing = (r0, r1, opacity, z, tintMix)=>{
const geo = new THREE.RingGeometry(r0, r1, 192, 1);
const mat = new THREE.ShaderMaterial({
transparent:true,
depthWrite:false,
blending:THREE.AdditiveBlending,
uniforms:{
uTime:{ value:0 },
uGold:{ value: gold.clone() },
uSilv:{ value: silv.clone() },
uOpacity:{ value: opacity },
uTint:{ value: tintMix }
},
vertexShader: `
varying vec2 vUv;
varying vec3 vPos;
void main(){
vUv = uv;
vec4 wp = modelMatrix * vec4(position,1.0);
vPos = wp.xyz;
gl_Position = projectionMatrix * viewMatrix * wp;
}
`,
fragmentShader: `
varying vec2 vUv;
varying vec3 vPos;
uniform float uTime;
uniform vec3 uGold;
uniform vec3 uSilv;
uniform float uOpacity;
uniform float uTint;
float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
float noise(vec2 p){
vec2 i = floor(p);
vec2 f = fract(p);
f = f*f*(3.0-2.0*f);
float a = hash(i);
float b = hash(i+vec2(1.0,0.0));
float c = hash(i+vec2(0.0,1.0));
float d = hash(i+vec2(1.0,1.0));
return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
}
void main(){
float r = length(vUv - 0.5) * 2.0;
float band = smoothstep(0.0, 1.0, r);
float g = noise((vUv-0.5)*vec2(180.0, 28.0) + uTime*0.02);
float streak = noise((vUv-0.5)*vec2(420.0, 44.0) - uTime*0.01);
float a = (0.55 + 0.45*g) * (0.55 + 0.45*streak);
float edge = smoothstep(0.98, 0.65, r) * smoothstep(0.02, 0.18, r);
a *= edge;
vec3 c = mix(uSilv, uGold, uTint + 0.15*sin(vUv.x*20.0));
gl_FragColor = vec4(c, a * uOpacity);
}
`
});
const m = new THREE.Mesh(geo, mat);
m.position.z = z;
ringGroup.add(m);
return m;
};
const rings = [];
rings.push(makeRing(innerR, outerR, 0.22, 0.0, 0.55));
rings.push(makeRing(innerR*1.02, outerR*0.985, 0.16, 0.06, 0.35));
rings.push(makeRing(innerR*1.06, outerR*0.96, 0.12, -0.06, 0.70));
return rings;
}
function wrapAngle(a){ const two = Math.PI*2; a = a % two; return a < 0 ? a + two : a; }
function angleDist(a,b){ const two = Math.PI*2; let d = Math.abs(a-b) % two; return d > Math.PI ? two - d : d; }
function enforceAngularSeparation(){
const n = entries.length;
if (n <= 1) return;
const minGapBase = 0.64;
for (let it=0; it<22; it++){
let moved = 0;
const idx = entries.map((p)=>p).sort((a,b)=>a.angle - b.angle);
for (let k=0;k<n;k++){
const A = idx[k];
const B = idx[(k+1)%n];
const gapNeed = minGapBase + 0.010*(A.radius + B.radius);
const d = angleDist(A.angle, B.angle);
if (d < gapNeed){
const push = (gapNeed - d) * 0.5;
A.angle = wrapAngle(A.angle - push);
B.angle = wrapAngle(B.angle + push);
moved++;
}
}
if (!moved) break;
}
}
function applyOrbitPosition(p){
const r = p.ringR * (1.0 + p.rMod);
const x = Math.cos(p.angle) * r;
const y = Math.sin(p.angle) * r;
const z = p.zMod;
const pos = new THREE.Vector3(x,y,0);
pos.applyEuler(new THREE.Euler(ringTiltX, 0, ringTiltZ, "XYZ"));
pos.z += z;
p.mesh.position.copy(pos);
p.atmo.position.copy(pos);
p.label.position.copy(pos);
const offset = (p.radius + 42 * p.scale * p.labelScaleMult);
const up = new THREE.Vector3(0,1,0).applyEuler(new THREE.Euler(ringTiltX, 0, ringTiltZ, "XYZ"));
const sign = (y >= 0) ? 1 : -1;
p.label.position.addScaledVector(up, offset * sign);
p.label.quaternion.copy(camera.quaternion);
}
function disposeObject(obj){
obj.traverse((o)=>{
if (o.geometry) o.geometry.dispose();
if (o.material){
if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose && m.dispose());
else o.material.dispose && o.material.dispose();
}
if (o.material && o.material.map) o.material.map.dispose && o.material.map.dispose();
});
}
function rebuildLabelTextures(){
for (const p of entries){
const spr = p.label;
if (!spr || !spr.userData || !spr.userData._labelText) continue;
const newSpr = labelSprite(spr.userData._labelText);
newSpr.scale.copy(spr.scale);
newSpr.position.copy(spr.position);
newSpr.quaternion.copy(spr.quaternion);
newSpr.userData.article = spr.userData.article;
planets.remove(spr);
planets.add(newSpr);
p.label = newSpr;
}
}
let ringMeshes = [];
function buildPlanets(){
for (let i = planets.children.length - 1; i >= 0; i--) {
const ch = planets.children[i];
if (ch !== ringGroup) { planets.remove(ch); try{ disposeObject(ch); }catch(_){} }
}
entries.length = 0;
let w = window.innerWidth;
let h = window.innerHeight;
if (!w || !h) { w = 1024; h = 768; }
const isMobile = w < 800;
const aspect = w / h;
const dist = 220;
const vH = 2 * dist * Math.tan((52 * Math.PI / 180) / 2);
const vW = vH * aspect;
let scale = Math.min(vW / 560, vH / 560);
if (!Number.isFinite(scale)) scale = 1.0;
const finalScale = Math.max(scale, 0.22);
const ringR = 142 * finalScale;
const ringInner = ringR * 0.78;
const ringOuter = ringR * 1.12;
ringMeshes = buildSaturnRings(ringInner, ringOuter);
const planetBaseRadius = isMobile ? 50 : 25;
const labelScaleMult = isMobile ? 2.05 : 1.0;
const n = ARTICLES.length;
for (let i=0;i<n;i++){
const art = ARTICLES[i];
const st = STYLES[i % STYLES.length];
const radius = planetBaseRadius * finalScale;
const mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 64, 64), planetMaterial(st));
mesh.userData.article = art;
mesh.userData.radius = radius;
const atmo = new THREE.Mesh(new THREE.SphereGeometry(radius*1.06, 64, 64), atmosphereMaterial(st.at));
atmo.userData.article = art;
const label = labelSprite(art.title);
label.scale.multiplyScalar(finalScale * labelScaleMult);
label.userData.article = art;
const baseAngle = (i / n) * Math.PI*2 + Math.PI/5;
entries.push({
mesh, atmo, label,
radius,
angle: baseAngle,
angVel: 0,
rMod: 0,
zMod: 0,
ringR,
hoverPull: 0,
scale: finalScale,
labelScaleMult
});
planets.add(mesh);
planets.add(atmo);
planets.add(label);
}
enforceAngularSeparation();
for (const p of entries) applyOrbitPosition(p);
}
buildPlanets();
if (document.fonts && document.fonts.ready) {
document.fonts.ready.then(()=>rebuildLabelTextures()).catch(()=>{});
}
function getClientXY(ev){
if (ev && ev.changedTouches && ev.changedTouches.length) return { x: ev.changedTouches[0].clientX, y: ev.changedTouches[0].clientY };
if (ev && ev.touches && ev.touches.length) return { x: ev.touches[0].clientX, y: ev.touches[0].clientY };
return { x: ev.clientX, y: ev.clientY };
}
function setPointerFromEvent(ev){
const r = canvas.getBoundingClientRect();
const p = getClientXY(ev);
const x = (p.x - r.left) / Math.max(1, r.width);
const y = (p.y - r.top) / Math.max(1, r.height);
pointer.x = x * 2 - 1;
pointer.y = -(y * 2 - 1);
px = clamp(p.x - r.left, 0, r.width);
py = clamp(p.y - r.top, 0, r.height);
pointerActive = true;
}
let lastTapAt = 0;
let tapStart = null;
function tryPick(ev){
if (modal.classList.contains("open")) return;
setPointerFromEvent(ev);
raycaster.setFromCamera(pointer, camera);
const hits = raycaster.intersectObjects(planets.children, true).filter(h => h.object && h.object.userData && h.object.userData.article);
if (hits.length > 0){
openArticle(hits[0].object.userData.article);
}
}
function onTapStart(ev){
if (modal.classList.contains("open")) return;
const p = getClientXY(ev);
tapStart = { x: p.x, y: p.y, t: performance.now() };
setPointerFromEvent(ev);
if (ev.cancelable) ev.preventDefault();
}
function onTapEnd(ev){
if (!tapStart) { tryPick(ev); return; }
const p = getClientXY(ev);
const dt = performance.now() - tapStart.t;
const dx = Math.abs(p.x - tapStart.x);
const dy = Math.abs(p.y - tapStart.y);
tapStart = null;
if (dt < 450 && dx < 14 && dy < 14){
const now = performance.now();
if (now - lastTapAt < 220) return;
lastTapAt = now;
tryPick(ev);
}
if (ev.cancelable) ev.preventDefault();
}
function onPointerMove(e){
setPointerFromEvent(e);
}
canvas.addEventListener("pointermove", onPointerMove, { passive:true });
canvas.addEventListener("pointerdown", onTapStart, { passive:false });
canvas.addEventListener("pointerup", onTapEnd, { passive:false });
canvas.addEventListener("touchstart", onTapStart, { passive:false });
canvas.addEventListener("touchend", onTapEnd, { passive:false });
canvas.addEventListener("touchcancel", ()=>{ tapStart = null; }, { passive:true });
canvas.addEventListener("click", (e)=>{ tryPick(e); }, { passive:true });
const clock = new THREE.Clock();
let eqItems = buildEquationLayer();
window.__RECOLOR__ = function(){
nebula.material.uniforms.uGold.value.set(cssVar("--gold") || "#D4AF37");
nebula.material.uniforms.uSilver.value.set(cssVar("--silver") || "#e8e8ea");
nebula.material.uniforms.uBg.value.set(cssVar("--bg") || "#050505");
scene.background.set(cssVar("--bg") || "#050505");
if (ringMeshes && ringMeshes.length){
const gold = new THREE.Color(cssVar("--gold") || "#D4AF37");
const silv = new THREE.Color(cssVar("--silver") || "#e8e8ea");
ringMeshes.forEach(m=>{
if (m.material && m.material.uniforms){
m.material.uniforms.uGold.value.copy(gold);
m.material.uniforms.uSilv.value.copy(silv);
}
});
}
};
const _targetScale = new THREE.Vector3();
function tick(){
const t = clock.getElapsedTime();
const dt = Math.min(0.033, clock.getDelta());
const nx = pointerActive ? (px / Math.max(1, canvas.getBoundingClientRect().width) - 0.5) : 0.0;
const ny = pointerActive ? (py / Math.max(1, canvas.getBoundingClientRect().height) - 0.5) : 0.0;
camera.position.x = lerp(camera.position.x, nx * 26, 0.06);
camera.position.y = lerp(camera.position.y, (-ny) * 12, 0.06);
camera.lookAt(0,0,0);
nebula.material.uniforms.uTime.value = t;
nebula.material.uniforms.uPointer.value.set(nx, -ny);
stars.material.uniforms.uTime.value = t;
stars.material.uniforms.uDpr.value = DPR();
galaxy.rotation.y = Math.sin(t*0.06)*0.12;
galaxy.rotation.z = Math.cos(t*0.04)*0.06;
if (ringMeshes && ringMeshes.length){
ringMeshes.forEach(m=>{ if (m.material && m.material.uniforms) m.material.uniforms.uTime.value = t; });
ringGroup.rotation.y = Math.sin(t*0.05)*0.06;
}
raycaster.setFromCamera(pointer, camera);
const hits = raycaster.intersectObjects(planets.children, true);
const hit = hits.find(h => h.object && h.object.userData && h.object.userData.article);
const newHover = hit ? hit.object : null;
if (hovered !== newHover){
hovered = newHover;
document.body.style.cursor = hovered ? "pointer" : "default";
}
const n = entries.length;
for (let i=0;i<n;i++){
const p = entries[i];
const m = p.mesh;
m.rotation.y += dt * (0.11 + i*0.008);
m.rotation.x += dt * 0.010;
const isHover = hovered && hovered.userData.article === m.userData.article;
p.hoverPull = lerp(p.hoverPull, isHover ? 1 : 0, 0.12);
const baseSpin = 0.052;
const steer = pointerActive ? (nx * 0.16) : 0.0;
const hoverSteer = p.hoverPull * (nx*0.50) * 0.08;
p.angVel = lerp(p.angVel, baseSpin + steer + hoverSteer, 0.05);
const wob = Math.sin(t*0.7 + i*1.7) * 0.0032;
p.angle = wrapAngle(p.angle + (p.angVel + wob) * dt * 8.0);
const rTarget = isHover ? 0.030 : 0.0;
p.rMod = lerp(p.rMod, rTarget, 0.09);
const zTarget = isHover ? 24.0 : 0.0;
p.zMod = lerp(p.zMod, zTarget, 0.10);
}
for (let it=0; it<2; it++) enforceAngularSeparation();
for (let i=0;i<n;i++){
const p = entries[i];
const isHover = hovered && hovered.userData.article === p.mesh.userData.article;
applyOrbitPosition(p);
const s = isHover ? 1.10 : 1.0;
_targetScale.set(s, s, s);
p.mesh.scale.lerp(_targetScale, 0.10);
_targetScale.set(s*1.02, s*1.02, s*1.02);
p.atmo.scale.lerp(_targetScale, 0.10);
if (p.mesh.material && p.mesh.material.uniforms){
p.mesh.material.uniforms.uTime.value = t;
p.mesh.material.uniforms.uGold.value.set(cssVar("--gold") || "#D4AF37");
}
}
$("depthName").style.transform = `translate(-50%, -50%) translate(${nx*18}px, ${-ny*10}px)`;
const w = window.innerWidth, h = window.innerHeight;
for (let i=0;i<eqItems.length;i++){
const it = eqItems[i];
it.a += dt * it.s;
const rr = (0.18 + it.r*0.82);
const x = (0.5 + 0.46*Math.cos(it.a) * rr) * w + it.ox;
const y = (0.5 + 0.36*Math.sin(it.a*0.92 + it.ph) * rr) * h + it.oy;
const op = 0.18 + 0.12*(0.5+0.5*Math.sin(t*0.35 + i));
it.el.style.opacity = String(op);
it.el.style.transform = `translate3d(${x}px, ${y}px, 0) rotate(${Math.sin(it.a)*2.0}deg)`;
}
renderer.render(scene, camera);
requestAnimationFrame(tick);
}
function onResize(){
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setPixelRatio(DPR());
renderer.setSize(window.innerWidth, window.innerHeight, false);
buildPlanets();
eqItems = buildEquationLayer();
if (document.fonts && document.fonts.ready) document.fonts.ready.then(()=>rebuildLabelTextures()).catch(()=>{});
}
window.addEventListener("resize", onResize, { passive:true });
const brand = $("brand");
brand.addEventListener("click", ()=>camera.position.set(0,0,220));
brand.addEventListener("keydown", (e)=>{ if (e.key==="Enter"||e.key===" "){ e.preventDefault(); camera.position.set(0,0,220); } });
themeBtn.addEventListener("click", ()=>{
const cur = root.getAttribute("data-theme") || "dark";
applyTheme(cur === "dark" ? "light" : "dark", true);
});
applyTheme(getInitialTheme(), false);
tick();
}catch(e){
showErr(e);
}
})();
</script>
</body>
</html>
