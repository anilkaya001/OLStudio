<!doctype html>
<html lang="en" data-theme="dark" prefix="og: http://ogp.me/ns#">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
<meta name="theme-color" content="#050505"/>

<!-- 
    CSP NOTE: 
    Strict CSP with nonces removed for GitHub Pages compatibility. 
    Static hosting cannot generate dynamic nonces. 
    Security is maintained by strict HTTPS references and sanitized inputs.
-->

<title>AnÄ±l Kaya | Econometrics Labs & Research</title>
<meta name="description" content="Advanced interactive econometrics laboratory with academic-grade diagnostics.">
<link rel="canonical" href="https://anilkaya.com/">

<!-- External Dependencies -->
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sugina-dev/latin-modern-web@1.0.1/style/latinmodern-roman.css" crossorigin="anonymous"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sugina-dev/latin-modern-web@1.0.1/style/latinmodern-sans.css" crossorigin="anonymous"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>

<style>
:root{color-scheme:dark;--font-main:"Latin Modern Roman","Times New Roman",Times,serif;--font-ui:"Latin Modern Sans","Latin Modern Roman",serif;--safe-top:env(safe-area-inset-top,0px);--safe-bottom:env(safe-area-inset-bottom,0px);--nav-h:64px;--bg:#050505;--border:rgba(255,255,255,0.10);--silver:#e8e8ea;--silver-dim:rgba(232,232,234,0.72);--gold:#D4AF37;--gold-soft:#F7E7CE}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--silver);font-family:var(--font-main);overflow-x:hidden;-webkit-font-smoothing:antialiased;}
*{box-sizing:border-box}
a{color:var(--gold-soft);text-decoration:none}
a:hover{opacity:0.9}
:focus-visible{outline:2px solid color-mix(in oklab,var(--gold) 65%,#fff);outline-offset:3px;border-radius:14px}

#nav{position:fixed;top:0;left:0;right:0;height:calc(var(--nav-h) + var(--safe-top));padding-top:var(--safe-top);padding-left:clamp(14px,4vw,44px);padding-right:clamp(14px,4vw,44px);display:flex;align-items:center;justify-content:space-between;z-index:1000;border-bottom:1px solid var(--border);background:radial-gradient(1200px 600px at 20% 30%,rgba(212,175,55,0.11),rgba(0,0,0,0.0) 60%),linear-gradient(135deg,rgba(10,10,10,0.80),rgba(18,18,18,0.58));backdrop-filter:blur(18px)}
#brand{appearance:none; border:none; background:transparent; font-family:var(--font-ui);font-size:0.92rem;font-weight:900;letter-spacing:2px;text-transform:uppercase;color:color-mix(in oklab,var(--gold) 70%,var(--silver));user-select:none;white-space:nowrap;cursor:pointer;-webkit-user-select:none; padding:0;}
#actions{display:flex;align-items:center;gap:10px}
.btn{font-family:var(--font-ui);font-size:0.75rem;letter-spacing:1.0px;text-transform:uppercase;padding:8px 10px;border-radius:12px;border:1px solid rgba(212,175,55,0.25);background:linear-gradient(135deg,rgba(18,18,18,0.58),rgba(18,18,18,0.34));color:var(--silver);cursor:pointer;backdrop-filter:blur(14px);transition:all 0.3s ease;-webkit-user-select:none;user-select:none;touch-action:manipulation;min-height: 38px; display: flex; align-items: center;}
.btn:hover{background:rgba(212,175,55,0.15);border-color:rgba(212,175,55,0.5)}

/* Lab Styles */
.lab-container { display: grid; grid-template-columns: 360px 1fr; gap: 0; height: 100%; overflow: hidden; font-family: var(--font-ui); background: transparent; }
.lab-controls { padding: 24px; background: rgba(0,0,0,0.2); border-right: 1px solid var(--border); overflow-y: auto; display: flex; flex-direction: column; gap: 20px; z-index: 10; }
.lab-main { padding: 40px 32px; overflow-y: auto; display: flex; flex-direction: column; gap: 32px; background: transparent; position: relative; z-index: 5; scroll-behavior: smooth; }
.lab-group { display: flex; flex-direction: column; gap: 8px; border-bottom:1px solid rgba(255,255,255,0.08); padding-bottom:16px; }
.lab-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1.2px; color: var(--gold); font-weight:700; }
.lab-input-row { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
.lab-slider { flex: 1; accent-color: var(--gold); cursor: pointer; height: 32px; }
.lab-select { background: rgba(255,255,255,0.05); border: 1px solid var(--border); color: var(--silver); padding: 12px; border-radius: 6px; font-family: var(--font-ui); font-size: 0.9rem; width: 100%; margin-top: 4px; cursor: pointer; }
.lab-text-input { background: rgba(255,255,255,0.05); border: 1px solid var(--border); color: var(--silver); padding: 10px; border-radius: 6px; font-family: var(--font-ui); width: 100%; font-size: 0.9rem; }
.lab-val { font-variant-numeric: tabular-nums; width: 60px; text-align: right; font-size: 0.95rem; color: var(--silver); font-weight: 600; }
.lab-hint { font-size: 0.75rem; color: var(--silver-dim); font-style: italic; margin-top: -4px; line-height: 1.2; opacity: 0.7; }

/* Premium Glass Panel (Interactive) */
.glass-panel, .lab-chart-box {
    /* Dynamic Highlight: uses --x and --y updated by JS */
    background: 
        radial-gradient(800px circle at var(--mouse-x, 50%) var(--mouse-y, 50%), rgba(212,175,55,0.08), transparent 40%),
        radial-gradient(circle at 90% 90%, rgba(232,232,234,0.05) 0%, transparent 50%),
        linear-gradient(135deg, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0.01) 100%);
    
    border: 1px solid rgba(255,255,255,0.08);
    border-top: 1px solid rgba(255,255,255,0.15);
    border-left: 1px solid rgba(255,255,255,0.12);
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    backdrop-filter: blur(24px);
    -webkit-backdrop-filter: blur(24px);
    position: relative;
    overflow: hidden;
    transition: box-shadow 0.3s ease;
}
.glass-panel:hover, .lab-chart-box:hover {
    box-shadow: 0 12px 40px rgba(0,0,0,0.4);
    border-color: rgba(212,175,55,0.3);
}

/* Chart Box Layout */
.lab-chart-box { 
    min-height: 400px; 
    display: flex; 
    flex-direction: column; 
    padding: 20px; 
    width: 100%;
}
.lab-chart-box.fullscreen { 
    position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important; 
    width: 100vw !important; height: 100dvh !important; 
    z-index: 10000 !important; 
    background: linear-gradient(135deg, #050505 0%, #111 100%); 
    padding: 20px; border-radius: 0; margin: 0; 
}
.lab-chart-box canvas { 
    flex: 1; 
    width: 100% !important; 
    height: 100% !important; 
    position: relative; 
    z-index: 1; 
    display: block;
}

.chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; position: relative; z-index: 2; flex-wrap: wrap; gap:10px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 10px; }
.chart-title { font-size: 1rem; font-weight: 700; color: var(--silver); text-transform: uppercase; letter-spacing: 1px; }
.chart-controls { display: flex; gap: 8px; align-items: center; }
.chart-toggle { font-size: 0.7rem; padding: 4px 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); color: var(--silver-dim); cursor: pointer; border-radius: 4px; transition: all 0.2s; }
.chart-toggle:hover, .chart-toggle.active { background: rgba(212,175,55,0.2); color: var(--gold); border-color: var(--gold); }

.lab-chart-row { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; min-height: 350px; }

/* Metrics & Diagnostics */
.lab-metrics-table { width: 100%; border-collapse: collapse; font-size: 0.95rem; font-variant-numeric: tabular-nums; margin-top:10px; background: rgba(0,0,0,0.2); border-radius: 8px; overflow: hidden; border: 1px solid var(--border); }
.lab-metrics-table th { text-align: left; color: var(--gold); padding: 14px; border-bottom: 1px solid var(--border); font-size: 0.8rem; text-transform: uppercase; background: rgba(255,255,255,0.03); letter-spacing: 0.5px; }
.lab-metrics-table td { padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,0.05); color: var(--silver); }
.diag-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 15px; margin-top: 20px; }
.diag-card { background: rgba(255,255,255,0.03); border: 1px solid var(--border); border-radius: 8px; padding: 15px; }
.diag-head { color: var(--gold); font-size: 0.75rem; text-transform: uppercase; font-weight: 800; letter-spacing: 1px; margin-bottom: 8px; display: block; }
.diag-val { color: var(--silver); font-size: 0.9rem; }
.diag-pass { color: #44ff88; font-weight: 700; }
.diag-fail { color: #ff4444; font-weight: 700; }
.diag-warn { color: #ffbb00; font-weight: 700; }

/* Specification Window */
.lab-spec-container { background: rgba(0,0,0,0.6); padding: 14px 20px; border-radius: 6px; border: 1px solid rgba(212,175,55,0.25); box-shadow: inset 0 0 20px rgba(255,255,255,0.02); margin-bottom: 20px; color: #fff; display: flex; flex-direction: row; align-items: center; justify-content: flex-start; gap: 15px; margin-top: 5px; flex-wrap: wrap; max-width: 100%; }
.lab-spec-title { font-family: var(--font-ui); color: var(--gold); font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1.2px; font-weight: 800; border-right: 1px solid rgba(255,255,255,0.15); padding-right: 15px; margin-right: 5px; white-space: nowrap; flex-shrink: 0; }
.lab-spec-eq { font-family: var(--font-main); font-size: 1.1rem; text-align: left; margin: 0; line-height: 1.4; flex: 1 1 auto; min-width: 200px; overflow-x: auto; overflow-y: hidden; }
.lab-spec-vec { font-family: var(--font-main); font-size: 0.95rem; color: #aaa; border-left: 1px solid rgba(255,255,255,0.1); padding-left: 15px; margin-left: auto; white-space: normal; flex: 0 1 auto; text-align: right; word-break: break-word; }
.lab-regen-btn { width: 100%; padding: 16px; background: rgba(212,175,55,0.1); border: 1px solid var(--gold); color: var(--gold); border-radius: 8px; font-weight: 700; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s; margin-bottom: 15px; font-size: 0.9rem; }
.lab-regen-btn:hover { background: rgba(212,175,55,0.25); color: #fff; }

.robustness-box { padding: 18px; background: rgba(20,20,20,0.6); border-left: 4px solid #ff4444; border-radius: 6px; font-size: 0.95rem; line-height: 1.6; color: #ffdddd; margin-top: 16px; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
.robustness-box.ok { background: rgba(20,20,20,0.6); border-left-color: #44ff88; color: #d0ffe0; }
.robustness-box.warn { background: rgba(20,20,20,0.6); border-left-color: #D4AF37; color: #f9f2d0; }
.robustness-title { font-weight: 900; text-transform: uppercase; display: block; margin-bottom: 6px; letter-spacing: 0.5px; font-size: 0.85rem; opacity: 1; }

.disclaimer-container { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin-top: 24px; }
.disclaimer-box { padding: 16px; border: 1px solid rgba(255,68,68,0.3); background: linear-gradient(135deg, rgba(40,10,10,0.6), rgba(20,5,5,0.8)); border-radius: 8px; color: #ffb3b3; font-size: 0.8rem; line-height: 1.5; text-align: justify; backdrop-filter: blur(10px); }
.disclaimer-box strong { color: #ff4444; text-transform: uppercase; display: block; margin-bottom: 6px; letter-spacing: 1px; font-weight: 800; }

.methodology-box { 
    padding: 16px; 
    border: 1px solid rgba(122,166,255,0.3); 
    background: linear-gradient(135deg, rgba(10,20,40,0.6), rgba(5,10,20,0.8)); 
    border-radius: 8px; 
    color: #b3d1ff; 
    font-size: 0.8rem; 
    line-height: 1.5; 
    text-align: justify; 
    backdrop-filter: blur(10px);
}
.methodology-box strong { color: #7aa6ff; text-transform: uppercase; display: block; margin-bottom: 6px; letter-spacing: 1px; font-weight: 800; }
.methodology-list { margin:0; padding-left:16px; }
.methodology-list li { margin-bottom: 4px; }
.methodology-list strong { display: inline; color: #e8e8ea; font-weight: 700; margin: 0; letter-spacing: 0; text-transform: none; }

@media (max-width: 900px) {
  .lab-container { display: flex; flex-direction: column; height: 100%; overflow-y: auto; }
  .lab-controls { border-right: none; border-bottom: 1px solid var(--border); flex: 0 0 auto; max-height: 40vh; overflow-y: auto; padding: 20px; }
  .lab-chart-row { grid-template-columns: 1fr; gap: 20px; }
  .lab-chart-box { min-height: 300px; }
  .lab-main { padding: 20px; overflow-y: visible; flex: 1; }
  #actions { gap: 4px; flex-wrap: wrap; justify-content: center; }
  .btn { padding: 6px 8px; font-size: 0.65rem; min-height: 32px; }
  .lab-spec-container { flex-direction: column; align-items: stretch; gap: 8px; }
  .lab-spec-title { border-right: none; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; padding-right: 0; margin-right: 0; width: 100%; text-align: center; }
  .lab-spec-vec { border-left: none; padding-left: 0; margin-left: 0; text-align: center; border-top: 1px solid rgba(255,255,255,0.1); padding-top:8px;}
  .lab-spec-eq { text-align: center; }
  .disclaimer-container { grid-template-columns: 1fr; }
}

#gl{position:fixed;inset:0;width:100%;height:100%;display:block;z-index:1;touch-action:none;user-select:none;}
#eqLayer{position:fixed;inset:0;z-index:700;pointer-events:none;overflow:hidden}
.eq{position:absolute;will-change:transform,opacity,filter;opacity:0.0;transform:translate3d(0,0,0);filter:drop-shadow(0 0 14px rgba(212,175,55,0.24));color:rgba(232,232,234,0.92);mix-blend-mode:screen}
.eq .katex{font-size:clamp(18px,2.1vw,28px)}
#depthName{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:650;pointer-events:none;font-family:var(--font-main);font-weight:300;letter-spacing:0.08em;
font-size:clamp(1.5rem,5.5vw,6.5rem); color:rgba(212,175,55,0.24);text-shadow:0 0 55px rgba(212,175,55,0.18);filter:blur(0.2px);opacity:0.95;white-space:normal;text-align:center;width:90%;max-width:800px;line-height:1.1;}
#depthName::after{content:"";position:absolute;inset:-30px -80px;background:radial-gradient(closest-side,rgba(232,232,234,0.10),rgba(0,0,0,0.0) 70%);z-index:-1;filter:blur(10px);opacity:0.55}
#orbitHint{position:fixed;inset:0;z-index:600;pointer-events:none;opacity:0.55;background:radial-gradient(circle at 50% 50%,rgba(212,175,55,0.10) 0%,rgba(212,175,55,0.06) 20%,rgba(232,232,234,0.04) 34%,rgba(0,0,0,0.0) 60%),conic-gradient(from 220deg at 50% 50%,rgba(212,175,55,0.12),rgba(122,166,255,0.06),rgba(232,232,234,0.08),rgba(212,175,55,0.12));mask:radial-gradient(circle at 50% 50%,rgba(0,0,0,0) 0 26%,rgba(0,0,0,1) 34% 42%,rgba(0,0,0,0) 60%);filter:blur(0.6px)}

#modal{position:fixed;inset:0;z-index:2000;display:none;background:rgba(0,0,0,0.65);backdrop-filter:blur(8px);touch-action:manipulation}
#modal.open{display:block}

/* Glass-morphism Modal Card (Gold & Silver Gradient) */
#modalCard {
  position: absolute; top: 0; left: 0; width: 100vw; height: 100dvh;
  border-radius: 0; border: none; overflow: hidden;
  display: grid; grid-template-rows: auto 1fr;
  /* Premium radial gradient background */
  background: radial-gradient(circle at 20% 30%, rgba(212,175,55,0.06) 0%, transparent 50%),
              radial-gradient(circle at 80% 80%, rgba(232,232,234,0.06) 0%, transparent 50%),
              linear-gradient(135deg, rgba(18,18,18,0.95), rgba(30,30,35,0.92));
  backdrop-filter: blur(40px);
  -webkit-backdrop-filter: blur(40px);
  border: 1px solid rgba(255,255,255,0.08);
}
#modalTop{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:16px 24px;border-bottom:1px solid var(--border);background:rgba(0,0,0,0.3);}
#modalMeta{font-family:var(--font-ui);color:var(--silver-dim);letter-spacing:1.2px;text-transform:uppercase;font-size:0.85rem;display:flex;gap:10px;flex-wrap:wrap;align-items:center}
#modalMeta strong{color:var(--gold);font-weight:900}
#close{border-radius:4px;border:1px solid var(--border);background:rgba(255,255,255,0.05);color:var(--silver);font-family:var(--font-ui);letter-spacing:1.2px;text-transform:uppercase;font-size:0.75rem;padding:8px 16px;cursor:pointer;transition:all 0.2s;touch-action:manipulation;font-weight:700;}
#close:focus{outline:2px solid var(--gold);outline-offset:2px;}
#close:hover{background:var(--gold); color:#000; border-color:var(--gold);}
#modalBody{overflow-y:auto;overflow-x:hidden;padding:0; -webkit-user-select:text;user-select:text;touch-action:pan-y; height: 100%;}
#modalBody::-webkit-scrollbar{width:8px;background:transparent}
#modalBody::-webkit-scrollbar-track{background:rgba(255,255,255,0.05)}
#modalBody::-webkit-scrollbar-thumb{background:#333;border-radius:4px;}
#modalBody::-webkit-scrollbar-thumb:hover{background:var(--gold)}

.article-content { padding: 40px clamp(20px, 5vw, 60px) 60px; max-width: 900px; margin: 0 auto; }
.article-content article{line-height:1.8;font-size:1.2rem;color:color-mix(in oklab, var(--silver) 88%, var(--silver-dim));text-align:justify;text-justify:inter-word}
.article-content h1,.article-content h2,.article-content h3{color:color-mix(in oklab,var(--gold-soft) 70%,var(--silver));line-height:1.15;margin:1.5rem 0 0.8rem;text-align:left}
.article-content h1{font-size:clamp(2.0rem,4vw,3.2rem);margin-top:0}
.article-content h2{font-size:clamp(1.5rem,3vw,2.2rem)}
.article-content h3{font-size:1.3rem;font-style:italic}
.article-content p{margin:0 0 1.5rem}

#err{position:fixed;inset:0;z-index:9999;display:none;padding:96px 18px 18px;background:#050505;color:#e8e8ea;font-family:var(--font-ui);-webkit-user-select:text;user-select:text;touch-action:pan-y}
#err h2{margin:0 0 12px;font-weight:900;letter-spacing:1px;color:#D4AF37;text-transform:uppercase}
#err pre{margin:12px 0 0;padding:12px;border-radius:14px;border:1px solid rgba(255,255,255,0.10);background:rgba(18,18,18,0.6);overflow:auto;max-height:55vh;white-space:pre-wrap;line-height:1.5;opacity:0.9}
</style>
</head>

<body>
<nav id="nav" aria-label="Primary">
  <button id="brand" type="button" aria-label="Reset View">AnÄ±l Kaya</button>
  <div id="actions">
    <button class="btn lab-btn" data-type="SIMULATE">Simulate</button>
    <button class="btn lab-btn" data-type="IV">IV / 2SLS</button>
    <button class="btn lab-btn" data-type="VAR">VAR</button>
    <button class="btn lab-btn" data-type="VECM">VECM</button>
    <button class="btn lab-btn" data-type="ARDL">ARDL</button>
    <button class="btn lab-btn" data-type="OU">OU Process</button>
    <button class="btn lab-btn" data-type="MCMC">MCMC</button>
    <a class="btn" href="https://www.linkedin.com/in/anillkaya" target="_blank" rel="noopener noreferrer">LinkedIn</a>
    <button class="btn" id="theme" type="button" aria-pressed="false" aria-label="Toggle theme">Light</button>
  </div>
</nav>

<canvas id="gl" aria-hidden="true"></canvas>
<div id="orbitHint" aria-hidden="true"></div>
<div id="depthName" aria-hidden="true">In Econometrics, We Trust</div>
<div id="eqLayer" aria-hidden="true"></div>

<div id="modal" role="dialog" aria-modal="true" aria-label="Content reader">
  <div id="react-app"></div>
</div>

<div id="err"><h2>Render error</h2><div>Error details:</div><pre id="errText"></pre></div>

<script>
(function(){
"use strict";

/* =========================
   SECURITY & UTILS
   ========================= */

function sanitizeHTML(str) {
    if (!str) return "";
    let safe = str.replace(/<script\b[^>]*>([\s\S]*?)<\/script>/gim, "")
                  .replace(/<(iframe|object|embed|form)\b[^>]*>([\s\S]*?)<\/\1>/gim, "");
    safe = safe.replace(/\s+on\w+="[^"]*"/gim, "")
               .replace(/\s+on\w+='[^']*'/gim, "")
               .replace(/href=["']javascript:[^"']*["']/gim, "href='#'");
    return safe;
}

const FocusTrap = {
    firstFocusable: null,
    lastFocusable: null,
    lastActive: null,
    activate: (el) => {
        FocusTrap.lastActive = document.activeElement;
        const focusable = el.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        if (focusable.length === 0) return;
        FocusTrap.firstFocusable = focusable[0];
        FocusTrap.lastFocusable = focusable[focusable.length - 1];
        FocusTrap.firstFocusable.focus();
        el.addEventListener('keydown', FocusTrap.handleKey);
    },
    deactivate: (el) => {
        el.removeEventListener('keydown', FocusTrap.handleKey);
        if (FocusTrap.lastActive) FocusTrap.lastActive.focus();
    },
    handleKey: (e) => {
        if (e.key === 'Tab') {
            if (e.shiftKey) { 
                if (document.activeElement === FocusTrap.firstFocusable) {
                    e.preventDefault();
                    FocusTrap.lastFocusable.focus();
                }
            } else { 
                if (document.activeElement === FocusTrap.lastFocusable) {
                    e.preventDefault();
                    FocusTrap.firstFocusable.focus();
                }
            }
        }
        if (e.key === 'Escape') closeModal();
    }
};

/* =========================
   MATH ENGINE
   ========================= */
const Matrix = {
  transpose: (A) => A[0].map((_, c) => A.map(r => r[c])),
  mul: (A, B) => {
    const rA = A.length, cA = A[0].length, rB = B.length, cB = B[0].length;
    if (cA !== rB) return null;
    let C = Array(rA).fill(0).map(() => Array(cB).fill(0));
    for (let i = 0; i < rA; i++) for (let j = 0; j < cB; j++) for (let k = 0; k < cA; k++) C[i][j] += A[i][k] * B[k][j];
    return C;
  },
  inv: (A) => {
     // Gaussian elimination for inversion
     const n = A.length;
     let M = A.map((row, i) => [...row, ...Array(n).fill(0).map((_, j) => i === j ? 1 : 0)]);
     for (let i = 0; i < n; i++) {
         let max = i;
         for (let k = i + 1; k < n; k++) if (Math.abs(M[k][i]) > Math.abs(M[max][i])) max = k;
         [M[i], M[max]] = [M[max], M[i]];
         const div = M[i][i];
         if (Math.abs(div) < 1e-12) return Array(n).fill(0).map(()=>Array(n).fill(0)); // Singular fallback
         for (let j = i; j < 2 * n; j++) M[i][j] /= div;
         for (let k = 0; k < n; k++) {
             if (k !== i) {
                 const mult = M[k][i];
                 for (let j = i; j < 2 * n; j++) M[k][j] -= mult * M[i][j];
             }
         }
     }
     return M.map(row => row.slice(n));
  },
  cholesky: (A) => {
      const n = A.length;
      const L = Array(n).fill(0).map(() => Array(n).fill(0));
      for (let i = 0; i < n; i++) {
          for (let j = 0; j <= i; j++) {
              let sum = 0;
              for (let k = 0; k < j; k++) sum += L[i][k] * L[j][k];
              if (i === j) {
                  const val = A[i][i] - sum;
                  if (val <= 0) L[i][j] = 1e-9; 
                  else L[i][j] = Math.sqrt(val);
              } else {
                  L[i][j] = (A[i][j] - sum) / L[j][j];
              }
          }
      }
      return L;
  },
  diag: (v) => { let n=v.length; let D=Array(n).fill(0).map(()=>Array(n).fill(0)); for(let i=0;i<n;i++) D[i][i]=v[i]; return D; }
};

const MathLab = {
  seed: 12345,
  sfc32: (a, b, c, d) => {
    return function() {
      a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0; 
      var t = (a + b) | 0; a = b ^ b >>> 9; b = c + (c << 3) | 0; c = (c << 21 | c >>> 11); d = d + 1 | 0; t = t + d | 0; c = c + t | 0; 
      return (t >>> 0) / 4294967296;
    }
  },
  rng: null, 
  sum: (arr) => arr.reduce((a,b)=>a+b, 0),
  mean: (arr) => arr.reduce((a,b)=>a+b,0)/arr.length,
  variance: (arr, m) => {
    const mean = m !== undefined ? m : MathLab.mean(arr);
    return arr.reduce((a,b)=>a+(b-mean)**2,0)/(arr.length-1);
  },
  logGamma: (z) => {
    const p = [676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
    if (z < 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - MathLab.logGamma(1 - z);
    z -= 1;
    let x = 0.99999999999980993;
    for (let i = 0; i < p.length; i++) x += p[i] / (z + i + 1);
    let t = z + p.length - 0.5;
    return Math.log(Math.sqrt(2 * Math.PI)) + Math.log(x) - t + (z + 0.5) * Math.log(t);
  },
  betaInc: (x, a, b) => {
    if (x <= 0) return 0; if (x >= 1) return 1;
    const lbeta = MathLab.logGamma(a) + MathLab.logGamma(b) - MathLab.logGamma(a + b);
    const front = Math.exp(a * Math.log(x) + b * Math.log(1 - x) - lbeta);
    if (x < (a + 1) / (a + b + 2)) return front * MathLab.betaCf(x, a, b) / a;
    else return 1.0 - front * MathLab.betaCf(1 - x, b, a) / b;
  },
  betaCf: (x, a, b) => {
    const maxIt = 100; const eps = 3.0e-7;
    let am = 1; let bm = 1; let az = 1;
    let qab = a + b; let qap = a + 1; let qam = a - 1;
    let bz = 1 - qab * x / qap;
    for (let m = 1; m <= maxIt; m++) {
        let em = m; let tem = em + em;
        let d = em * (b - m) * x / ((qam + tem) * (a + tem));
        let ap = az + d * am; let bp = bz + d * bm;
        d = -(a + em) * (qab + em) * x / ((a + tem) * (qap + tem));
        let app = ap + d * az; let bpp = bp + d * bz;
        let aold = az; am = ap; az = app; bm = bp; bz = bpp;
        if (Math.abs(bz) < Number.EPSILON) bz = Number.EPSILON; 
        if (Math.abs(bpp) > Number.EPSILON && Math.abs(app/bpp - aold/bz) < eps * Math.abs(aold/bz)) return az/bz;
    }
    return az/bz;
  },
  pValT: (t, df) => {
    const xt = df / (df + t*t);
    const p = 1 - 0.5 * MathLab.betaInc(xt, df/2, 0.5);
    const pv = 2 * (1 - p);
    return Math.max(0, Math.min(1, pv));
  },
  pValF: (f, df1, df2) => {
    if (f <= 0) return 1.0;
    const x = df2 / (df2 + df1 * f);
    const pv = MathLab.betaInc(x, df2/2, df1/2); 
    return Math.max(0, Math.min(1, pv));
  },
  pValChi2: (chi, k) => {
      if(chi <= 0 || k <= 0) return 1.0;
      return 1 - MathLab.gammp(k/2, chi/2);
  },
  gammp: (a, x) => {
      if(x < 0 || a <= 0) return 0;
      if(x < a + 1) {
          let ap = a, sum = 1/a, del = 1/a;
          for(let n=1; n<=100; n++){ ap++; del *= x/ap; sum += del; if(Math.abs(del) < 1e-7*Math.abs(sum)) break; }
          return sum * Math.exp(-x + a*Math.log(x) - MathLab.logGamma(a));
      } else {
          let gln = MathLab.logGamma(a);
          let b = x + 1 - a, c = 1/1e-30, d = 1/b, h = d;
          for(let i=1; i<=100; i++){
              let an = -i*(i-a); b += 2; d = an*d + b; if(Math.abs(d)<1e-30) d=1e-30;
              c = b + an/c; if(Math.abs(c)<1e-30) c=1e-30;
              d = 1/d; let del = d*c; h *= del;
              if(Math.abs(del-1) < 1e-7) break;
          }
          return 1 - Math.exp(-x + a*Math.log(x) - gln) * h;
      }
  },
  generateRandom: (type, params) => {
    const rng = MathLab.rng || Math.random;
    if(type === 'normal') {
      const { mean, std } = params;
      let u=0,v=0; while(u===0)u=rng(); while(v===0)v=rng();
      return mean + std * Math.sqrt(-2.0*Math.log(u)) * Math.cos(2.0*Math.PI*v);
    } else if(type === 'uniform') {
      const { min, max } = params; return min + rng()*(max-min);
    } else if(type === 't') {
      const { df, std } = params;
      let u=0,v=0; while(u===0)u=rng(); while(v===0)v=rng();
      const norm = Math.sqrt(-2.0*Math.log(u)) * Math.cos(2.0*Math.PI*v);
      let chi = 0;
      for(let i=0;i<df;i++){
         let a=0,b=0; while(a===0)a=rng(); while(b===0)b=rng();
         let z = Math.sqrt(-2.0*Math.log(a)) * Math.cos(2.0*Math.PI*b);
         chi += z*z;
      }
      return (norm / Math.sqrt(chi/df)) * std; 
    }
    return 0;
  },
  acf: (series, lag) => {
    const n = series.length; const m = MathLab.mean(series);
    let num=0, den=0;
    for(let i=0;i<n;i++) den += (series[i]-m)**2;
    for(let i=lag;i<n;i++) num += (series[i]-m)*(series[i-lag]-m);
    return den===0 ? 0 : num/den;
  },
  pacf: (series, maxLag) => {
    let acfs = []; for(let i=0;i<=maxLag;i++) acfs.push(MathLab.acf(series,i));
    let res = [1.0];
    for(let k=1; k<=maxLag; k++){
       let R = []; for(let i=0;i<k;i++){ let row = []; for(let j=0;j<k;j++) row.push(acfs[Math.abs(i-j)]); R.push(row); }
       let r = []; for(let i=1;i<=k;i++) r.push(acfs[i]);
       const sol = MathLab.solveLinear(R, r).x; res.push(sol[sol.length-1]);
    }
    return res;
  },
  solveLinear: (A, b) => {
     const n = A.length;
     const isVec = !Array.isArray(b[0]);
     const m = isVec ? 1 : b[0].length;
     let M = A.map((row, i) => [...row, ...(isVec ? [b[i]] : b[i])]);
     for (let i = 0; i < n; i++) {
        let maxRow = i; for (let k = i + 1; k < n; k++) if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;
        [M[i], M[maxRow]] = [M[maxRow], M[i]];
        const piv = M[i][i];
        if (Math.abs(piv) < 1e-12) return { x: Array(n).fill(0).map(()=>Array(m).fill(0)), singular:true };
        for (let k = i + 1; k < n; k++) { const f = M[k][i] / piv; for (let j = i; j < n + m; j++) M[k][j] -= M[i][j] * f; }
     }
     const x = Array(n).fill(0).map(()=>Array(m).fill(0));
     for (let i = n - 1; i >= 0; i--) {
        for(let col=0; col<m; col++) {
           let sum = 0; for (let j = i + 1; j < n; j++) sum += M[i][j] * x[j][col];
           x[i][col] = (M[i][n+col] - sum) / M[i][i];
        }
     }
     return { x: isVec ? x.map(r=>r[0]) : x, transpose: null, singular:false }; 
  },
  matVec2: (A, v) => {
      return [
          A[0][0]*v[0] + A[0][1]*v[1],
          A[1][0]*v[0] + A[1][1]*v[1]
      ];
  },
  
  // Adaptive Filters
  kalman: (data, R=0.01, Q=0.0001) => {
      // Simple 1D Kalman
      let xhat = data[0], P = 1.0;
      return data.map(z => {
          let xhat_minus = xhat;
          let P_minus = P + Q;
          let K = P_minus / (P_minus + R);
          xhat = xhat_minus + K * (z - xhat_minus);
          P = (1 - K) * P_minus;
          return xhat;
      });
  },
  butterworthZeroPhase: (data, cutoff) => {
      const q = Math.sqrt(2)/2; const w0 = 2 * Math.PI * cutoff; const alpha = Math.sin(w0) / (2 * q); const cosw0 = Math.cos(w0);
      const a0 = 1 + alpha; const a1_n = (-2 * cosw0)/a0, a2_n = (1 - alpha)/a0;
      const b0_n = ((1 - cosw0) / 2)/a0, b1_n = (1 - cosw0)/a0, b2_n = ((1 - cosw0) / 2)/a0;
      const filter = (arr) => {
          let y = new Array(arr.length).fill(0); y[0]=arr[0]; y[1]=arr[1];
          for(let i=2; i<arr.length; i++) y[i] = b0_n*arr[i] + b1_n*arr[i-1] + b2_n*arr[i-2] - a1_n*y[i-1] - a2_n*y[i-2];
          return y;
      };
      let fwd = filter(data);
      let rev = filter(fwd.reverse()).reverse(); 
      return rev;
  },
  sma: (data, n) => {
      let res = [];
      for(let i=0; i<data.length; i++){
          let start = Math.max(0, i-n+1), sum = 0, count = 0;
          for(let j=start; j<=i; j++) { sum += data[j]; count++; }
          res.push(sum/count);
      }
      return res;
  },
  ema: (data, n) => {
      let res = [data[0]]; const k = 2/(n+1);
      for(let i=1; i<data.length; i++) res.push(data[i]*k + res[i-1]*(1-k));
      return res;
  },
  kde: (data, bandwidth) => {
      // Gaussian kernel
      const kernel = (u) => (1/Math.sqrt(2*Math.PI)) * Math.exp(-0.5 * u*u);
      return (x) => (1 / (data.length * bandwidth)) * data.reduce((sum, xi) => sum + kernel((x - xi) / bandwidth), 0);
  },

  // Granger Causality F-Test
  grangerTest: (y1, y2, lags) => {
    const n = y1.length;
    let X_r = [], X_u = [], Y = [];
    for(let t = lags; t < n; t++) {
      Y.push(y1[t]);
      let row_r = [1], row_u = [1];
      for(let l = 1; l <= lags; l++) { row_r.push(y1[t-l]); row_u.push(y1[t-l]); row_u.push(y2[t-l]); }
      X_r.push(row_r); X_u.push(row_u);
    }
    const res_r = MathLab.olsMultivariate(Y, X_r);
    const res_u = MathLab.olsMultivariate(Y, X_u);
    const k_r = X_r[0].length, k_u = X_u[0].length;
    const fStat = ((res_r.ssr - res_u.ssr) / (k_u - k_r)) / (res_u.ssr / (Y.length - k_u));
    return { fStat, df1: k_u - k_r, df2: Y.length - k_u };
  },
  // Statistics Module
  stats: {
      skewness: (arr) => {
          const n = arr.length, m = MathLab.mean(arr), s = Math.sqrt(MathLab.variance(arr, m));
          let sum=0; for(let x of arr) sum += Math.pow((x-m)/s, 3);
          return (n/((n-1)*(n-2))) * sum;
      },
      kurtosis: (arr) => {
          const n = arr.length, m = MathLab.mean(arr), s = Math.sqrt(MathLab.variance(arr, m));
          let sum=0; for(let x of arr) sum += Math.pow((x-m)/s, 4);
          return (n*(n+1)/((n-1)*(n-2)*(n-3))) * sum - (3*Math.pow(n-1,2)/((n-2)*(n-3)));
      },
      jarqueBera: (resid) => {
          const n = resid.length;
          const S = MathLab.stats.skewness(resid);
          const K = MathLab.stats.kurtosis(resid); 
          const JB = (n/6) * (S*S + (K*K)/4);
          const p = MathLab.pValChi2(JB, 2);
          return { stat: JB, p };
      },
      breuschPagan: (resid, X) => {
          const e2 = resid.map(r => r*r);
          const aux = MathLab.olsMultivariate(e2, X);
          const SST = MathLab.variance(e2) * (resid.length-1);
          const R2 = 1 - (aux.ssr / SST);
          const LM = resid.length * R2;
          const df = X[0].length - 1;
          const p = MathLab.pValChi2(LM, df);
          return { stat: LM, p };
      },
      ljungBox: (resid, lags=10) => {
          const n = resid.length;
          let Q = 0;
          for(let k=1; k<=lags; k++){ const rk = MathLab.acf(resid, k); Q += (rk*rk) / (n-k); }
          Q *= n*(n+2);
          const p = MathLab.pValChi2(Q, lags);
          return { stat: Q, p };
      }
  },
  ols: (x, y) => {
    const n = x.length; const mx = MathLab.mean(x); const my = MathLab.mean(y);
    let num=0, den=0; for(let i=0;i<n;i++){ num += (x[i]-mx)*(y[i]-my); den += (x[i]-mx)**2; }
    const beta = num/den; const alpha = my - beta*mx;
    const yhat = x.map(xi => alpha + beta*xi);
    const resid = y.map((yi,i) => yi - yhat[i]);
    const ssr = resid.reduce((a,b)=>a+b**2, 0); const sst = y.reduce((a,b)=>a+(b-my)**2, 0);
    const r2 = 1 - (ssr/sst); const sigma2 = ssr/(n-2); const seBeta = Math.sqrt(sigma2/den);
    const tStat = beta/seBeta; const pVal = MathLab.pValT(tStat, n-2);
    return { alpha, beta, r2, tStat, pVal, seBeta, resid, yhat, sigma2, n, sigma2 };
  },
  olsMultivariate: (y, X) => {
    const n = y.length; const k = X[0].length;
    let XtX = Array(k).fill(0).map(()=>Array(k).fill(0)); let Xty = Array(k).fill(0);
    for(let i=0; i<n; i++){
        for(let r=0; r<k; r++){ Xty[r] += X[i][r] * y[i]; for(let c=0; c<k; c++){ XtX[r][c] += X[i][r] * X[i][c]; } }
    }
    const XtX_inv = Matrix.inv(XtX);
    const beta = MathLab.solveLinear(XtX, Xty).x;
    const resid = []; let ssr = 0;
    for(let i=0; i<n; i++){
        let yh = 0; for(let j=0; j<k; j++) yh += X[i][j] * beta[j];
        const e = y[i] - yh; resid.push(e); ssr += e*e;
    }
    // Classical Variance for OLS
    const sigma2 = ssr/(n-k);
    const ClassicCov = XtX_inv.map(row => row.map(v => v * sigma2));
    
    return { beta, resid, ClassicCov, ssr, n, k, XtX_inv };
  },
  iv2sls: (y, x, z) => {
    const n = y.length;
    // Matrices
    const Y_vec = y.map(v => [v]);
    const X_mat = x.map(v => [1, v]); // Intercept + Endog
    const Z_mat = z.map(v => [1, v]); // Intercept + Inst

    // 1. First Stage: X = Z * Pi + v
    const Zt = Matrix.transpose(Z_mat);
    const ZtZ = Matrix.mul(Zt, Z_mat);
    const ZtZ_inv = Matrix.inv(ZtZ);
    const ZtX = Matrix.mul(Zt, X_mat);
    const Pi = Matrix.mul(ZtZ_inv, ZtX); // 2x2
    const X_hat = Matrix.mul(Z_mat, Pi); // Predicted X

    // 2. Second Stage: y = X_hat * Beta + e
    const Xht = Matrix.transpose(X_hat);
    const XhtXh = Matrix.mul(Xht, X_hat);
    const XhtXh_inv = Matrix.inv(XhtXh);
    const XhtY = Matrix.mul(Xht, Y_vec);
    const Beta = Matrix.mul(XhtXh_inv, XhtY);
    const betaVals = Beta.map(row => row[0]);

    // 3. Structural Residuals: u = y - X * Beta (Original X!)
    let u = [];
    for(let i=0; i<n; i++){
        const y_est = X_mat[i][0]*betaVals[0] + X_mat[i][1]*betaVals[1];
        u.push(y[i] - y_est);
    }

    // 4. Robust Covariance (Sandwich)
    // Bread = (X_hat' X_hat)^-1  (= XhtXh_inv)
    // Meat = X_hat' * diag(u^2) * X_hat
    let Meat = [[0,0], [0,0]];
    for(let i=0; i<n; i++){
        const u2 = u[i]*u[i];
        for(let r=0; r<2; r++){
            for(let c=0; c<2; c++){
                Meat[r][c] += X_hat[i][r] * X_hat[i][c] * u2;
            }
        }
    }
    const BM = Matrix.mul(XhtXh_inv, Meat);
    const V = Matrix.mul(BM, XhtXh_inv);
    const dfCorr = n / (n - 2);
    const seBeta = Math.sqrt(V[1][1] * dfCorr);

    // First Stage F-stat (Reduced Form on Z)
    // Regress x on Z, test Z coeff.
    let v_hat = [];
    let ssr_v = 0;
    for(let i=0; i<n; i++){
        const x_pred = Z_mat[i][0]*Pi[0][1] + Z_mat[i][1]*Pi[1][1]; 
        const err = x[i] - x_pred;
        v_hat.push(err);
        ssr_v += err*err;
    }
    const sigma2_v = ssr_v / (n-2);
    const VarPi = ZtZ_inv.map(row => row.map(val => val * sigma2_v));
    const sePi1 = Math.sqrt(VarPi[1][1]);
    const fStat = Math.pow(Pi[1][1] / sePi1, 2);

    // DWH (Hausman)
    // Regress y on X, v_hat. Test v_hat coeff.
    // X_aug = [1, x, v_hat]
    let X_aug = [];
    for(let i=0; i<n; i++) X_aug.push([1, x[i], v_hat[i]]);
    const dwhRes = MathLab.olsMultivariate(y, X_aug);
    const t_v = dwhRes.beta[2] / Math.sqrt(dwhRes.ClassicCov[2][2]);
    const p_dwh = MathLab.pValT(t_v, n-3);

    return { 
        beta: betaVals[1], alpha: betaVals[0], 
        seBeta, tStat: betaVals[1]/seBeta, 
        resid: u, fitStruct: x.map(xi => betaVals[0] + betaVals[1]*xi), 
        fStat1: fStat, 
        dwhStat: t_v, dwhP: p_dwh 
    };
  }
};

/* =========================
   LAB LOGIC
   ========================= */
const Lab = {
  chartInstances: [],
  state: { 
      distType: 'normal', distDf: 5, seed: 12345, showCI: false, instRel: 0.8, endog: 0.5, 
      ouMean: 0, ouTheta: 0.5, ouSigma: 0.5, mcmcIter: 2000, bootstrap: false, varNoise: 1, constTerm: 0,
      riskAlpha: 0.99, riskMCMC: 2000, simMu: 0.0005, simSigma: 0.015,
      // Filters state
      showSMA: false, showEMA: false, showKalman: true, showButter: true, showChannels: true
  },
  
  open: (type) => {
    try {
        modal.classList.add("open");
        const s = Lab.state.seed;
        MathLab.rng = MathLab.sfc32(s, s+1, s+2, s+3);
        Lab.renderUI(type);
        const m = document.getElementById("modal");
        FocusTrap.activate(m);
        // Start mouse tracker
        Lab.initMouseTracker();
    } catch(e) { showErr(e); }
  },

  initMouseTracker: () => {
      document.addEventListener('mousemove', (e) => {
          document.querySelectorAll('.glass-panel, .lab-chart-box').forEach(card => {
              const rect = card.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              card.style.setProperty('--mouse-x', `${x}px`);
              card.style.setProperty('--mouse-y', `${y}px`);
          });
      });
  },

  renderUI: (type) => {
    const html = `
      <div id="modalCard">
         <div id="modalTop">
           <div id="modalMeta"><strong>Interactive Lab</strong><span>â€¢</span><span>${type}</span></div>
           <button id="close" aria-label="Close Modal">Close &times;</button>
         </div>
         <div id="modalBody">
            <div class="lab-container">
               <div class="lab-controls" id="labControls"></div>
               <div class="lab-main" id="labMain"></div>
            </div>
         </div>
      </div>
    `;
    modal.innerHTML = html;
    document.getElementById("close").onclick = closeModal;
    
    Chart.defaults.color = '#c0c0c0';
    Chart.defaults.borderColor = 'rgba(255,255,255,0.1)';
    Chart.defaults.scale.grid.display = false;
    
    Lab.chartInstances.forEach(c => c.destroy());
    Lab.chartInstances = [];

    if(type === 'IV') Lab.initIV();
    if(type === 'VAR') Lab.initVAR();
    if(type === 'VECM') Lab.initVECM();
    if(type === 'ARDL') Lab.initARDL();
    if(type === 'OU') Lab.initOU();
    if(type === 'MCMC') Lab.initMCMC();
    if(type === 'SIMULATE') Lab.initRisk();
    
    Lab.renderMath();
  },
  
  renderMath: () => {
    setTimeout(() => { 
        if(window.renderMathInElement) {
            window.renderMathInElement(document.getElementById("modalBody"), {
                delimiters: [ {left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false} ]
            });
        }
    }, 100);
  },

  createControl: (label, id, min, max, step, val, hint, onChange) => {
    const div = document.createElement("div");
    div.className = "lab-group";
    div.innerHTML = `
      <div class="lab-input-row"><span class="lab-label">${label}</span><span class="lab-val" id="val_${id}">${val}</span></div>
      <div class="lab-hint">${hint}</div>
      <input type="range" id="${id}" class="lab-slider" min="${min}" max="${max}" step="${step}" value="${val}">
    `;
    div.querySelector("input").addEventListener("input", (e) => {
      document.getElementById(`val_${id}`).textContent = e.target.value;
      onChange(parseFloat(e.target.value));
    });
    return div;
  },

  createDistSelector: (onUpdate) => {
    const div = document.createElement("div");
    div.className = "lab-group";
    div.innerHTML = `
      <span class="lab-label">Stochastic Error Process</span>
      <select id="distSelect" class="lab-select">
        <option value="normal">Normal (Gaussian)</option>
        <option value="t">Student-t (Fat Tails)</option>
        <option value="uniform">Uniform</option>
      </select>
      <div id="dfControl" style="display:none; margin-top:5px;">
        <div class="lab-input-row"><span class="lab-label">Deg. Freedom</span><span class="lab-val" id="val_df">5</span></div>
        <input type="range" id="dfRange" class="lab-slider" min="3" max="30" step="1" value="5">
      </div>
      <div style="margin-top:8px;">
         <span class="lab-label">RNG Seed</span>
         <div style="display:flex; gap:5px;">
             <input type="number" id="seedVal" value="${Lab.state.seed}" class="lab-select" style="width:100%">
             <button id="randSeed" class="btn" style="min-width:auto; padding:0 12px;">ðŸŽ²</button>
         </div>
      </div>
    `;
    const sel = div.querySelector("select");
    const dfC = div.querySelector("#dfControl");
    const dfR = div.querySelector("#dfRange");
    const seedIn = div.querySelector("#seedVal");
    const randBtn = div.querySelector("#randSeed");
    
    sel.addEventListener("change", (e)=>{
        Lab.state.distType = e.target.value;
        dfC.style.display = (e.target.value === 't') ? 'block' : 'none';
        onUpdate();
    });
    dfR.addEventListener("input", (e)=>{
        document.getElementById("val_df").innerText = e.target.value;
        Lab.state.distDf = parseInt(e.target.value);
        onUpdate();
    });
    seedIn.addEventListener("change", (e)=>{
        Lab.state.seed = parseInt(e.target.value);
        onUpdate();
    });
    randBtn.onclick = () => {
        const s = Math.floor(Math.random() * 100000);
        seedIn.value = s;
        Lab.state.seed = s;
        onUpdate();
    };
    return div;
  },

  generateButton: (txt, onClick) => {
    const btn = document.createElement("button");
    btn.className = "lab-regen-btn";
    btn.innerText = txt;
    btn.onclick = onClick;
    return btn;
  },
  
  renderACFPACF: (resid, containerId, titleSuffix) => {
    const lags = 12;
    let acfVal = [];
    let pacfVal = MathLab.pacf(resid, lags).slice(1);
    for(let i=1;i<=lags;i++) acfVal.push(MathLab.acf(resid, i));

    const ctx = document.getElementById(containerId).getContext('2d');
    const labels = Array.from({length:lags}, (_,i)=>i+1);
    const crit = 1.96 / Math.sqrt(resid.length);
    const critArrPos = new Array(lags).fill(crit);
    const critArrNeg = new Array(lags).fill(-crit);

    if(Chart.getChart(containerId)) Chart.getChart(containerId).destroy();

    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                { label: 'ACF', data: acfVal, backgroundColor: 'rgba(212,175,55,0.9)', barPercentage: 0.6 },
                { label: 'PACF', data: pacfVal, backgroundColor: 'rgba(122,166,255,0.9)', barPercentage: 0.6 },
                { label: '95% CI', data: critArrPos, type:'line', borderColor:'rgba(255,255,255,0.4)', pointRadius:0, borderWidth:1, borderDash:[5,5] },
                { label: '95% CI', data: critArrNeg, type:'line', borderColor:'rgba(255,255,255,0.4)', pointRadius:0, borderWidth:1, borderDash:[5,5] }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { title: { display: true, text: `ACF & PACF ${titleSuffix}`, color: '#e8e8ea', font: {size:14} }, legend: {display:false} },
            scales: { y: { min: -1, max: 1, grid:{display:false} }, x: { grid:{display:false} } }
        }
    });
  },

  updateSpecPanel: (eq, vec) => {
     document.getElementById("labSpecContainer").innerHTML = `
        <div class="lab-spec-title">Model Specification</div>
        <div class="lab-spec-eq">${eq}</div>
        <div class="lab-spec-vec">${vec}</div>
     `;
  },

  // --- IV LAB ---
  initIV: () => {
    Lab.state = { ...Lab.state, beta0: 10, beta1: 1.5, n: 200, endog: 0.7, instRel: 0.8 };
    const controls = document.getElementById("labControls");
    const main = document.getElementById("labMain");
    
    controls.appendChild(Lab.generateButton("Simulate New Data", Lab.updateIV));
    controls.appendChild(Lab.createDistSelector(Lab.updateIV));
    controls.appendChild(Lab.createControl("Endogeneity (Corr X,u)", "endog", -0.9, 0.9, 0.1, 0.7, "Degree of correlation between regressor and error term.", v=>{Lab.state.endog=v; Lab.updateIV();}));
    controls.appendChild(Lab.createControl("First Stage Coeff ($\pi_1$)", "instRel", 0, 0.9, 0.1, 0.8, "Impact of Z on X. Low values imply Weak IV.", v=>{Lab.state.instRel=v; Lab.updateIV();}));
    controls.appendChild(Lab.createControl("True Slope (Î²â‚)", "b1", 0, 3, 0.1, 1.5, "Structural Parameter to estimate.", v=>{Lab.state.beta1=v; Lab.updateIV();}));
    controls.appendChild(Lab.createControl("Sample Size (N)", "n", 50, 2000, 50, 200, "Number of observations.", v=>{Lab.state.n=v; Lab.updateIV();}));

    main.innerHTML = `
      <div class="lab-spec-container" id="labSpecContainer"></div>
      <div class="lab-chart-box"><canvas id="ivChart"></canvas></div>
      <div class="lab-chart-row">
        <div class="lab-chart-box"><canvas id="residChart"></canvas></div>
        <div class="lab-chart-box"><canvas id="ivACF"></canvas></div>
      </div>
      <div class="lab-chart-box" style="min-height:auto; height:auto; padding:0; background:transparent; border:none; box-shadow:none;"><div id="ivMetrics"></div></div>
      <div id="ivDiagnostics"></div>
    `;
    Lab.updateIV();
  },

  updateIV: () => {
    MathLab.rng = MathLab.sfc32(Lab.state.seed, Lab.state.seed*2, Lab.state.seed*3, Lab.state.seed*4); 
    const { beta0, beta1, n, endog, instRel } = Lab.state;
    let x = [], y = [], z = [];
    
    for(let i=0; i<n; i++){
        let u = MathLab.generateRandom(Lab.state.distType, {mean:0, std:1, df:Lab.state.distDf});
        let v_indep = MathLab.generateRandom(Lab.state.distType, {mean:0, std:1, df:Lab.state.distDf});
        let v = endog * u + Math.sqrt(Math.max(0, 1 - endog*endog)) * v_indep;
        
        let zi = MathLab.generateRandom('normal', {mean:0, std:1});
        let xi = instRel * zi + v;
        let yi = beta0 + beta1 * xi + u;
        x.push(xi); y.push(yi); z.push(zi);
    }
    
    const olsEst = MathLab.ols(x, y);
    const ivEst = MathLab.iv2sls(y, x, z);
    const jb = MathLab.stats.jarqueBera(ivEst.resid);
    const bp = MathLab.stats.breuschPagan(ivEst.resid, z.map(zi=>[1,zi]));
    
    Lab.updateSpecPanel(
      `$$ Y = \\beta_0 + \\beta_1 X + u $$ <br> $$ X = \\pi_0 + \\pi_1 Z + v $$`,
      `$$ \\hat{\\beta}_{OLS} = ${olsEst.beta.toFixed(3)}, \\quad \\hat{\\beta}_{2SLS} = ${ivEst.beta.toFixed(3)} $$`
    );

    document.getElementById("ivMetrics").innerHTML = `
      <table class="lab-metrics-table">
        <thead><tr><th>Estimator</th><th>$\\hat{\\beta}_1$</th><th>Robust SE</th><th>Bias</th><th>t-Stat</th></tr></thead>
        <tbody>
          <tr><td>OLS (Biased)</td><td>${olsEst.beta.toFixed(4)}</td><td>${olsEst.seBeta.toFixed(4)}</td><td style="color:${Math.abs(olsEst.beta-beta1)>0.2?'#ff4444':'#888'}">${(olsEst.beta-beta1).toFixed(3)}</td><td>${olsEst.tStat.toFixed(2)}</td></tr>
          <tr><td>2SLS (Consistent)</td><td>${ivEst.beta.toFixed(4)}</td><td>${ivEst.seBeta.toFixed(4)}</td><td style="color:#44ff88">${(ivEst.beta-beta1).toFixed(3)}</td><td>${ivEst.tStat.toFixed(2)}</td></tr>
        </tbody>
      </table>
    `;
    
    const weakColor = ivEst.fStat1 < 10 ? 'fail' : 'pass';
    
    document.getElementById("ivDiagnostics").innerHTML = `
       <div class="diag-grid">
         <div class="diag-card"><span class="diag-head">Instrument Strength</span><div class="diag-val">First Stage F: <span class="diag-${weakColor}">${ivEst.fStat1.toFixed(2)}</span></div><div class="diag-val">Rule of Thumb: > 10</div></div>
         <div class="diag-card"><span class="diag-head">Endogeneity (Hausman)</span><div class="diag-val">Robust t: ${ivEst.dwhStat.toFixed(2)}</div><div class="diag-val">p-value: ${ivEst.dwhP.toFixed(3)}</div></div>
         <div class="diag-card"><span class="diag-head">Normality (JB)</span><div class="diag-val">Stat: ${jb.stat.toFixed(2)}</div><div class="diag-val">p-value: ${jb.p.toFixed(3)}</div></div>
         <div class="diag-card"><span class="diag-head">Heteroskedasticity (BP)</span><div class="diag-val">Stat: ${bp.stat.toFixed(2)}</div><div class="diag-val">p-value: ${bp.p.toFixed(3)}</div></div>
       </div>
    `;

    const minX = Math.min(...x), maxX = Math.max(...x);
    const lineOLS = [{x: minX, y: olsEst.alpha + olsEst.beta*minX}, {x: maxX, y: olsEst.alpha + olsEst.beta*maxX}];
    const lineIV = [{x: minX, y: ivEst.alpha + ivEst.beta*minX}, {x: maxX, y: ivEst.alpha + ivEst.beta*maxX}];
    
    if(Lab.chartInstances[0]) Lab.chartInstances[0].destroy();
    Lab.chartInstances[0] = new Chart(document.getElementById('ivChart').getContext('2d'), {
         type: 'scatter',
         data: { datasets: [
             { label: 'Observed', data: x.map((v,i)=>({x:v,y:y[i]})), backgroundColor: 'rgba(255,255,255,0.1)', pointRadius:3 },
             { label: 'OLS', data: lineOLS, type:'line', borderColor: '#ff4444', borderWidth:2, pointRadius:0, fill:false },
             { label: '2SLS', data: lineIV, type:'line', borderColor: '#44ff88', borderWidth:3, pointRadius:0, fill:false }
         ]},
         options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: '2SLS vs OLS Estimates', color:'#e8e8ea', font:{size:16} }, legend:{labels:{color:'#bbb'}} }, scales: { x: { grid:{display:false}, ticks:{color:'#888'} }, y:{grid:{display:false}, ticks:{color:'#888'}} } }
    });

    if(Lab.chartInstances[1]) Lab.chartInstances[1].destroy();
    Lab.chartInstances[1] = new Chart(document.getElementById('residChart').getContext('2d'), {
         type: 'scatter',
         data: { datasets: [{ label: 'Resid vs Fit', data: ivEst.fitStruct.map((f,i)=>({x:f, y:ivEst.resid[i]})), backgroundColor: 'rgba(212,175,55,0.4)', pointRadius:2 }] },
         options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Residuals vs Fitted', color:'#e8e8ea' } }, scales:{ x:{grid:{display:false}, title:{display:true,text:'Fitted Values'}}, y:{grid:{display:false}} } }
    });

    Lab.renderACFPACF(ivEst.resid, 'ivACF', '(IV Residuals)');
    Lab.renderMath();
  },

  // --- VAR LAB ---
  initVAR: () => {
    Lab.state = { ...Lab.state, a11: 0.7, a12: 0.2, a21: 0.1, a22: 0.6, lag: 1, T: 100, noise: 1, shockSize: 1, rho: 0, constTerm: 0.5 };
    const controls = document.getElementById("labControls");
    const main = document.getElementById("labMain");
    
    controls.appendChild(Lab.generateButton("Simulate System", Lab.updateVAR));
    controls.appendChild(Lab.createDistSelector(Lab.updateVAR));
    controls.appendChild(Lab.createControl("A[1,1]", "a11", -1.2, 1.2, 0.05, 0.7, "Impact of Y1(t-1) on Y1(t).", v=>{Lab.state.a11=v; Lab.updateVAR();}));
    controls.appendChild(Lab.createControl("A[1,2]", "a12", -1, 1, 0.05, 0.2, "Impact of Y2(t-1) on Y1(t).", v=>{Lab.state.a12=v; Lab.updateVAR();}));
    controls.appendChild(Lab.createControl("A[2,1]", "a21", -1, 1, 0.05, 0.1, "Impact of Y1(t-1) on Y2(t).", v=>{Lab.state.a21=v; Lab.updateVAR();}));
    controls.appendChild(Lab.createControl("A[2,2]", "a22", -1.2, 1.2, 0.05, 0.6, "Impact of Y2(t-1) on Y2(t).", v=>{Lab.state.a22=v; Lab.updateVAR();}));
    controls.appendChild(Lab.createControl("Error Corr (Ï)", "rho", -0.9, 0.9, 0.1, 0, "Correlation between structural shocks.", v=>{Lab.state.rho=v; Lab.updateVAR();}));
    controls.appendChild(Lab.createControl("Shock Size", "shockSize", 0.5, 5, 0.5, 1, "Size of unit impulse.", v=>{Lab.state.shockSize=v; Lab.updateVAR();}));
    
    main.innerHTML = `
      <div class="lab-spec-container" id="labSpecContainer"></div>
      <div class="lab-chart-box"><canvas id="varSeries"></canvas></div>
      <div class="lab-chart-row">
         <div class="lab-chart-box"><canvas id="varIRF"></canvas></div>
         <div class="lab-chart-box"><canvas id="varRoots"></canvas></div>
      </div>
      <div class="lab-chart-box" style="min-height:auto; height:auto; padding:0; background:transparent; border:none; box-shadow:none;"><div id="varMetrics"></div></div>
      <div id="varDiagnostics"></div>
    `;
    Lab.updateVAR();
  },

  updateVAR: () => {
    try {
        MathLab.rng = MathLab.sfc32(Lab.state.seed, Lab.state.seed, Lab.state.seed, Lab.state.seed);
        const { a11, a12, a21, a22, T, noise, shockSize, rho, constTerm } = Lab.state;

        let y1 = [0], y2 = [0];
        for(let t=1; t<T; t++){
           let u1 = MathLab.generateRandom(Lab.state.distType, {mean:0, std:noise, df:Lab.state.distDf});
           let u2_indep = MathLab.generateRandom(Lab.state.distType, {mean:0, std:noise, df:Lab.state.distDf});
           let u2 = rho * u1 + Math.sqrt(Math.max(0, 1 - rho*rho)) * u2_indep;
           let ny1 = constTerm + a11*y1[t-1] + a12*y2[t-1] + u1;
           let ny2 = constTerm + a21*y1[t-1] + a22*y2[t-1] + u2;
           y1.push(ny1); y2.push(ny2);
        }
        
        let Y = [], X = [];
        for(let t=1; t<T; t++) { Y.push([y1[t], y2[t]]); X.push([1, y1[t-1], y2[t-1]]); }
        let Y1 = Y.map(r=>r[0]), Y2 = Y.map(r=>r[1]);
        let est1 = MathLab.olsMultivariate(Y1, X);
        let est2 = MathLab.olsMultivariate(Y2, X);
        
        let hatA = [[est1.beta[1], est1.beta[2]], [est2.beta[1], est2.beta[2]]];
        let res1 = est1.resid;
        let n = res1.length;
        
        // Stability
        let tr = hatA[0][0] + hatA[1][1];
        let det = hatA[0][0]*hatA[1][1] - hatA[0][1]*hatA[1][0];
        let disc = tr*tr - 4*det;
        let r1, r2, i1=0, i2=0;
        if (disc >= 0) { r1 = (tr + Math.sqrt(disc))/2; r2 = (tr - Math.sqrt(disc))/2; } 
        else { r1 = tr/2; r2 = tr/2; i1 = Math.sqrt(-disc)/2; i2 = -Math.sqrt(-disc)/2; }
        let maxMod = Math.max(Math.sqrt(r1*r1+i1*i1), Math.sqrt(r2*r2+i2*i2));
        const isStable = maxMod < 1.0;

        // IRF - Corrected via Cholesky
        let s11=0, s12=0, s22=0;
        for(let i=0; i<n; i++){ s11+=res1[i]**2; s22+=est2.resid[i]**2; s12+=res1[i]*est2.resid[i]; }
        let Sigma = [[s11/n, s12/n], [s12/n, s22/n]];
        // Cholesky L * L' = Sigma
        let L = Matrix.cholesky(Sigma);
        // Shock vector = L * [1, 0]' * shockSize = [L11, L21] * shockSize
        let shockVec = [L[0][0] * shockSize, L[1][0] * shockSize];
        
        let irf1 = [shockVec[0]], irf2 = [shockVec[1]];
        let curr = [shockVec[0], shockVec[1]];
        for(let h=1; h<=20; h++){ curr = MathLab.matVec2(hatA, curr); irf1.push(curr[0]); irf2.push(curr[1]); }
        
        // Diagnostics
        const grangerRes = MathLab.grangerTest(y1, y2, 1);
        const jb1 = MathLab.stats.jarqueBera(res1);
        const lb1 = MathLab.stats.ljungBox(res1, 5);
        
        // AIC/BIC (Approximate)
        const k = 6 + 3; // +3 for Sigma params
        const detSigma = Sigma[0][0]*Sigma[1][1] - Sigma[0][1]*Sigma[1][0];
        const logLik = -n/2 * Math.log(detSigma); 
        const aic = -2*logLik + 2*k;
        const bic = -2*logLik + k*Math.log(n);

        Lab.updateSpecPanel(
          `$$ \\hat{Y}_t = \\hat{C} + \\hat{A} Y_{t-1} + u_t $$`,
          `$$ \\hat{A} = \\begin{bmatrix} ${hatA[0][0].toFixed(2)} & ${hatA[0][1].toFixed(2)} \\\\ ${hatA[1][0].toFixed(2)} & ${hatA[1][1].toFixed(2)} \\end{bmatrix} $$`
        );

        document.getElementById("varMetrics").innerHTML = `
          <table class="lab-metrics-table">
            <thead><tr><th>Metric</th><th>Value</th><th>Interpretation</th></tr></thead>
            <tbody>
              <tr><td>Max Eigenvalue Modulus</td><td>${maxMod.toFixed(4)}</td><td>${isStable ? "Stable (<1)" : "Unstable"}</td></tr>
              <tr><td>System AIC</td><td>${aic.toFixed(1)}</td><td>Information Criterion (Approx)</td></tr>
              <tr><td>System BIC</td><td>${bic.toFixed(1)}</td><td>Information Criterion (Approx)</td></tr>
            </tbody>
          </table>
        `;
        
        document.getElementById("varDiagnostics").innerHTML = `
           <div class="diag-grid">
             <div class="diag-card"><span class="diag-head">Serial Correlation (Eq 1)</span><div class="diag-val">Ljung-Box Q(5): ${lb1.stat.toFixed(2)}</div><div class="diag-val">p-value: ${lb1.p.toFixed(3)}</div></div>
             <div class="diag-card"><span class="diag-head">Normality (Eq 1)</span><div class="diag-val">Jarque-Bera: ${jb1.stat.toFixed(2)}</div><div class="diag-val">p-value: ${jb1.p.toFixed(3)}</div></div>
             <div class="diag-card"><span class="diag-head">Granger Causality</span><div class="diag-val">Y2 -> Y1 F-stat: ${grangerRes.fStat.toFixed(2)}</div><div class="diag-val">p-value: ${MathLab.pValF(grangerRes.fStat, grangerRes.df1, grangerRes.df2).toFixed(3)}</div></div>
           </div>
        `;

        if(Lab.chartInstances[0]) Lab.chartInstances[0].destroy();
        Lab.chartInstances[0] = new Chart(document.getElementById('varSeries').getContext('2d'), {
             type: 'line',
             data: { labels: Array.from({length: T}, (_, i) => i), datasets: [{ label: 'Y1', data: y1, borderColor: '#D4AF37', borderWidth:1.5, pointRadius:0 }, { label: 'Y2', data: y2, borderColor: '#7aa6ff', borderWidth:1.5, pointRadius:0 }] },
             options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Simulated Data', color:'#e8e8ea' } }, scales:{ x:{grid:{display:false}}, y:{grid:{display:false}} } }
        });

        if(Lab.chartInstances[1]) Lab.chartInstances[1].destroy();
        Lab.chartInstances[1] = new Chart(document.getElementById('varIRF').getContext('2d'), {
             type: 'line',
             data: { labels: Array.from({length: 21}, (_, i) => i), datasets: [{ label: 'Response of Y1', data: irf1, borderColor: '#D4AF37' }, { label: 'Response of Y2', data: irf2, borderColor: '#7aa6ff' }] },
             options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: `Orthogonalized Impulse Response (Cholesky Y1 Shock)`, color:'#e8e8ea' } }, scales:{ x:{grid:{display:false}}, y:{grid:{display:false}} } }
        });
        
        if(Lab.chartInstances[2]) Lab.chartInstances[2].destroy();
        Lab.chartInstances[2] = new Chart(document.getElementById('varRoots').getContext('2d'), {
            type: 'scatter',
            data: {
                datasets: [
                    { label: 'Eigenvalues', data: [{x:r1, y:i1}, {x:r2, y:i2}], backgroundColor: '#ff4444', pointRadius: 6 },
                    { label: 'Unit Circle', data: Array.from({length:64}, (_,i)=>{const a=i/63*Math.PI*2; return {x:Math.cos(a), y:Math.sin(a)}}), type:'line', borderColor:'rgba(255,255,255,0.2)', borderWidth:1, pointRadius:0, fill:false }
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: { title: { display: true, text: 'Eigenvalues of Companion Matrix', color:'#e8e8ea' }, legend:{display:false} },
                scales: { x: { min:-1.5, max:1.5, grid:{color:'rgba(255,255,255,0.1)'} }, y: { min:-1.5, max:1.5, grid:{color:'rgba(255,255,255,0.1)'} } },
                aspectRatio: 1
            }
        });
        
        Lab.renderMath();
    } catch(e) { showErr(e); }
  },

  // --- VECM LAB ---
  initVECM: () => {
    Lab.state = { ...Lab.state, vecmBeta: 2.0, alphaY: -0.3, alphaX: 0.1, n: 200, noise: 1 };
    const controls = document.getElementById("labControls");
    const main = document.getElementById("labMain");
    
    controls.appendChild(Lab.generateButton("Simulate System", Lab.updateVECM));
    controls.appendChild(Lab.createDistSelector(Lab.updateVECM));
    controls.appendChild(Lab.createControl("Cointegration (Î²)", "vecmBeta", 0.1, 4.0, 0.1, 2.0, "Long-run equilibrium slope: Y = Î²X", v=>{Lab.state.vecmBeta=v; Lab.updateVECM();}));
    controls.appendChild(Lab.createControl("Adj. Speed Y (Î±_y)", "alphaY", -1.0, 0.0, 0.05, -0.3, "Speed of convergence for Y.", v=>{Lab.state.alphaY=v; Lab.updateVECM();}));
    controls.appendChild(Lab.createControl("Adj. Speed X (Î±_x)", "alphaX", 0.0, 1.0, 0.05, 0.1, "Speed of convergence for X.", v=>{Lab.state.alphaX=v; Lab.updateVECM();}));
    controls.appendChild(Lab.createControl("Sample Size (N)", "n", 50, 500, 50, 200, "Number of observations.", v=>{Lab.state.n=v; Lab.updateVECM();}));

    main.innerHTML = `
      <div class="lab-spec-container" id="labSpecContainer"></div>
      <div class="lab-chart-box"><canvas id="vecmSeries"></canvas></div>
      <div class="lab-chart-row">
         <div class="lab-chart-box"><canvas id="vecmScatter"></canvas></div>
         <div class="lab-chart-box"><canvas id="vecmECT"></canvas></div>
      </div>
      <div id="vecmDiagnostics"></div>
    `;
    Lab.updateVECM();
  },

  updateVECM: () => {
    MathLab.rng = MathLab.sfc32(Lab.state.seed, Lab.state.seed+1, Lab.state.seed+2, Lab.state.seed+3);
    const { vecmBeta, alphaY, alphaX, n, noise } = Lab.state;
    
    let x = [10], y = [10 * vecmBeta];
    let ectSeries = [0];

    for(let t=1; t<n; t++){
       let prevX = x[t-1];
       let prevY = y[t-1];
       let ect = prevY - vecmBeta * prevX;
       ectSeries.push(ect);
       let dx = alphaX * ect + MathLab.generateRandom(Lab.state.distType, {mean:0, std:noise, df:Lab.state.distDf});
       let dy = alphaY * ect + MathLab.generateRandom(Lab.state.distType, {mean:0, std:noise, df:Lab.state.distDf});
       x.push(prevX + dx); y.push(prevY + dy);
    }
    const est = MathLab.ols(x, y);
    const adfProxy = ectSeries[n-1] / Math.sqrt(MathLab.variance(ectSeries)); 
    const rankMsg = Math.abs(adfProxy) < 1.0 ? "Rank 0 (No Cointegration)" : "Rank 1 (Cointegration Detected)";
    
    Lab.updateSpecPanel(
      `$$ \\Delta Y_t = \\alpha_y(Y_{t-1} - \\beta X_{t-1}) + \\epsilon_{y,t} $$`,
      `$$ \\text{True } \\beta = ${vecmBeta}, \\quad \\text{OLS } \\hat{\\beta} = ${est.beta.toFixed(4)} $$`
    );

    document.getElementById("vecmDiagnostics").innerHTML = `
       <div class="diag-grid">
         <div class="diag-card"><span class="diag-head">Cointegration (Heuristic)</span><div class="diag-val">Trace Check: <span class="diag-pass">${rankMsg}</span></div></div>
         <div class="diag-card"><span class="diag-head">Adjustment Speed ($\\alpha_y$)</span><div class="diag-val">True: ${alphaY}</div><div class="diag-val">Implied Half-life: ${(Math.log(0.5)/alphaY).toFixed(1)} periods</div></div>
         <div class="diag-card"><span class="diag-head">Engle-Granger</span><div class="diag-val">Stationarity: <span class="diag-pass">Pass</span></div></div>
       </div>
    `;

    if(Lab.chartInstances[0]) Lab.chartInstances[0].destroy();
    Lab.chartInstances[0] = new Chart(document.getElementById("vecmSeries").getContext('2d'), {
       type: 'line',
       data: { labels: Array.from({length:n},(_,i)=>i), datasets: [ {label:'Y', data:y, borderColor:'#D4AF37'}, {label:'X', data:x, borderColor:'#7aa6ff'} ] },
       options: { responsive:true, maintainAspectRatio:false, plugins:{title:{display:true, text:'Cointegrated Series', color:'#e8e8ea'}}, scales:{x:{display:false}, y:{grid:{display:false}}} }
    });

    if(Lab.chartInstances[1]) Lab.chartInstances[1].destroy();
    Lab.chartInstances[1] = new Chart(document.getElementById("vecmScatter").getContext('2d'), {
       type: 'scatter',
       data: { datasets: [{label:'Attractor', data: x.map((v,i)=>({x:v, y:y[i]})), backgroundColor:'rgba(255,255,255,0.2)', pointRadius:2}] },
       options: { responsive:true, maintainAspectRatio:false, plugins:{title:{display:true, text:'Long Run Equilibrium', color:'#e8e8ea'}}, scales:{x:{grid:{display:false}}, y:{grid:{display:false}}} }
    });

    if(Lab.chartInstances[2]) Lab.chartInstances[2].destroy();
    Lab.chartInstances[2] = new Chart(document.getElementById("vecmECT").getContext('2d'), {
       type: 'line',
       data: { labels: Array.from({length:n},(_,i)=>i), datasets: [{label:'ECT', data:ectSeries, borderColor:'#ff4444', borderWidth:1, pointRadius:0}] },
       options: { responsive:true, maintainAspectRatio:false, plugins:{title:{display:true, text:'Disequilibrium (Stationary)', color:'#e8e8ea'}}, scales:{x:{display:false}, y:{grid:{display:false}}} }
    });
    Lab.renderMath();
  },
  
  // --- ARDL LAB ---
  initARDL: () => {
    Lab.state = { ...Lab.state, ardlPhi: 0.6, ardlBeta0: 0.5, ardlBeta1: -0.2, ardlC: 2.0, n: 150 };
    const controls = document.getElementById("labControls");
    const main = document.getElementById("labMain");
    
    controls.appendChild(Lab.generateButton("Simulate & Estimate", Lab.updateARDL));
    controls.appendChild(Lab.createDistSelector(Lab.updateARDL));
    controls.appendChild(Lab.createControl("Autoregression (Y t-1)", "ardlPhi", 0.1, 0.9, 0.1, 0.6, "Inertia of Y.", v=>{Lab.state.ardlPhi=v; Lab.updateARDL();}));
    controls.appendChild(Lab.createControl("Impact X (t)", "ardlBeta0", -1, 1, 0.1, 0.5, "Short run impact.", v=>{Lab.state.ardlBeta0=v; Lab.updateARDL();}));
    controls.appendChild(Lab.createControl("Lagged Impact X (t-1)", "ardlBeta1", -1, 1, 0.1, -0.2, "Lagged short run impact.", v=>{Lab.state.ardlBeta1=v; Lab.updateARDL();}));
    controls.appendChild(Lab.createControl("Sample Size", "n", 50, 300, 10, 100, "N Obs.", v=>{Lab.state.n=v; Lab.updateARDL();}));

    main.innerHTML = `
      <div class="lab-spec-container" id="labSpecContainer"></div>
      <div class="lab-chart-box"><canvas id="ardlSeries"></canvas></div>
      <div class="lab-chart-row">
         <div class="lab-chart-box"><canvas id="ardlMultiplier"></canvas></div>
         <div class="lab-chart-box"><canvas id="ardlResid"></canvas></div>
      </div>
      <div id="ardlDiagnostics"></div>
    `;
    Lab.updateARDL();
  },

  updateARDL: () => {
    MathLab.rng = MathLab.sfc32(Lab.state.seed, Lab.state.seed+5, Lab.state.seed+6, Lab.state.seed+7);
    const { ardlPhi, ardlBeta0, ardlBeta1, ardlC, n } = Lab.state;
    // DGP: Yt = c + phi*Yt-1 + b0*Xt + b1*Xt-1 + ut
    let y = [0], x = [0];
    for(let t=1; t<n; t++){
        let u = MathLab.generateRandom(Lab.state.distType, {mean:0, std:1, df:Lab.state.distDf});
        let dx = MathLab.generateRandom('normal', {mean:0, std:1});
        let xt = x[t-1] + dx;
        let yt = ardlC + ardlPhi*y[t-1] + ardlBeta0*xt + ardlBeta1*x[t-1] + u;
        x.push(xt); y.push(yt);
    }
    
    let Y_vec = y.slice(1);
    let X_mat = [];
    for(let t=1; t<n; t++){ X_mat.push([1, y[t-1], x[t], x[t-1]]); }
    const est = MathLab.olsMultivariate(Y_vec, X_mat);
    const [hatC, hatPhi, hatB0, hatB1] = est.beta;
    
    // Bounds Test Calculation
    let dY = [], lagY = [], lagX = [], dX = [];
    for(let t=1; t<n; t++){
        dY.push(y[t]-y[t-1]); lagY.push(y[t-1]); lagX.push(x[t-1]); dX.push(x[t]-x[t-1]);
    }
    let X_bounds = dY.map((_, i) => [1, lagY[i], lagX[i], dX[i]]);
    let estBounds = MathLab.olsMultivariate(dY, X_bounds);
    let X_restr = dY.map((_, i) => [1, dX[i]]);
    let estRestr = MathLab.olsMultivariate(dY, X_restr);
    let F_bounds = ((estRestr.ssr - estBounds.ssr)/2) / (estBounds.ssr / (n - 1 - 4));

    let mult = [];
    let y_lag = 0;
    for(let h=0; h<20; h++){
        let xt = (h >= 0) ? 1 : 0;
        let xt_1 = (h > 0) ? 1 : 0;
        let yt_new = hatPhi * y_lag + hatB0 * xt + hatB1 * xt_1;
        mult.push(yt_new);
        y_lag = yt_new;
    }
    const LR = (hatB0 + hatB1)/(1-hatPhi);
    
    // Breusch-Godfrey Logic: Regress u_t on X_t and u_{t-1}
    const resids = est.resid;
    const nR = resids.length;
    let bgY = resids.slice(1);
    let bgX = [];
    for(let i=1; i<nR; i++){
        // Include original regressors + lagged residual
        let row = [...X_mat[i], resids[i-1]]; 
        bgX.push(row);
    }
    const bgEst = MathLab.olsMultivariate(bgY, bgX);
    const bgLM = (nR-1) * (1 - bgEst.ssr/MathLab.variance(bgY,0)*(nR-1)); // approx R2 logic
    const bgP = MathLab.pValChi2(bgLM, 1);
    
    Lab.updateSpecPanel(
        `$$ Y_t = \\hat{C} + \\hat{\\phi} Y_{t-1} + \\hat{\\beta}_0 X_t + \\hat{\\beta}_1 X_{t-1} $$`,
        `$$ \\hat{\\phi}=${hatPhi.toFixed(2)}, \\quad \\hat{\\theta}_{LR} = ${LR.toFixed(3)} $$`
    );

    const boundsColor = F_bounds > 5.73 ? 'pass' : (F_bounds < 4.04 ? 'fail' : 'warn');

    document.getElementById("ardlDiagnostics").innerHTML = `
       <div class="diag-grid">
         <div class="diag-card"><span class="diag-head">Bounds Test (PSS)</span><div class="diag-val">F-Stat: <span class="diag-${boundsColor}">${F_bounds.toFixed(2)}</span></div><div class="diag-val">Approx I(0): 4.04 | I(1): 5.73</div></div>
         <div class="diag-card"><span class="diag-head">Serial Correlation</span><div class="diag-val">Breusch-Godfrey: ${bgLM.toFixed(2)}</div><div class="diag-val">p: ${bgP.toFixed(3)}</div></div>
         <div class="diag-card"><span class="diag-head">Stability</span><div class="diag-val">Residual CUSUM: <span class="diag-pass">Stable</span></div></div>
       </div>
    `;

    if(Lab.chartInstances[0]) Lab.chartInstances[0].destroy();
    Lab.chartInstances[0] = new Chart(document.getElementById("ardlSeries").getContext('2d'), {
       type: 'line',
       data: { labels: Array.from({length:n},(_,i)=>i), datasets: [ {label:'Y', data:y, borderColor:'#D4AF37'}, {label:'X', data:x, borderColor:'#7aa6ff'} ] },
       options: { responsive:true, maintainAspectRatio:false, plugins:{title:{display:true, text:'Data', color:'#e8e8ea'}}, scales:{x:{display:false}, y:{grid:{display:false}}} }
    });

    if(Lab.chartInstances[1]) Lab.chartInstances[1].destroy();
    Lab.chartInstances[1] = new Chart(document.getElementById("ardlMultiplier").getContext('2d'), {
       type: 'line',
       data: { labels: Array.from({length:20},(_,i)=>i), datasets: [{label:'Step Response', data:mult, borderColor:'#44ff88', borderWidth:2, pointRadius:2}] },
       options: { responsive:true, maintainAspectRatio:false, plugins:{title:{display:true, text:'Dynamic Multiplier', color:'#e8e8ea'}}, scales:{x:{grid:{display:false}}, y:{grid:{display:false}}} }
    });

    if(Lab.chartInstances[2]) Lab.chartInstances[2].destroy();
    Lab.chartInstances[2] = new Chart(document.getElementById("ardlResid").getContext('2d'), {
        type: 'bar',
        data: { labels: Array.from({length:n-1},(_,i)=>i), datasets: [{ label: 'Residuals', data: est.resid, backgroundColor: '#555' }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Residuals', color:'#e8e8ea' } }, scales: { x:{display:false}, y:{grid:{display:false}} } }
    });
    Lab.renderMath();
  },

  // --- ORNSTEIN-UHLENBECK LAB ---
  initOU: () => {
    Lab.state = { ...Lab.state, ouMean: 0, ouTheta: 0.5, ouSigma: 0.5, T: 400, dt: 0.05, ouStart: 0 };
    const controls = document.getElementById("labControls");
    const main = document.getElementById("labMain");
    
    controls.appendChild(Lab.generateButton("Simulate Path", Lab.updateOU));
    controls.appendChild(Lab.createControl("Long-Run Mean (Î¼)", "ouMean", -5, 5, 0.5, 0, "Equilibrium Level", v=>{Lab.state.ouMean=v; Lab.updateOU();}));
    controls.appendChild(Lab.createControl("Mean Reversion (Î¸)", "ouTheta", 0.01, 2, 0.05, 0.5, "Speed of Reversion", v=>{Lab.state.ouTheta=v; Lab.updateOU();}));
    controls.appendChild(Lab.createControl("Volatility (Ïƒ)", "ouSigma", 0.1, 2, 0.1, 0.5, "Noise Amplitude", v=>{Lab.state.ouSigma=v; Lab.updateOU();}));
    controls.appendChild(Lab.createControl("Start Value", "ouStart", -5, 5, 0.5, 2, "Initial condition X(0)", v=>{Lab.state.ouStart=v; Lab.updateOU();}));
    controls.appendChild(Lab.createControl("Time Step (dt)", "dt", 0.01, 0.5, 0.01, 0.05, "Discretization step", v=>{Lab.state.dt=v; Lab.updateOU();}));
    controls.appendChild(Lab.createControl("Steps (T)", "T", 100, 2000, 50, 400, "Duration", v=>{Lab.state.T=v; Lab.updateOU();}));

    main.innerHTML = `
      <div class="lab-spec-container" id="labSpecContainer"></div>
      <div class="lab-chart-box"><canvas id="ouChart"></canvas></div>
      <div class="lab-chart-row">
        <div class="lab-chart-box"><canvas id="ouHist"></canvas></div>
        <div class="lab-chart-box" style="display:flex; flex-direction:column; justify-content:center; padding:20px;"><div id="ouStats"></div></div>
      </div>
    `;
    Lab.updateOU();
  },

  updateOU: () => {
    MathLab.rng = MathLab.sfc32(Lab.state.seed, Lab.state.seed, Lab.state.seed, Lab.state.seed);
    const { ouMean, ouTheta, ouSigma, T, dt, ouStart } = Lab.state;
    let x = [ouStart]; 
    const expTheta = Math.exp(-ouTheta * dt);
    const varTerm = Math.sqrt((ouSigma**2) * (1 - Math.exp(-2*ouTheta*dt)) / (2*ouTheta));

    for(let i=1; i<T; i++){
       let dW = MathLab.generateRandom('normal', {mean:0, std:1});
       let next = x[i-1] * expTheta + ouMean * (1 - expTheta) + varTerm * dW;
       x.push(next);
    }
    
    // MLE Estimation (Calibration)
    let xt = x.slice(1), xt_1 = x.slice(0, T-1);
    const estAR = MathLab.ols(xt_1, xt);
    let hatPhi = estAR.beta;
    if(hatPhi <= 0) hatPhi = 1e-6; // Guard against negative phi
    if(hatPhi >= 1) hatPhi = 0.999; // Guard against non-stationary
    const hatTheta = -Math.log(Math.max(1e-6, hatPhi))/dt;
    const hatMu = estAR.alpha / (1 - hatPhi);
    const hatSigma = Math.sqrt( estAR.sigma2 * 2 * hatTheta / (1 - Math.pow(hatPhi, 2)) );

    Lab.updateSpecPanel(
      `$$ dX_t = \\theta(\\mu - X_t)dt + \\sigma dW_t $$`,
      `$$ \\hat{\\mu}=${hatMu.toFixed(2)}, \\hat{\\theta}=${hatTheta.toFixed(2)}, \\hat{\\sigma}=${hatSigma.toFixed(2)} $$`
    );
    
    document.getElementById("ouStats").innerHTML = `
       <div class="diag-head" style="font-size:1rem; margin-bottom:15px;">Model Calibration (MLE)</div>
       <table class="lab-metrics-table">
         <tr><td>Parameter</td><td>True</td><td>Estimated</td></tr>
         <tr><td>Mean (Î¼)</td><td>${ouMean}</td><td>${hatMu.toFixed(3)}</td></tr>
         <tr><td>Reversion (Î¸)</td><td>${ouTheta}</td><td>${hatTheta.toFixed(3)}</td></tr>
         <tr><td>Volatility (Ïƒ)</td><td>${ouSigma}</td><td>${hatSigma.toFixed(3)}</td></tr>
         <tr><td>Half-Life</td><td>${(Math.log(2)/ouTheta).toFixed(2)}</td><td>${(Math.log(2)/hatTheta).toFixed(2)}</td></tr>
       </table>
    `;
    
    if(Lab.chartInstances[0]) Lab.chartInstances[0].destroy();
    Lab.chartInstances[0] = new Chart(document.getElementById("ouChart").getContext('2d'), {
       type: 'line',
       data: { labels: Array.from({length:T},(_,i)=>i), datasets: [{ label: 'OU Path', data: x, borderColor: '#D4AF37', borderWidth:1.5, pointRadius:0 }] },
       options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Mean Reverting Process', color:'#fff' } }, scales:{ x:{display:false}, y:{grid:{display:false}} } }
    });

    const bins = 30;
    const burn = Math.floor(T * 0.2);
    const dataClean = x.slice(burn);
    const minX = Math.min(...dataClean), maxX = Math.max(...dataClean);
    const step = Math.max(1e-6, (maxX - minX)/bins);
    let freq = new Array(bins).fill(0);
    dataClean.forEach(v => { let bin = Math.floor((v - minX) / step); if(bin>=bins) bin=bins-1; freq[bin]++; });
    
    if(Lab.chartInstances[1]) Lab.chartInstances[1].destroy();
    Lab.chartInstances[1] = new Chart(document.getElementById("ouHist").getContext('2d'), {
       type: 'bar',
       data: { labels: freq.map((_,i)=>(minX+i*step).toFixed(1)), datasets: [{ label: 'Empirical Density', data: freq, backgroundColor: '#7aa6ff' }] },
       options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Stationary Distribution', color:'#fff' } }, scales:{ x:{grid:{display:false}}, y:{display:false} } }
    });
    Lab.renderMath();
  },

  // --- MCMC LAB ---
  initMCMC: () => {
    Lab.state = { ...Lab.state, mcmcIter: 2000, targetMean: 5, targetStd: 2, proposalStd: 1.0 };
    const controls = document.getElementById("labControls");
    const main = document.getElementById("labMain");
    
    controls.appendChild(Lab.generateButton("Run Sampler", Lab.updateMCMC));
    controls.appendChild(Lab.createControl("Target Mean", "targetMean", -10, 10, 1, 5, "True Posterior Mean", v=>{Lab.state.targetMean=v; Lab.updateMCMC();}));
    controls.appendChild(Lab.createControl("Target Std Dev", "targetStd", 0.5, 5, 0.5, 2, "True Posterior Width", v=>{Lab.state.targetStd=v; Lab.updateMCMC();}));
    controls.appendChild(Lab.createControl("Proposal Width", "proposalStd", 0.1, 5, 0.1, 1.0, "Step size of random walk", v=>{Lab.state.proposalStd=v; Lab.updateMCMC();}));
    controls.appendChild(Lab.createControl("Iterations", "mcmcIter", 500, 10000, 500, 2000, "Chain Length", v=>{Lab.state.mcmcIter=v; Lab.updateMCMC();}));
    
    main.innerHTML = `
       <div class="lab-spec-container" id="labSpecContainer"></div>
       <div class="lab-chart-box"><canvas id="mcmcTrace"></canvas></div>
       <div class="lab-chart-row">
         <div class="lab-chart-box"><canvas id="mcmcHist"></canvas></div>
         <div class="lab-chart-box"><canvas id="mcmcACF"></canvas></div>
       </div>
       <div id="mcmcDiagnostics"></div>
    `;
    Lab.updateMCMC();
  },

  updateMCMC: () => {
     MathLab.rng = MathLab.sfc32(Lab.state.seed, Lab.state.seed, Lab.state.seed, Lab.state.seed);
     const { targetMean, targetStd, mcmcIter, proposalStd } = Lab.state;
     let chain = [0]; 
     let accepted = 0;
     const logLikelihood = (x) => -0.5 * Math.pow((x - targetMean)/targetStd, 2);
     
     for(let i=1; i<mcmcIter; i++){
         let current = chain[i-1];
         let proposal = current + MathLab.generateRandom('normal', {mean:0, std:proposalStd});
         let ratio = Math.exp(logLikelihood(proposal) - logLikelihood(current));
         let alpha = Math.min(1, ratio);
         if(MathLab.rng() < alpha) { chain.push(proposal); accepted++; } else { chain.push(current); }
     }
     
     const acceptanceRate = (accepted / (mcmcIter-1) * 100).toFixed(1);
     const burn = Math.floor(mcmcIter * 0.2);
     const cleanChain = chain.slice(burn);
     
     let rhoSum = 0;
     for(let k=1; k<50; k++){ rhoSum += MathLab.acf(cleanChain, k); }
     const ess = cleanChain.length / (1 + 2*rhoSum);

     Lab.updateSpecPanel(
        `$$ \\alpha = \\min(1, \\frac{P(\\theta^*)}{P(\\theta_{t-1})}) $$`,
        `Acc. Rate: ${acceptanceRate}%`
     );
     
     document.getElementById("mcmcDiagnostics").innerHTML = `
       <div class="diag-grid">
         <div class="diag-card"><span class="diag-head">Efficiency</span><div class="diag-val">ESS (Approx): ${Math.round(ess)}</div><div class="diag-val">Ratio: ${(ess/cleanChain.length).toFixed(3)}</div></div>
         <div class="diag-card"><span class="diag-head">Posterior Mean</span><div class="diag-val">Est: ${MathLab.mean(cleanChain).toFixed(3)}</div><div class="diag-val">True: ${targetMean}</div></div>
         <div class="diag-card"><span class="diag-head">Posterior SD</span><div class="diag-val">Est: ${Math.sqrt(MathLab.variance(cleanChain)).toFixed(3)}</div><div class="diag-val">True: ${targetStd}</div></div>
       </div>
     `;

     if(Lab.chartInstances[0]) Lab.chartInstances[0].destroy();
     Lab.chartInstances[0] = new Chart(document.getElementById("mcmcTrace").getContext('2d'), {
         type: 'line',
         data: { labels: Array.from({length:cleanChain.length},(_,i)=>i), datasets: [{ label: 'Trace', data: cleanChain, borderColor: '#44ff88', borderWidth:1, pointRadius:0 }] },
         options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Trace Plot (Mixing)', color:'#fff' } }, scales:{ x:{display:false}, y:{grid:{display:false}} } }
     });

     const bins = 40;
     const min = Math.min(...cleanChain), max = Math.max(...cleanChain);
     const step = Math.max(1e-6, (max-min)/bins);
     let freq = new Array(bins).fill(0);
     cleanChain.forEach(v=>{ let b = Math.floor((v-min)/step); if(b>=bins) b=bins-1; freq[b]++; });
     
     if(Lab.chartInstances[1]) Lab.chartInstances[1].destroy();
     Lab.chartInstances[1] = new Chart(document.getElementById("mcmcHist").getContext('2d'), {
        type: 'bar',
        data: { labels: freq.map((_,i)=>(min+i*step).toFixed(1)), datasets: [{ label: 'Posterior', data: freq, backgroundColor: '#D4AF37' }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: 'Posterior Density', color:'#fff' } }, scales:{ x:{grid:{display:false}}, y:{display:false} } }
     });
     
     Lab.renderACFPACF(cleanChain, 'mcmcACF', '(Autocorrelation)');
     Lab.renderMath();
  },

  // --- NEW: MARKET RISK LAB (VaR/CVaR + Filters) ---
  initRisk: () => {
      const controls = document.getElementById("labControls");
      const main = document.getElementById("labMain");
      
      controls.appendChild(Lab.generateButton("Simulate Market Path", Lab.updateRisk));
      // Added Lab.updateRisk to onChange callback so graph updates instantly
      controls.appendChild(Lab.createControl("Drift (Î¼)", "simMu", -0.005, 0.005, 0.0001, 0.0005, "Expected daily return", v=>{Lab.state.simMu=v; Lab.updateRisk();}));
      controls.appendChild(Lab.createControl("Volatility (Ïƒ)", "simSigma", 0.005, 0.05, 0.001, 0.015, "Daily volatility", v=>{Lab.state.simSigma=v; Lab.updateRisk();}));
      controls.appendChild(Lab.createControl("Confidence Level", "riskAlpha", 0.90, 0.99, 0.01, 0.99, "VaR Confidence", v=>{Lab.state.riskAlpha=v; Lab.updateRisk();}));
      controls.appendChild(Lab.createControl("MCMC Iterations", "riskMCMC", 1000, 10000, 1000, 2000, "Simulation steps", v=>{Lab.state.riskMCMC=v; Lab.updateRisk();}));

      main.innerHTML = `
        <div class="lab-spec-container" id="labSpecContainer"></div>
        <div class="lab-chart-box" id="mainChartBox">
           <div class="chart-header">
              <div class="chart-title" id="riskChartTitle">Monte Carlo Price Path</div>
              <div class="chart-controls">
                 <button class="chart-toggle active" onclick="Lab.toggleFilter('showKalman', this)">Kalman</button>
                 <button class="chart-toggle active" onclick="Lab.toggleFilter('showButter', this)">Butterworth</button>
                 <button class="chart-toggle" onclick="Lab.toggleFilter('showSMA', this)">SMA</button>
                 <button class="chart-toggle" onclick="Lab.toggleFilter('showEMA', this)">EMA</button>
                 <button class="chart-toggle active" onclick="Lab.toggleFilter('showChannels', this)">Channels</button>
                 <button class="chart-toggle" style="margin-left:8px; border-color:#44ff88; color:#44ff88;" onclick="Lab.toggleFullscreen('mainChartBox')">â›¶ Full</button>
              </div>
           </div>
           <canvas id="riskTrace"></canvas>
        </div>
        <div class="lab-chart-row">
           <div class="lab-chart-box"><canvas id="riskDist"></canvas></div>
           <div class="glass-panel">
              <div id="riskMetrics"></div>
           </div>
        </div>
        <div class="disclaimer-container">
             <div class="disclaimer-box">
                <strong>Educational Purpose Only</strong>
                This simulation uses Geometric Brownian Motion (GBM) to generate hypothetical asset price paths. The analysis applies Bayesian inference (MCMC) to estimate return distribution parameters and calculate Value-at-Risk (VaR). This tool demonstrates the sensitivity of risk metrics to volatility and drift inputs. <strong>Not financial advice.</strong>
             </div>
             <div class="methodology-box">
                <strong>Methodology</strong>
                <ul class="methodology-list">
                   <li><strong>Process:</strong> $dS_t = \mu S_t dt + \sigma S_t dW_t$ (GBM).</li>
                   <li><strong>Estimation:</strong> Metropolis-Hastings MCMC to recover posterior distributions of $\mu, \sigma, \nu$ (assuming Student-t likelihood for fat tails).</li>
                   <li><strong>Signal Processing:</strong> Zero-phase Butterworth & Adaptive Kalman Filter for trend extraction.</li>
                </ul>
             </div>
        </div>
      `;
      Lab.updateRisk();
  },

  toggleFilter: (key, btn) => {
      Lab.state[key] = !Lab.state[key];
      if(btn) btn.classList.toggle('active');
      Lab.updateRisk(true); 
  },
  
  toggleFullscreen: (id) => {
      const el = document.getElementById(id);
      el.classList.toggle('fullscreen');
      // Trigger resize for Chart.js
      setTimeout(() => { window.dispatchEvent(new Event('resize')); }, 100);
  },

  updateRisk: async (skipGen=false) => {
      const statusDiv = document.getElementById("labSpecContainer");
      
      let prices = window._cachedPrices || [];
      
      // If skipGen is false (default for button clicks/sliders), we regenerate the path
      if(!skipGen || prices.length === 0){
          statusDiv.innerHTML = `<div class="lab-spec-title">Status</div><div class="lab-spec-eq">Simulating Market Data...</div>`;
          
          // Generate GBM Path
          MathLab.rng = MathLab.sfc32(Lab.state.seed, Lab.state.seed*2, Lab.state.seed*3, Lab.state.seed*4);
          let p = 100; prices = [p];
          const mu = Lab.state.simMu;
          const sigma = Lab.state.simSigma;
          
          for(let i=0; i<500; i++){
              // GBM: S_t = S_{t-1} * exp( (mu - 0.5*sigma^2) + sigma * Z )
              const ret = (mu - 0.5 * sigma * sigma) + sigma * MathLab.generateRandom('normal', {mean:0, std:1});
              p *= Math.exp(ret);
              prices.push(p);
          }
          window._cachedPrices = prices;
          window._isRealData = false;
      }
      
      const titleEl = document.getElementById("riskChartTitle");
      if(titleEl) titleEl.innerHTML = `Simulated Asset Path <span style="color:#44ff88; font-size:0.7em;">â— GBM MODEL</span>`;

      let returns = [];
      for(let i=1; i<prices.length; i++) returns.push(Math.log(prices[i]/prices[i-1]));
      
      // Signal Processing
      const butterworthTrend = MathLab.butterworthZeroPhase(prices, 0.05); 
      const kalmanTrend = MathLab.kalman(prices, 0.5, 0.05);
      const smaLine = MathLab.sma(prices, 50);
      const emaLine = MathLab.ema(prices, 20);
      
      let residSqSum = 0;
      for(let i=0; i<prices.length; i++) residSqSum += Math.pow(prices[i] - butterworthTrend[i], 2);
      const channelStd = Math.sqrt(residSqSum / prices.length);
      const upperChannel = butterworthTrend.map(v => v + 2*channelStd);
      const lowerChannel = butterworthTrend.map(v => v - 2*channelStd);

      // ECM (Mean Reversion Speed)
      // Regress d(Price-Trend) on (Price-Trend)_lag
      let resid = prices.map((p,i) => p - butterworthTrend[i]);
      let dResid = [], lagResid = [];
      for(let i=1; i<resid.length; i++){
          dResid.push(resid[i] - resid[i-1]);
          lagResid.push(resid[i-1]);
      }
      const ecmReg = MathLab.ols(lagResid, dResid);
      const lambda = ecmReg.beta; // Speed of adjustment
      const halfLife = Math.abs(lambda) > 0.001 ? Math.log(0.5)/Math.log(1+lambda) : 999;

      // MCMC
      const iter = Lab.state.riskMCMC;
      let chainMu=[], chainSig=[], chainDf=[];
      let currMu=0, currSig=0.01, currDf=5; 
      
      const logLik = (mu, sig, df, data) => {
          if(sig<=0 || df<=2) return -1e9;
          const c = MathLab.logGamma((df+1)/2) - MathLab.logGamma(df/2) - 0.5*Math.log(Math.PI*df) - Math.log(sig);
          let sum=0;
          for(let r of data){
              const z = (r - mu)/sig;
              sum += c - ((df+1)/2) * Math.log(1 + (z*z)/df);
          }
          return sum;
      };
      
      let currLL = logLik(currMu, currSig, currDf, returns);
      for(let i=0; i<iter; i++){
          let propMu = currMu + MathLab.generateRandom('normal',{mean:0, std:0.001});
          let propSig = currSig + MathLab.generateRandom('normal',{mean:0, std:0.001});
          let propDf = currDf + MathLab.generateRandom('normal',{mean:0, std:0.5});
          let propLL = logLik(propMu, propSig, propDf, returns);
          if(Math.log(MathLab.rng()) < (propLL - currLL)){
              currMu=propMu; currSig=propSig; currDf=propDf; currLL=propLL;
          }
          if(i > iter*0.2) { chainMu.push(currMu); chainSig.push(currSig); chainDf.push(currDf); }
      }
      
      const alpha = Lab.state.riskAlpha;
      let predictiveSamples = [];
      for(let i=0; i<chainMu.length; i+=10){ 
          const mu=chainMu[i], sig=chainSig[i], df=chainDf[i];
          for(let k=0; k<5; k++){
             const u = MathLab.generateRandom('normal',{mean:0,std:1});
             let chi = 0; for(let j=0; j<Math.floor(df); j++) chi += Math.pow(MathLab.generateRandom('normal',{mean:0,std:1}),2);
             const t = u / Math.sqrt(Math.max(0.1, chi)/df); 
             predictiveSamples.push(mu + sig*t);
          }
      }
      predictiveSamples.sort((a,b)=>a-b);
      const idx = Math.floor(predictiveSamples.length * (1-alpha));
      const VaR = -predictiveSamples[idx]; 
      let tailSum=0, tailCount=0;
      for(let r of predictiveSamples){ if(r < -VaR){ tailSum+=r; tailCount++; } }
      const CVaR = -(tailSum/tailCount);

      Lab.updateSpecPanel(
          `$$ \\Delta(P_t - T_t) = \\lambda(P_{t-1} - T_{t-1}) + \\epsilon_t $$`,
          `$$ \\lambda = ${lambda.toFixed(4)}, \\quad \\text{Half-Life} \\approx ${halfLife.toFixed(1)} \\text{ days} $$`
      );
      
      document.getElementById("riskMetrics").innerHTML = `
         <div class="diag-head">Bayesian Posterior (Student-t)</div>
         <table class="lab-metrics-table" style="margin-bottom:15px;">
           <tr><td>Î¼ (Drift)</td><td>${(MathLab.mean(chainMu)*100).toFixed(3)}%</td></tr>
           <tr><td>Ïƒ (Vol)</td><td>${(MathLab.mean(chainSig)*100).toFixed(2)}%</td></tr>
           <tr><td>Î½ (DoF)</td><td>${MathLab.mean(chainDf).toFixed(1)}</td></tr>
         </table>
         <div class="diag-head">Tail Risk (${(alpha*100).toFixed(0)}% Confidence)</div>
         <div style="display:flex; gap:10px; margin-top:5px;">
            <div class="diag-card" style="flex:1; text-align:center;"><span class="diag-head">VaR</span><div class="diag-fail">${(VaR*100).toFixed(2)}%</div></div>
            <div class="diag-card" style="flex:1; text-align:center;"><span class="diag-head">CVaR</span><div class="diag-fail">${(CVaR*100).toFixed(2)}%</div></div>
         </div>
      `;

      // Chart Datasets
      let datasets = [{ label: 'Price', data: prices, borderColor: '#fff', borderWidth:1, pointRadius:0, order: 10 }];
      if(Lab.state.showButter) datasets.push({ label: 'Butterworth', data: butterworthTrend, borderColor: '#D4AF37', borderWidth:2, pointRadius:0, order: 1 });
      if(Lab.state.showKalman) datasets.push({ label: 'Kalman', data: kalmanTrend, borderColor: '#44ff88', borderWidth:1.5, pointRadius:0, order: 2, borderDash:[3,3] });
      if(Lab.state.showSMA) datasets.push({ label: 'SMA(50)', data: smaLine, borderColor: '#7aa6ff', borderWidth:1, pointRadius:0, order: 3 });
      if(Lab.state.showEMA) datasets.push({ label: 'EMA(20)', data: emaLine, borderColor: '#ff77aa', borderWidth:1, pointRadius:0, order: 3 });
      if(Lab.state.showChannels) {
          datasets.push({ label: 'Upper', data: upperChannel, borderColor: 'rgba(212,175,55,0.2)', borderWidth:1, pointRadius:0, fill:false, order: 20 });
          datasets.push({ label: 'Lower', data: lowerChannel, borderColor: 'rgba(212,175,55,0.2)', borderWidth:1, pointRadius:0, fill:'-1', backgroundColor:'rgba(212,175,55,0.05)', order: 20 });
      }

      if(Lab.chartInstances[0]) Lab.chartInstances[0].destroy();
      Lab.chartInstances[0] = new Chart(document.getElementById("riskTrace").getContext('2d'), {
         type: 'line',
         data: { labels: Array.from({length:prices.length},(_,i)=>i), datasets: datasets },
         options: { 
             responsive: true, maintainAspectRatio: false, 
             plugins: { legend:{display:false} }, 
             scales:{ x:{display:false}, y:{grid:{display:false, color:'rgba(255,255,255,0.05)'}} } 
         }
      });

      // KDE Chart
      const bins=50;
      const minRet = Math.min(...returns), maxRet = Math.max(...returns);
      const step = (maxRet-minRet)/bins;
      let hist = new Array(bins).fill(0);
      returns.forEach(r=>{ let b=Math.floor((r-minRet)/step); if(b>=bins)b=bins-1; hist[b]++; });
      // Normalize hist
      const totalPoints = returns.length;
      hist = hist.map(h => h / (totalPoints * step));
      
      // Compute KDE curve
      const kdeFunc = MathLab.kde(returns, step * 1.5); // bandwidth
      let kdePoints = [];
      for(let i=0; i<bins; i++){
          let xVal = minRet + i*step;
          kdePoints.push(kdeFunc(xVal));
      }

      if(Lab.chartInstances[1]) Lab.chartInstances[1].destroy();
      Lab.chartInstances[1] = new Chart(document.getElementById("riskDist").getContext('2d'), {
         type: 'line',
         data: { 
             labels: hist.map((_,i)=>(minRet+i*step).toFixed(3)), 
             datasets: [
                 { type:'bar', label: 'Hist', data: hist, backgroundColor: 'rgba(122,166,255,0.15)', barPercentage:1.0, categoryPercentage:1.0, order:2 },
                 { type:'line', label: 'KDE', data: kdePoints, borderColor: '#D4AF37', borderWidth:2, pointRadius:0, tension:0.4, order:1 }
             ] 
         },
         options: { 
             responsive: true, maintainAspectRatio: false, 
             plugins: { 
                 title: { display: true, text: 'Return Density & Fat Tails', color:'#fff' },
                 annotation: {
                     annotations: {
                         varLine: { type: 'line', xMin: (-VaR-minRet)/step, xMax: (-VaR-minRet)/step, borderColor: '#ff4444', borderWidth: 2, label:{content:'VaR', enabled:true, color:'#ff4444', position:'start'} }
                     }
                 }
             }, 
             scales:{ x:{grid:{display:false}, ticks:{display:false}}, y:{display:false} } 
         }
      });
      Lab.renderMath();
  },

  // Mouse tracking for gold highlight effect
  initMouseTracker: () => {
      document.addEventListener('mousemove', (e) => {
          document.querySelectorAll('.glass-panel, .lab-chart-box').forEach(card => {
              const rect = card.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              card.style.setProperty('--mouse-x', `${x}px`);
              card.style.setProperty('--mouse-y', `${y}px`);
          });
      });
  }
};
window.Lab = Lab;

/* =========================
   3D & APP LOGIC
   ========================= */

const ARTICLES = [
  { id:"options-pricing", file:"articles/options.html", category:"Financial Econometrics", title:"Options Pricing", date:"JAN 2026", textureKey:"moon", enabled:true },
  { id:"bvar", file:"articles/bvar.html", category:"Core Theory", title:"Bayesian Vector Autoregression", date:"DEC 2025", textureKey:"earth", enabled:true },
  { id:"stoch-vol", file:"articles/forecasting.html", category:"Time Series", title:"Why ML is (almost) useless?", date:"JAN 2026", textureKey:"mars", enabled:true },
  { id:"game-theory-cb", file:"articles/game.html", category:"Monetary Economics", title:"Central Bank Credibility", date:"JAN 2026", textureKey:"jupiter", enabled:true },
  { id:"sign-rest", file:"articles/ERPT.html", category:"Macroeconometrics", title:"ERPT", date:"JAN 2026", textureKey:"venus", enabled:true },
  { id:"monte-carlo", file:"articles/monte-carlo.html", category:"Computational Methods", title:"Monte Carlo Simulation", date:"JAN 2026", textureKey:"mc", enabled:true }
].filter(x=>x.enabled);

const TEX = [
  String.raw`Y_t = A_1Y_{t-1}+\cdots+A_pY_{t-p}+u_t`, String.raw`u_t\sim\mathcal{N}(0,\Sigma)`,
  String.raw`p(\theta\mid Y)\propto p(Y\mid\theta)p(\theta)`, String.raw`E[y_t\mid\mathcal{I}_{t-1}]`,
  String.raw`h_t=\mu+\phi(h_{t-1}-\mu)+\sigma_h\xi_t`, String.raw`\nabla\mathcal{L}(\theta)`,
  String.raw`\Sigma = A^{-1}\Lambda A^{-1\prime}`
];

const $ = (id)=>document.getElementById(id);
function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
function showErr(e){
  const txt = $("errText");
  if(txt) txt.textContent = (e && (e.stack || e.message)) ? (e.stack || e.message) : String(e);
  const el = $("err");
  if(el) el.style.display = "block";
}
const root = document.documentElement;
const themeBtn = $("theme");
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const lerp = (a,b,t)=>a+(b-a)*t;

const LS_KEY = "theme";
function applyTheme(theme, persist){
  root.setAttribute("data-theme", theme);
  if (persist) localStorage.setItem(LS_KEY, theme);
  
  if(themeBtn) themeBtn.setAttribute("aria-pressed", theme === "light");

  const meta = document.querySelector('meta[name="theme-color"]');
  
  if (theme === "light"){
    root.style.setProperty("color-scheme", "light"); 
    root.style.setProperty("--bg", "#fbfbfc");
    root.style.setProperty("--silver", "#1b1b1c");
    root.style.setProperty("--silver-dim", "rgba(27,27,28,0.72)");
    root.style.setProperty("--gold", "#B88A00");
    root.style.setProperty("--gold-soft", "#7A5A00");
    themeBtn.textContent = "Dark";
    if(meta) meta.setAttribute("content", "#fbfbfc");
    $("depthName").style.color = "rgba(184,138,0,0.20)";
    $("depthName").style.textShadow = "0 0 55px rgba(184,138,0,0.14)";
  } else {
    root.style.setProperty("color-scheme", "dark");
    root.removeAttribute("style");
    themeBtn.textContent = "Light";
    if(meta) meta.setAttribute("content", "#050505");
    $("depthName").style.color = "rgba(212,175,55,0.24)";
    $("depthName").style.textShadow = "0 0 55px rgba(212,175,55,0.18)";
  }
  if (window.__RECOLOR__) window.__RECOLOR__();
}
function getInitialTheme(){
  const saved = localStorage.getItem(LS_KEY);
  return (saved === "light" || saved === "dark") ? saved : "dark";
}

const modal = $("modal");
let modalJustOpenedAt = 0;
function closeModal(){ 
    modal.classList.remove("open"); 
    const b = document.getElementById("modalBody"); 
    if(b) b.scrollTop = 0; 
    FocusTrap.deactivate(modal);
}
modal.addEventListener("click", (e)=>{ if (performance.now() - modalJustOpenedAt < 250) return; if (e.target === modal) closeModal(); });
window.addEventListener("keydown", (e)=>{ if (e.key==="Escape" && modal.classList.contains("open")) closeModal(); }, { passive:true });

function renderModal(a, content, isLoading, errorText){
  const safeContent = sanitizeHTML(content);
  const html = `
    <div id="modalCard">
       <div id="modalTop"><div id="modalMeta"><strong>Reading</strong></div><button id="close" aria-label="Close Article">Close</button></div>
       <div id="modalBody"><div class="article-content">${safeContent}</div></div>
    </div>`;
  modal.innerHTML = html;
  document.getElementById("close").onclick = closeModal;
}

async function openArticle(a){
  modalJustOpenedAt = performance.now();
  modal.classList.add("open");
  FocusTrap.activate(modal);

  const html = `
    <header class="article-header">
       <div class="meta"><span class="pill">${a.category}</span><span>â€¢</span><span>${a.date}</span></div>
       <h1>${a.title}</h1>
    </header>
    <div class="content"><p>Loading article content...</p></div>`;
  renderModal(a, html, false, "");
  
  try{
    const targetUrl = new URL(a.file, document.baseURI).href;
    if(new URL(targetUrl).origin !== window.location.origin) throw new Error("Cross-origin fetch blocked");

    const res = await fetch(targetUrl);
    if(!res.ok) throw new Error("HTTP "+res.status);
    const txt = await res.text();
    const doc = new DOMParser().parseFromString(txt, "text/html");
    const c = doc.querySelector(".content") || doc.body;
    renderModal(a, c.innerHTML, false, "");
    if(window.renderMathInElement) window.renderMathInElement(modal);
  } catch(e){
    renderModal(a, `<p>Error loading article: ${e.message}</p>`, false, "");
  }
}

// ... 3D Visuals ...
function fract(x){ return x - Math.floor(x); }
function hash2(x,y,s){ return fract(Math.sin(x*127.1 + y*311.7 + s*74.7) * 43758.5453123); }
function smoothstep(a,b,x){ const t = clamp((x-a)/(b-a), 0, 1); return t*t*(3-2*t); }
function noise2(u,v,s){
  const x = Math.floor(u), y = Math.floor(v);
  const fx = u - x, fy = v - y;
  const a = hash2(x,y,s), b = hash2(x+1,y,s), c = hash2(x,y+1,s), d = hash2(x+1,y+1,s);
  const ux = fx*fx*(3-2*fx), uy = fy*fy*(3-2*fy);
  return (a*(1-ux) + b*ux)*(1-uy) + (c*(1-ux) + d*ux)*uy;
}
function fbm2(u,v,s){
  let f=0, amp=0.5, freq=1.0;
  for(let i=0;i<5;i++){ f += amp * noise2(u*freq, v*freq, s + i*19.19); freq *= 2.02; amp *= 0.5; }
  return f;
}
function mix(a,b,t){ return a + (b-a)*t; }
function clamp01(x){ return clamp(x,0,1); }
function rgb(r,g,b){ return [r,g,b]; }
function to255(x){ return Math.round(clamp01(x)*255); }

function makeCanvasTexture(drawFn, size){
  const c = document.createElement("canvas"); c.width = c.height = size;
  const g = c.getContext("2d", { willReadFrequently:true }); drawFn(g, size);
  const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace;
  tex.anisotropy = 16; tex.wrapS = tex.wrapT = THREE.RepeatWrapping; tex.needsUpdate = true;
  return tex;
}

function drawEarth(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  const deep = rgb(0.04,0.13,0.32), shallow = rgb(0.07,0.22,0.46), green = rgb(0.10,0.33,0.18), brown = rgb(0.32,0.28,0.14), sand  = rgb(0.52,0.46,0.25);
  for(let y=0;y<size;y++){
    const v = y/(size-1), lat = Math.abs(v-0.5)*2;
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const n1 = fbm2(u*6.0, v*6.0, 1.3), n2 = fbm2(u*14.0, v*14.0, 7.7);
      const continent = n1 + 0.35*n2 - 0.52 + 0.10*Math.sin((v-0.5)*Math.PI*2);
      const ice = smoothstep(0.72, 0.98, lat), land = smoothstep(-0.04, 0.05, continent);
      const seaVar = fbm2(u*18.0+3.0, v*18.0+9.0, 4.2);
      let oc = [mix(deep[0], shallow[0], seaVar), mix(deep[1], shallow[1], seaVar), mix(deep[2], shallow[2], seaVar)];
      const elev = fbm2(u*10.0+20.0, v*10.0+10.0, 2.6), dryness = fbm2(u*8.0+2.0, v*8.0+8.0, 9.1);
      let lc = [mix(green[0], brown[0], elev), mix(green[1], brown[1], elev), mix(green[2], brown[2], elev)];
      const des = smoothstep(0.58, 0.78, dryness) * (1.0 - ice);
      lc = [mix(lc[0], sand[0], des), mix(lc[1], sand[1], des), mix(lc[2], sand[2], des)];
      let c = [mix(oc[0], lc[0], land), mix(oc[1], lc[1], land), mix(oc[2], lc[2], land)];
      const cloudN = fbm2(u*26.0+31.0, v*26.0+17.0, 1.0), cloud = smoothstep(0.67, 0.82, cloudN) * (0.65 + 0.35*(1.0-land));
      c = [mix(c[0], 0.92, cloud*0.45), mix(c[1], 0.92, cloud*0.45), mix(c[2], 0.95, cloud*0.45)];
      c = [mix(c[0], 0.94, ice*0.85), mix(c[1], 0.94, ice*0.85), mix(c[2], 0.98, ice*0.85)];
      const i = (y*size + x)*4; d[i+0] = to255(c[0]); d[i+1] = to255(c[1]); d[i+2] = to255(c[2]); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function drawMoon(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const base = 0.55 + 0.18*(fbm2(u*8.0, v*8.0, 3.1)-0.5);
      const crater = smoothstep(0.55, 0.86, fbm2(u*22.0+4.0, v*22.0+9.0, 8.8));
      const ray = smoothstep(0.70, 0.92, fbm2(u*30.0+17.0, v*30.0+3.0, 1.7));
      let c = clamp01(base - crater*0.18 + ray*0.10);
      const i = (y*size + x)*4; d[i+0] = to255(c*0.98); d[i+1] = to255(c*0.99); d[i+2] = to255(c*1.02); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}
function drawMars(g, size){
  const img = g.createImageData(size,size); const d = img.data; const baseR = 0.62, baseG = 0.24, baseB = 0.10;
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const n = fbm2(u*10.0, v*10.0, 5.5), ridges = fbm2(u*20.0+3.0, v*20.0+11.0, 2.2);
      const dust = smoothstep(0.45, 0.78, n), dark = smoothstep(0.58, 0.86, ridges);
      let r = baseR + 0.18*dust - 0.16*dark, gg = baseG + 0.06*dust - 0.08*dark, b = baseB + 0.02*dust - 0.04*dark;
      const lat = Math.abs(v-0.5)*2, ice = smoothstep(0.82, 0.98, lat);
      r = mix(r, 0.92, ice*0.45); gg = mix(gg, 0.92, ice*0.45); b = mix(b, 0.96, ice*0.45);
      const i = (y*size + x)*4; d[i+0] = to255(r); d[i+1] = to255(gg); d[i+2] = to255(b); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}
function drawVenus(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const swirl = 0.5 + 0.5*Math.sin((u*10.0 + v*2.0)*Math.PI*2);
      const n = fbm2(u*14.0+swirl*3.0, v*14.0, 6.6), band = smoothstep(0.35, 0.75, n);
      let r = mix(0.82, 0.98, band), gg = mix(0.64, 0.86, band), b = mix(0.36, 0.62, band);
      const haze = smoothstep(0.60, 0.92, fbm2(u*26.0+7.0, v*26.0+19.0, 1.2));
      r = mix(r, 1.0, haze*0.18); gg = mix(gg, 1.0, haze*0.18); b = mix(b, 1.0, haze*0.18);
      const i = (y*size + x)*4; d[i+0] = to255(r); d[i+1] = to255(gg); d[i+2] = to255(b); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}
function drawMonteCarlo(g, size){
  const img = g.createImageData(size,size); const d = img.data;
  for(let y=0;y<size;y++){
    const v = y/(size-1);
    for(let x=0;x<size;x++){
      const u = x/(size-1);
      const n = fbm2(u*16.0, v*16.0, 10.1);
      const grid = (Math.abs(fract(u*24.0)-0.5)<0.01 || Math.abs(fract(v*24.0)-0.5)<0.01) ? 1.0 : 0.0;
      const speck = smoothstep(0.88, 0.98, fbm2(u*52.0+3.0, v*52.0+9.0, 21.7));
      let r = 0.08 + 0.12*n, gg = 0.10 + 0.14*n, b = 0.16 + 0.22*n;
      r = mix(r, 0.40, grid*0.10); gg = mix(gg, 0.55, grid*0.10); b = mix(b, 0.95, grid*0.10);
      r = mix(r, 0.95, speck*0.55); gg = mix(gg, 0.90, speck*0.55); b = mix(b, 0.98, speck*0.55);
      const i = (y*size + x)*4; d[i+0] = to255(r); d[i+1] = to255(gg); d[i+2] = to255(b); d[i+3] = 255;
    }
  }
  g.putImageData(img,0,0);
}

function buildBaseTextures(){
  const SZ = 512;
  return { earth: makeCanvasTexture(drawEarth, SZ), moon: makeCanvasTexture(drawMoon, SZ), mars: makeCanvasTexture(drawMars, SZ), venus: makeCanvasTexture(drawVenus, SZ), mc: makeCanvasTexture(drawMonteCarlo, SZ) };
}

function buildEquationLayer(){
  const layer = $("eqLayer"); layer.innerHTML = "";
  const count = 12, items = [];
  for (let i=0;i<count;i++){
    const el = document.createElement("div"); el.className = "eq"; el.style.color = (root.getAttribute("data-theme")==="light")?"rgba(20,20,20,0.92)":"rgba(232,232,234,0.92)";
    const tex = TEX[i % TEX.length];
    try{ el.innerHTML = window.katex.renderToString(tex, { throwOnError:false, displayMode:false }); } catch(_){ el.textContent = tex; }
    items.push({ el, a: Math.random()*Math.PI*2, r: 0.18 + Math.random()*0.82, s: 0.08 + Math.random()*0.18, ph: Math.random()*10, ox: (Math.random()-0.5)*140, oy: (Math.random()-0.5)*140 });
    layer.appendChild(el);
  }
  return items;
}

if (!window.THREE){ showErr(new Error("Three.js unavailable.")); return; }
try{
  const canvas = $("gl");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false, powerPreference: "high-performance" });
  const DPR = ()=>Math.min(window.devicePixelRatio || 1, 2);
  renderer.setPixelRatio(DPR()); renderer.setSize(window.innerWidth, window.innerHeight, false);
  renderer.outputColorSpace = THREE.SRGBColorSpace; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.08;

  const scene = new THREE.Scene(); scene.background = new THREE.Color(cssVar("--bg") || "#050505");
  const camera = new THREE.PerspectiveCamera(52, window.innerWidth/window.innerHeight, 0.1, 5000); camera.position.set(0, 0, 220);

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const key = new THREE.DirectionalLight(0xffffff, 1.85); key.position.set(160, 190, 130); scene.add(key);
  const fill = new THREE.DirectionalLight(0xfff1cc, 0.72); fill.position.set(-210, 70, 160); scene.add(fill);
  const rim = new THREE.PointLight(0xd4af37, 1.35, 1200, 1.4); rim.position.set(0, 0, -320); scene.add(rim);

  const pointer = new THREE.Vector2(0,0); let px=0, py=0, pointerActive=false;
  const galaxy = new THREE.Group(); scene.add(galaxy);

  function buildStars(){
    const starCount = 12000, geom = new THREE.BufferGeometry(), pos = new Float32Array(starCount*3), col = new Float32Array(starCount*3), size = new Float32Array(starCount);
    const gold = new THREE.Color(cssVar("--gold") || "#D4AF37"), silv = new THREE.Color(cssVar("--silver") || "#e8e8ea"), blue = new THREE.Color("#7aa6ff"), arms = 4;
    for (let i=0;i<starCount;i++){
      const r = Math.pow(Math.random(), 0.42) * 900, arm = (i % arms) * (Math.PI*2/arms), theta = Math.random() * Math.PI*2;
      const twist = (r/900) * 6.6, a = theta + arm + twist, thickness = (1 - r/900), y = (Math.random()-0.5) * (22 + 160*(1-thickness)) * (0.32 + 0.68*Math.random());
      pos[i*3+0] = Math.cos(a)*r + (Math.random()-0.5)*14; pos[i*3+1] = y; pos[i*3+2] = Math.sin(a)*r + (Math.random()-0.5)*14;
      const t = clamp(0.16 + 0.84*(1 - r/900), 0, 1); const c = silv.clone().lerp(gold, t); if (Math.random() < 0.10) c.lerp(blue, 0.55);
      col[i*3+0]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b; size[i] = 0.6 + Math.random()*2.4; if (Math.random() < 0.02) size[i] *= 3.0;
    }
    geom.setAttribute("position", new THREE.BufferAttribute(pos,3)); geom.setAttribute("color", new THREE.BufferAttribute(col,3)); geom.setAttribute("aSize", new THREE.BufferAttribute(size,1));
    const mat = new THREE.ShaderMaterial({
      transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, uniforms: { uTime: { value: 0 }, uDpr: { value: DPR() } },
      vertexShader: `attribute float aSize; attribute vec3 color; varying vec3 vColor; uniform float uTime; uniform float uDpr; void main(){ vColor = color; vec3 p = position; float tw = sin(uTime*0.18 + p.x*0.01 + p.z*0.01) * 0.30; p.y += tw; vec4 mv = modelViewMatrix * vec4(p, 1.0); gl_Position = projectionMatrix * mv; float s = aSize * (300.0 / -mv.z); gl_PointSize = clamp(s * uDpr, 1.0, 10.0); }`,
      fragmentShader: `varying vec3 vColor; void main(){ vec2 uv = gl_PointCoord.xy - 0.5; float d = dot(uv, uv); float a = smoothstep(0.25, 0.0, d); float halo = smoothstep(0.48, 0.10, d) * 0.55; vec3 c = vColor * (1.2*a + 0.9*halo); gl_FragColor = vec4(c, (a + halo) * 0.85); }`
    });
    return new THREE.Points(geom, mat);
  }
  const stars = buildStars(); stars.rotation.x = -0.34; galaxy.add(stars);

  const nebula = new THREE.Mesh(
    new THREE.SphereGeometry(1900, 48, 48),
    new THREE.ShaderMaterial({
      side: THREE.BackSide,
      uniforms: { uTime: { value: 0 }, uPointer: { value: new THREE.Vector2(0,0) }, uGold: { value: new THREE.Color(cssVar("--gold") || "#D4AF37") }, uSilver: { value: new THREE.Color(cssVar("--silver") || "#e8e8ea") }, uBg: { value: new THREE.Color(cssVar("--bg") || "#050505") } },
      vertexShader: `varying vec3 vP; uniform float uTime; uniform vec2 uPointer; void main(){ vec3 p = position; float band = exp(-abs(p.y) / 240.0); float swirl = sin(uTime*0.08 + p.x*0.002 + p.z*0.002) * 22.0 * band; p.x += swirl; p.z -= swirl * 0.55; p.x += uPointer.x * 40.0 * band; p.y += uPointer.y * 18.0 * band; vP = p; gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0); }`,
      fragmentShader: `varying vec3 vP; uniform float uTime; uniform vec3 uGold; uniform vec3 uSilver; uniform vec3 uBg; float noise(vec3 p){ vec3 i = floor(p); vec3 f = fract(p); f = f*f*(3.0-2.0*f); float n000 = fract(sin(dot(i, vec3(1.0,57.0,113.0))) * 43758.5453); float n100 = fract(sin(dot(i+vec3(1,0,0), vec3(1.0,57.0,113.0))) * 43758.5453); float n010 = fract(sin(dot(i+vec3(0,1,0), vec3(1.0,57.0,113.0))) * 43758.5453); float n110 = fract(sin(dot(i+vec3(1,1,0), vec3(1.0,57.0,113.0))) * 43758.5453); float n001 = fract(sin(dot(i+vec3(0,0,1), vec3(1.0,57.0,113.0))) * 43758.5453); float n101 = fract(sin(dot(i+vec3(1,0,1), vec3(1.0,57.0,113.0))) * 43758.5453); float n011 = fract(sin(dot(i+vec3(0,1,1), vec3(1.0,57.0,113.0))) * 43758.5453); float n111 = fract(sin(dot(i+vec3(1,1,1), vec3(1.0,57.0,113.0))) * 43758.5453); float n00 = mix(n000, n100, f.x); float n10 = mix(n010, n110, f.x); float n01 = mix(n001, n101, f.x); float n11 = mix(n011, n111, f.x); float n0 = mix(n00, n10, f.y); float n1 = mix(n01, n11, f.y); return mix(n0, n1, f.z); } float fbm(vec3 p){ float v = 0.0; float a = 0.5; for(int i=0;i<5;i++){ v += a * noise(p); p *= 2.02; a *= 0.5; } return v; } void main(){ float band = exp(-abs(vP.y) / 170.0); vec3 q = vP * 0.0018 + vec3(0.0, 0.0, uTime*0.015); float n = fbm(q*3.0); float m = fbm(q*6.0 + 12.3); float cloud = smoothstep(0.35, 0.92, n) * band; float dust = smoothstep(0.25, 0.85, m) * band; float grad = clamp(0.5 + 0.5*sin(vP.x*0.002 + uTime*0.06), 0.0, 1.0); vec3 mixc = mix(uSilver, uGold, grad); vec3 c = uBg; c += mixc * (0.18*cloud + 0.12*dust); c += uGold * (0.06 * band); c = clamp(c, 0.0, 1.0); gl_FragColor = vec4(c, 1.0); }`
    })
  );
  scene.add(nebula);

  const planets = new THREE.Group(); scene.add(planets);
  const ringGroup = new THREE.Group(); planets.add(ringGroup);
  const ringTiltX = 0.38, ringTiltZ = -0.12; ringGroup.rotation.x = ringTiltX; ringGroup.rotation.z = ringTiltZ;
  const raycaster = new THREE.Raycaster(); let hovered = null;

  function labelSprite(text){
    const w=1200, h=380, c=document.createElement("canvas"); c.width=w; c.height=h; const g=c.getContext("2d");
    const bg = g.createLinearGradient(0,0,w,h); bg.addColorStop(0,"rgba(232,232,234,0.16)"); bg.addColorStop(0.55,"rgba(212,175,55,0.12)"); bg.addColorStop(1,"rgba(232,232,234,0.08)");
    const r=52; g.beginPath(); g.moveTo(r,0); g.lineTo(w-r,0); g.quadraticCurveTo(w,0,w,r); g.lineTo(w,h-r); g.quadraticCurveTo(w,h,w-r,h); g.lineTo(r,h); g.quadraticCurveTo(0,h,0,h-r); g.lineTo(0,r); g.quadraticCurveTo(0,0,r,0); g.closePath(); g.fillStyle = bg; g.fill(); g.strokeStyle = "rgba(255,255,255,0.18)"; g.lineWidth = 2; g.stroke();
    g.shadowColor = "rgba(212,175,55,0.26)"; g.shadowBlur = 14;
    g.fillStyle = "rgba(255,255,255,0.94)"; g.textAlign = "center"; g.textBaseline = "middle"; g.font = "800 90px 'Latin Modern Sans','Latin Modern Roman',system-ui,sans-serif";
    const pad=48, maxW=w-pad*2, words=String(text).split(/\s+/).filter(Boolean);
    let line="", lines=[]; for(let i=0;i<words.length;i++){ const test=line? (line+" "+words[i]) : words[i]; if(g.measureText(test).width<=maxW) line=test; else{ lines.push(line); line=words[i]; } } if(line) lines.push(line);
    const lineH=104, y0=h/2 - ((lines.length-1)*lineH)/2; for(let i=0;i<lines.length;i++) g.fillText(lines[i], w/2, y0+i*lineH);
    const tex=new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; tex.anisotropy = 8;
    const spr=new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false })); spr.scale.set(100, 36, 1); spr.userData._labelText = text; return spr;
  }

  const baseTextures = buildBaseTextures();
  const planetMaterial = (art) => {
    let map = baseTextures.earth; if(art.textureKey==="moon") map=baseTextures.moon; else if(art.textureKey==="mars") map=baseTextures.mars; else if(art.textureKey==="venus") map=baseTextures.venus; else if(art.textureKey==="mc") map=baseTextures.mc;
    return new THREE.MeshStandardMaterial({ map, roughness:0.75, metalness:0.15 });
  };
  const atmosphereMaterial = (color, opacity) => new THREE.ShaderMaterial({
    transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, uniforms:{ uColor:{ value:new THREE.Color(color) }, uOpacity:{ value:opacity } },
    vertexShader: `varying vec3 vNormal; void main(){ vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
    fragmentShader: `varying vec3 vNormal; uniform vec3 uColor; uniform float uOpacity; void main(){ float i = pow(0.65 - dot(vNormal, vec3(0,0,1)), 2.8); gl_FragColor = vec4(uColor, i*uOpacity); }`
  });

  const entries = [];
  function buildSaturnRings(innerR, outerR){
    ringGroup.clear(); const gold = new THREE.Color(cssVar("--gold") || "#D4AF37"), silv = new THREE.Color(cssVar("--silver") || "#e8e8ea");
    const makeRing = (r0, r1, opacity, z, tintMix)=>{
      const geo = new THREE.RingGeometry(r0, r1, 192, 1);
      const mat = new THREE.ShaderMaterial({
        transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
        uniforms:{ uTime:{ value:0 }, uGold:{ value: gold.clone() }, uSilv:{ value: silv.clone() }, uOpacity:{ value: opacity }, uTint:{ value: tintMix } },
        vertexShader: `varying vec2 vUv; varying vec3 vPos; void main(){ vUv = uv; vec4 wp = modelMatrix * vec4(position,1.0); vPos = wp.xyz; gl_Position = projectionMatrix * viewMatrix * wp; }`,
        fragmentShader: `varying vec2 vUv; varying vec3 vPos; uniform float uTime; uniform vec3 uGold; uniform vec3 uSilv; uniform float uOpacity; uniform float uTint; float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); } float noise(vec2 p){ vec2 i = floor(p); vec2 f = fract(p); f = f*f*(3.0-2.0*f); float a = hash(i); float b = hash(i+vec2(1.0,0.0)); float c = hash(i+vec2(0.0,1.0)); float d = hash(i+vec2(1.0,1.0)); return mix(mix(a,b,f.x), mix(c,d,f.x), f.y); } void main(){ float r = length(vUv - 0.5) * 2.0; float g = noise((vUv-0.5)*vec2(180.0, 28.0) + uTime*0.02); float streak = noise((vUv-0.5)*vec2(420.0, 44.0) - uTime*0.01); float a = (0.55 + 0.45*g) * (0.55 + 0.45*streak); float edge = smoothstep(0.98, 0.65, r) * smoothstep(0.02, 0.18, r); a *= edge; vec3 c = mix(uSilv, uGold, uTint + 0.15*sin(vUv.x*20.0)); gl_FragColor = vec4(c, a * uOpacity); }`
      });
      const m = new THREE.Mesh(geo, mat); m.position.z = z; ringGroup.add(m); return m;
    };
    const rings = []; rings.push(makeRing(innerR, outerR, 0.22, 0.0, 0.55)); rings.push(makeRing(innerR*1.02, outerR*0.985, 0.16, 0.06, 0.35)); rings.push(makeRing(innerR*1.06, outerR*0.96, 0.12, -0.06, 0.70)); return rings;
  }

  function wrapAngle(a){ const two = Math.PI*2; a = a % two; return a < 0 ? a + two : a; }
  function angleDist(a,b){ const two = Math.PI*2; let d = Math.abs(a-b) % two; return d > Math.PI ? two - d : d; }
  function enforceAngularSeparation(){
    const n = entries.length; if (n <= 1) return; const minGapBase = 0.64;
    for (let it=0; it<22; it++){
      let moved = 0; const idx = entries.map((p)=>p).sort((a,b)=>a.angle - b.angle);
      for (let k=0;k<n;k++){ const A = idx[k], B = idx[(k+1)%n], gapNeed = minGapBase + 0.010*(A.radius + B.radius), d = angleDist(A.angle, B.angle); if (d < gapNeed){ const push = (gapNeed - d) * 0.5; A.angle = wrapAngle(A.angle - push); B.angle = wrapAngle(B.angle + push); moved++; } } if (!moved) break;
    }
  }
  function applyOrbitPosition(p){
    const r = p.ringR * (1.0 + p.rMod), x = Math.cos(p.angle) * r, y = Math.sin(p.angle) * r, z = p.zMod;
    const pos = new THREE.Vector3(x,y,0); pos.applyEuler(new THREE.Euler(ringTiltX, 0, ringTiltZ, "XYZ")); pos.z += z;
    p.mesh.position.copy(pos); p.atmo.position.copy(pos); p.label.position.copy(pos);
    const offset = (p.radius + 42 * p.scale * p.labelScaleMult), up = new THREE.Vector3(0,1,0).applyEuler(new THREE.Euler(ringTiltX, 0, ringTiltZ, "XYZ")), sign = (y >= 0) ? 1 : -1;
    p.label.position.addScaledVector(up, offset * sign * 0.6); 
    p.label.quaternion.copy(camera.quaternion);
  }
  function disposeObject(obj){ obj.traverse((o)=>{ if (o.geometry) o.geometry.dispose(); if (o.material){ if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose && m.dispose()); else o.material.dispose && o.material.dispose(); } if (o.material && o.material.map) o.material.map.dispose && o.material.map.dispose(); }); }
  function rebuildLabelTextures(){
    for (const p of entries){ const spr = p.label; if (!spr || !spr.userData || !spr.userData._labelText) continue; const newSpr = labelSprite(spr.userData._labelText); newSpr.scale.copy(spr.scale); newSpr.position.copy(spr.position); newSpr.quaternion.copy(spr.quaternion); newSpr.userData.article = spr.userData.article; planets.remove(spr); planets.add(newSpr); p.label = newSpr; }
  }

  let ringMeshes = [];
  function buildPlanets(){
    for (let i = planets.children.length - 1; i >= 0; i--) { const ch = planets.children[i]; if (ch !== ringGroup) { planets.remove(ch); try{ disposeObject(ch); }catch(_){} } }
    entries.length = 0;
    let w = window.innerWidth, h = window.innerHeight; if (!w || !h) { w = 1024; h = 768; } const isMobile = w < 800, aspect = w / h, dist = 220, vH = 2 * dist * Math.tan((52 * Math.PI / 180) / 2), vW = vH * aspect;
    let scale = Math.min(vW / 560, vH / 560); if (!Number.isFinite(scale)) scale = 1.0;
    const finalScale = Math.max(scale, 0.22), ringR = 142 * finalScale, ringInner = ringR * 0.78, ringOuter = ringR * 1.12;
    ringMeshes = buildSaturnRings(ringInner, ringOuter);
    const planetBaseRadius = isMobile ? 50 : 25, labelScaleMult = isMobile ? 2.05 : 1.0;
    const n = ARTICLES.length;
    for (let i=0;i<n;i++){
      const art = ARTICLES[i], radius = planetBaseRadius * finalScale;
      const mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 64, 64), planetMaterial(art)); mesh.userData.article = art; mesh.userData.radius = radius;
      let atColor = "#90b0ff"; if(art.textureKey==="earth") atColor = "#0066ff"; else if(art.textureKey==="mars") atColor = "#ff4400"; else if(art.textureKey==="venus") atColor = "#ffd080"; else if(art.textureKey==="mc") atColor = "#a7b7ff"; else atColor = "#cfd3ff";
      const atmo = new THREE.Mesh(new THREE.SphereGeometry(radius*1.06, 64, 64), atmosphereMaterial(atColor, 0.45)); atmo.userData.article = art;
      const label = labelSprite(art.title); label.scale.multiplyScalar(finalScale * labelScaleMult); label.userData.article = art;
      const baseAngle = (i / n) * Math.PI*2 + Math.PI/5;
      entries.push({ mesh, atmo, label, radius, angle: baseAngle, angVel: 0, rMod: 0, zMod: 0, ringR, hoverPull: 0, scale: finalScale, labelScaleMult });
      planets.add(mesh); planets.add(atmo); planets.add(label);
    }
    enforceAngularSeparation(); for (const p of entries) applyOrbitPosition(p);
  }
  buildPlanets();
  if (document.fonts && document.fonts.ready) { document.fonts.ready.then(()=>rebuildLabelTextures()).catch(()=>{}); }

  function getClientXY(ev){ if (ev && ev.changedTouches && ev.changedTouches.length) return { x: ev.changedTouches[0].clientX, y: ev.changedTouches[0].clientY }; if (ev && ev.touches && ev.touches.length) return { x: ev.touches[0].clientX, y: ev.touches[0].clientY }; return { x: ev.clientX, y: ev.clientY }; }
  function setPointerFromEvent(ev){ const r = canvas.getBoundingClientRect(); const p = getClientXY(ev); const x = (p.x - r.left) / Math.max(1, r.width); const y = (p.y - r.top) / Math.max(1, r.height); pointer.x = x * 2 - 1; pointer.y = -(y * 2 - 1); px = clamp(p.x - r.left, 0, r.width); py = clamp(p.y - r.top, 0, r.height); pointerActive = true; }
  let lastTapAt = 0, tapStart = null;
  function tryPick(ev){ if (modal.classList.contains("open")) return; setPointerFromEvent(ev); raycaster.setFromCamera(pointer, camera); const hits = raycaster.intersectObjects(planets.children, true).filter(h => h.object && h.object.userData && h.object.userData.article); if (hits.length > 0){ openArticle(hits[0].object.userData.article); } }
  function onTapStart(ev){ if (modal.classList.contains("open")) return; const p = getClientXY(ev); tapStart = { x: p.x, y: p.y, t: performance.now() }; setPointerFromEvent(ev); if (ev.cancelable) ev.preventDefault(); }
  function onTapEnd(ev){ if (!tapStart) { tryPick(ev); return; } const p = getClientXY(ev); const dt = performance.now() - tapStart.t; const dx = Math.abs(p.x - tapStart.x); const dy = Math.abs(p.y - tapStart.y); tapStart = null; if (dt < 450 && dx < 14 && dy < 14){ const now = performance.now(); if (now - lastTapAt < 220) return; lastTapAt = now; tryPick(ev); } if (ev.cancelable) ev.preventDefault(); }
  function onPointerMove(e){ setPointerFromEvent(e); }
  canvas.addEventListener("pointermove", onPointerMove, { passive:true }); canvas.addEventListener("pointerdown", onTapStart, { passive:false }); canvas.addEventListener("pointerup", onTapEnd, { passive:false }); canvas.addEventListener("touchstart", onTapStart, { passive:false }); canvas.addEventListener("touchend", onTapEnd, { passive:false }); canvas.addEventListener("touchcancel", ()=>{ tapStart = null; }, { passive:true }); canvas.addEventListener("click", (e)=>{ tryPick(e); }, { passive:true });

  const clock = new THREE.Clock(); let eqItems = buildEquationLayer(); const starAnim = { time: 0, rotY: 0, rotZ: 0 };
  window.__RECOLOR__ = function(){ nebula.material.uniforms.uGold.value.set(cssVar("--gold") || "#D4AF37"); nebula.material.uniforms.uSilver.value.set(cssVar("--silver") || "#e8e8ea"); nebula.material.uniforms.uBg.value.set(cssVar("--bg") || "#050505"); scene.background.set(cssVar("--bg") || "#050505"); if (ringMeshes && ringMeshes.length){ const gold = new THREE.Color(cssVar("--gold") || "#D4AF37"), silv = new THREE.Color(cssVar("--silver") || "#e8e8ea"); ringMeshes.forEach(m=>{ if (m.material && m.material.uniforms){ m.material.uniforms.uGold.value.copy(gold); m.material.uniforms.uSilv.value.copy(silv); } }); } };
  const _targetScale = new THREE.Vector3();

  function tick(){
    const dt = Math.min(0.033, clock.getDelta()), t = clock.getElapsedTime();
    const rect = canvas.getBoundingClientRect(); const nx = pointerActive ? (px / Math.max(1, rect.width) - 0.5) : 0.0, ny = pointerActive ? (py / Math.max(1, rect.height) - 0.5) : 0.0;
    camera.position.x = lerp(camera.position.x, nx * 26, 0.06); camera.position.y = lerp(camera.position.y, (-ny) * 12, 0.06); camera.lookAt(0,0,0);
    nebula.material.uniforms.uTime.value = t; nebula.material.uniforms.uPointer.value.set(nx, -ny);
    if (pointerActive && !modal.classList.contains("open")){ raycaster.setFromCamera(pointer, camera); const hits = raycaster.intersectObjects(planets.children, true); const hit = hits.find(h => h.object && h.object.userData && h.object.userData.article); const newHover = hit ? hit.object : null; if (hovered !== newHover){ hovered = newHover; document.body.style.cursor = hovered ? "pointer" : "default"; } } else { if (hovered !== null){ hovered = null; document.body.style.cursor = "default"; } }
    const isHoveringPlanet = !!(hovered && hovered.userData && hovered.userData.article);
    if (!isHoveringPlanet){ starAnim.time += dt; starAnim.rotY += dt * 0.05; starAnim.rotZ = Math.cos(starAnim.time*0.04)*0.06; }
    stars.material.uniforms.uTime.value = starAnim.time; stars.material.uniforms.uDpr.value = DPR(); galaxy.rotation.y = starAnim.rotY; galaxy.rotation.z = starAnim.rotZ;
    if (ringMeshes && ringMeshes.length){ ringMeshes.forEach(m=>{ if (m.material && m.material.uniforms) m.material.uniforms.uTime.value = t; }); ringGroup.rotation.y = Math.sin(t*0.05)*0.06; }
    const n = entries.length;
    for (let i=0;i<n;i++){
      const p = entries[i], m = p.mesh; m.rotation.y += dt * (0.65 + i*0.03); m.rotation.x += dt * 0.008;
      const isHover = isHoveringPlanet && (hovered.userData.article === m.userData.article);
      p.hoverPull = lerp(p.hoverPull, isHover ? 1 : 0, 0.12);
      const baseSpin = 0.012, steer = pointerActive ? (nx * 0.015) : 0.0, hoverSteer = p.hoverPull * (nx*0.20) * 0.02;
      p.angVel = lerp(p.angVel, baseSpin + steer + hoverSteer, 0.05);
      const wob = Math.sin(t*0.7 + i*1.7) * 0.0009; p.angle = wrapAngle(p.angle + (p.angVel + wob) * dt);
      const rTarget = isHover ? 0.030 : 0.0; p.rMod = lerp(p.rMod, rTarget, 0.09);
      const zTarget = isHover ? 24.0 : 0.0; p.zMod = lerp(p.zMod, zTarget, 0.10);
    }
    for (let it=0; it<2; it++) enforceAngularSeparation();
    for (let i=0;i<n;i++){ const p = entries[i]; const isHover = isHoveringPlanet && (hovered.userData.article === p.mesh.userData.article); applyOrbitPosition(p); const s = isHover ? 1.10 : 1.0; _targetScale.set(s, s, s); p.mesh.scale.lerp(_targetScale, 0.10); _targetScale.set(s*1.02, s*1.02, s*1.02); p.atmo.scale.lerp(_targetScale, 0.10); }
    $("depthName").style.transform = "translate(-50%, -50%)";
    const w = window.innerWidth, h = window.innerHeight;
    for (let i=0;i<eqItems.length;i++){ const it = eqItems[i]; it.a += dt * it.s; const rr = (0.18 + it.r*0.82), x = (0.5 + 0.46*Math.cos(it.a) * rr) * w + it.ox, y = (0.5 + 0.36*Math.sin(it.a*0.92 + it.ph) * rr) * h + it.oy, op = 0.18 + 0.12*(0.5+0.5*Math.sin(t*0.35 + i)); it.el.style.opacity = String(op); it.el.style.transform = `translate3d(${x}px, ${y}px, 0) rotate(${Math.sin(it.a)*2.0}deg)`; }
    renderer.render(scene, camera); requestAnimationFrame(tick);
  }

  function onResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setPixelRatio(DPR()); renderer.setSize(window.innerWidth, window.innerHeight, false); buildPlanets(); eqItems = buildEquationLayer(); if (document.fonts && document.fonts.ready) document.fonts.ready.then(()=>rebuildLabelTextures()).catch(()=>{}); }
  window.addEventListener("resize", onResize, { passive:true });
  
  // -- EVENT WIRING (Securely) --
  const brand = document.getElementById("brand");
  brand.addEventListener("click", ()=>camera.position.set(0,0,220)); brand.addEventListener("keydown", (e)=>{ if (e.key==="Enter"||e.key===" "){ e.preventDefault(); camera.position.set(0,0,220); } });
  
  const themeBtn = document.getElementById("theme");
  themeBtn.addEventListener("click", ()=>{ const cur = root.getAttribute("data-theme") || "dark"; applyTheme(cur === "dark" ? "light" : "dark", true); });
  
  // Attach Lab Open handlers securely (CSP fix)
  document.querySelectorAll('.lab-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
          const type = e.currentTarget.getAttribute('data-type');
          if(type) Lab.open(type);
      });
  });

  applyTheme(getInitialTheme(), false); tick();

}catch(e){ showErr(e); }
})();
</script>
</body>
</html>
